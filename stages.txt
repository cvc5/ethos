Run:

./build-debug/run_gen_vc <proof-rule>

At a high-level, the correctness of a Eunoia proof rule can be compiled to
a *.smt2 file, which if unsat, is evidence that the proof rule is sound.
Alternatively, we can compile to Lean, where a Lean theorem gives
the correctness property to prove for the rule.
In both cases, the final encoding uses a deep embedding where:
- A datatype "eo.Term" is declared, which several builtin constructors, e.g.
  eo.Stuck and eo.Apply.
- All constants in the Eunoia signature are constructors of this datatype.

In the SMT encoding:
- Eunoia programs are uninterpreted functions.
- Definitions of Eunoia programs are quantified axioms.
- If a Eunoia program is forward declared but not defined, then it is
a free uninterpreted function in the final encoding.

In the Lean encoding:
- Eunoia programs are Lean definitions.

The entire pipeline relies on:
- Bash scripting,
- Ethos (~10k LOC C++), and depends on GMP
  - The majority of its parser is used in the compilation.
- A standard Ethos plugin infrastructure, 133 LOC C++

Below summarizes where certain corner cases are handled when using
cvc5 -> Cpc.eo -> desugared *.eo -> model-smt *.eo -> smt2|lean.

=== cvc5 parsing

Relies on:
- cvc5 parser source code

Things handled at this stage:

- let as a parsing construct, not a binder.
- global variable semantics, i.e. variables are unique up to their name and
  type (different from SMT-LIB?)
- Numeral as Decimal in logics without Integers.
- :named.

=== cvc5 API 

Relies on:
- cvc5 API code

Things handled at this stage:
- Desugaring of :chainable, some of the :left-assoc, :right-assoc operators.
  This desugaring is mirror in the CPC signature/Ethos parser.

=== cvc5 internals -> CPC proof 

Relies on:
- cvc5 source code

Things handled at this stage:
- Modifications made to input -> proof assumptions in solver_engine.cpp:
  - define-fun-rec desugared to declare-fun + assert forall.
  - Mixed arithmetic is silently eliminated.
- Modifications made in proof printer:
  - match, desugared to ITE
  - some FP operators renamed
  - Currying of ProofRule::SCOPE.

=== Ethos parser

Things handled at this stage:
- Operator properties.
  - :right-assoc-nil, :right-assoc, :left-assoc-nil, :left-assoc, :chainable, :binder, :let-binder
- Desugar n-ary literal ops to binary (e.g. (eo::add a b c) -> (eo::add (eo::add a b) c)).

=== Desugar

Compiles *.eo to *.eo.
The resulting *.eo is desugared to define non-essential Eunoia features as Eunoia programs.
Includes a forward declaration of a side condtion $eo_model_sat.
Optionally, a proof rule can be compiled to a Eunoia program $eor_X which
operates over *formulas* not proofs. Additionally, we may generate a 
Eunoia program $eovc_X which:
- Calls $eo_model_sat and $eor_X.
- Evaluates successfully iff the proof rule is unsound.
This side condition is the target for verification in the Smt_Meta step below.

Relies on:
- eo_desugar.eo template, 304 LOC EO
- desugar.cpp (ethos plugin), 1078 LOC C++
- (Optional) trim_defs.cpp (ethos plugin), 305 LOC C++
  - Slices the signature, preserves S-expressions.
  - Needed to make the VCs more manageable.
- (Optional) desugaring of an executable checker
  - eo_desugar_checker.eo, 134 LOC EO
  - desugar_checker.h/cpp, 219 LOC C++
- (Optional) desugaring of proof scripts
  - desugar_proof.h/cpp, 152 LOC C++

Things handled at this stage:
- define commands inlined
- (Optional) flattening of evaluation
  - All evaluation nested inside of ordinary applications are lifted. This effectively
    ensures that stuckness propagates eagerly through ordinary constant applications.
  - Each instance of eo::requires, eo::ite converted to a program.
- declare-rule
  - Proof type handled as part of the VC generation function ($eovc_X).
- declare-consts
  - $eo_Numeral, $eo_Rational, $eo_String, $eo_Binary as references to builtin types.
- Operator overloading.
  - Introduces "$eoo_X.N" as a convention for overloaded symbols.
- Ambiguously typed functions are converted to unambiguous functions having
  an opaque type argument and a helper program invoked on this type. This means
  e.g. (as nil (List Int)) becomes (nil (List Int)) after desugaring, where
  this is an opaque application.
- Desugaring template:
  - eo::cons
  - eo::list_len, eo::list_concat, eo::list_nth, eo::list_find, eo::list_rev, eo::list_erase,
    eo::list_erase_all, eo::list_setof, eo::list_minclude, eo::list_meq
  - eo::nil
    - Includes an auto-generation of cases for each :right-assoc-nil, :left-assoc-nil operator.
  - (All user-defined symbol cases of) eo::dt_constructors, eo::dt_selectors
  - (All user-defined symbol cases of) eo::typeof
    - *Approximates* the internal type system of Eunoia (monomorphizes partial applications).
      - For example, we give a type rule for (= x), not =.
    - Includes an auto-generation of cases for all user symbols ($eo_typeof_main).
- declare-datatype/declare-datatypes is eliminated, effectively turned into a
  set of ordinary types and constants. The semantics of datatypes, constructors
  and selectors is preserved based on the auto-generation of eo::dt_constructors
  and eo::dt_selectors.

=== Model_smt

Compiles *.eo to *.eo.
Includes a definition of $eo_model_sat, which defines SMT-LIB model semantics.

Relies on:
- smt_embed.eo, 192 LOC EO
  - Defines infrastructure for references to native SMT types.
  - Defines operations on pairs of integers to mimic parameteric bitvector operations.
  - Defines SMT datatypes and datatype constructors.
- eo_builtin_smt.eo, 487 LOC EO
  - Defines the SMT-like builtins of Eunoia
  - Declares all terms in the SMT-LIB deep embedding
- model_smt.eo, 709 LOC EO
  - Model semantics $eo_model_sat
- model_smt.cpp (ethos plugin), 1437 LOC C++
- (Optional) trim_defs.cpp (ethos plugin), also used above

Things handled at this stage:
- Reduces many Eunoia builtins to SMT-LIB literal semantics
  - eo::eq
  - eo::not, eo::and, eo::or, eo::xor
  - eo::add, eo::mul, eo::qdiv, eo::zdiv, eo::zmod, eo::is_neg, eo::neg
  - eo::len, eo::concat, eo::extract, eo::find
  - eo::to_z, eo::to_q, eo::to_bin, eo::to_str
  - eo::var, eo::nameof
    - Represents variables as constant $eo_Var.
- Macros that could be defined in terms of those above, we do them here to not
  introduce forward references (i.e. desugaring that calls eo::):
  - eo::is_eq, eo::is_z, eo::is_q, eo::is_bin, eo::is_str, eo::is_bool, eo::is_var
  - eo::gt, eo::cmp
- eo::typeof completed
  - Includes definitions of literal types, and type of variables ($eo_Var).
  - Reference to previously defined $eo_typeof_main.
- Core Eunoia builtins defined.
  - eo::is_ok which reasons about the *deep embedding* of the SMT-LIB datatype we are defining.
    In particular, $eo_is_ok asks whether the deep embedding of the term under test
    in the datatype constructor eo.Stuck.
- SMT-LIB semantics (model_smt.eo).
  - Map utility
    - Used for array or function values. Operations for lookup, canonical update.
    - Specialized for sets. Utilities for basic operations on sets.
  - Sequence utility.
    - Used for sequence values.
  - Defines a core evaluation semantics ($smt_model_eval), having cases:
    - Function application.
    - Auto-generated in various forms
      - Term reductions "this operator evaluates based on the evaluation of this term"
        - e.g. (bvsle x1 x2) is (bvsge x2 x1).
      - Constant folding auxiliary functions "this operator evaluates the arguments then calls the SMT-LIB operator on the result"
        - e.g. (+ x1 x2) is ($smt_apply_2 "+" ($evaluate x1) ($evaluate x2))
      - Hard-coded cases "this operator uses the custom function defined in this signature".
        - e.g. (select x1 x2) is ($smtx_map_select ($evaluate x1) ($evaluate x2)).
    - Overloading arithmetic uses multi-case programs.
    - Reverts operator overload, recognizes "$eoo_-.2" as SMT-LIB "-".
  - Forward declaration of type enumeration ($smt_model_type_enum)


=== Smt_Meta

Compiles *.eo to *.smt2.
Constructs the deep embedding of Eunoia terms (eo.Term),
SMT terms (sm.Term), SMT types (tsm.Type), SMT values (vsm.Value) as
well as specific datatypes for modelling SMT values.
Implements a policy that interprets opaque arguments as constructor arguments
and distinguished names for Eunoia types and operators to mark native SMT types
and operators.
Optimizes for non-recursive programs using define-fun.
Generates a conjecture for a Eunoia program under test (e.g. $eovc_X)
which states the $eovc_X program does not get stuck for some input.
This means we are searching over the *syntactic space* of Eunoia terms
to find terms that witness the semantic unsoundness of the rule.

Relies on:
- smt_meta.smt2 template, 84 LOC SMT2
- smt_meta_reduce.cpp (ethos plugin), 1057 LOC C++
- (Optional) smt_meta_sygus.cpp, 483 LOC C++
  - Constructs an alternative *.sy file for SyGuS.

Things handled at this stage:
- The final deep embedding
  - Eunoia Terms (eo.Term)
  - SMT-LIB Values (vsm.Value)
    - Has constructors for certain custom data values (maps, sequences).
    - Note that values are disjoint from terms.
- Function types become ordinary applications e.g. (-> T1 T2) ---> (_ (_ -> T1) T2).
- Eunoia semantics of pattern matching based on datatype selectors/testers.
- Symbols introduced for deep embedding in Model_Smt $smt_apply_N, $smt_type_N.
- Remaining eo::define and define commands inlined.
- Axiom for eo::hash
- :opaque on user symbols becomes part of the deep embedding.
  - For example a constructor like:
      (declare-parameterized-const const ((id Int :opaque) (T Type :opaque)) T)
    becomes the datatype constructor with arity 2:
      (eo.@const (eo.@const.arg1 Int) (eo.@const.arg2 eo.Term))
    whereas:
      (declare-parameterized-const and (-> Bool Bool Bool))
    becomes the nullary constructor:
      (eo.And)

=== Lean_Meta

Compiles *.eo to *.lean.
Similar to Smt_Meta, implements a policy that interprets opaque arguments as
constructor arguments and distinguished names for Eunoia types and operators
to indicate native Lean types and operators.

Relies on:
- lean_meta.lean template, 270 LOC Lean
- lean_meta_reduce.cpp (ethos plugin), 1011 LOC C++
- (Optional) linear_patterns.cpp (ethos plugin), 162 LOC C++
  - Linearizes patterns in Eunoia programs

Things handled at this stage:
- Constructs correctness theorems for the individual rules and the overall checker.

===

Not handled:
- Well foundedness of all Eunoia programs. This can lead to spurious unsoundess in the Smt_Meta step.
  - TODO: well foundedness as a Eunoia program
- Modelling of assume-push/step-pop.
- TODO: modelling of :conclusion-explicit, :assumption.
- TODO: unconstrained semantics of datatype constructors and selectors
- TODO: axiom for type enumeration.
- TODO: we could construct another intermediate *.eo where all types are
  replaced by those in the deep embedding.

===

Future research:
- Fuzz Ethos to make sure it is syncronized with desugaring semantics.
- Lean_Meta or Isabelle_Meta plugin, either:
  - A reimplementation of the above meta-prover in Lean.
  - Use cvc5 to prove meta-theorems and replay them for each proof rule.
- Parametric bitvectors in cvc5 to prove VCs.
- Logos: reimplementation of ethos whose native language is desugared *.eo. It should be formally verified to incorporate some stages of the above pipeline.
- Telos: an SMT solver API to run cvc5 -> proof API -> ethos/logos.
- Alethe to Eunoia.
- Agda_Meta, Deduckti_Meta?
