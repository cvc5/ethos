Run:

./build-debug/run_gen_vc <proof-rule>

At a high-level, the correctness of a Eunoia proof rule can be compiled to
a *.smt2 file, which if unsat, is evidence that the proof rule is sound.
The final encoding uses a deep embedding where:
- A datatype "eo.Term" is declared, which several builtin constructors, e.g.
  eo.Stuck and eo.Apply.
- All constants in the Eunoia signature are constructors of this datatype.
- Eunoia programs are uninterpreted functions.
- Definitions of Eunoia programs are quantified axioms.
Note that if a Eunoia program is forward declared but not defined, then it is
a free uninterpreted function in the final encoding.

The entire pipeline relies on:
- Bash scripting,
- Ethos (~10k LOC C++), and depends on GMP
  - The majority of its parser is used in the compilation.
- A standard Ethos plugin infrastructure, 133 LOC C++

Below summarizes where certain corner cases are handled when using
cvc5 -> Cpc.eo -> desugared *.eo -> model-smt *.eo -> smt2.

=== cvc5 parsing

Relies on:
- cvc5 parser source code

Things handled at this stage:

- let as a parsing construct, not a binder.
- global variable semantics, i.e. variables are unique up to their name and
  type (different from SMT-LIB?)
- Numeral as Decimal in logics without Integers.
- :named.

=== cvc5 API 

Relies on:
- cvc5 API code

Things handled at this stage:
- Desugaring of :chainable, some of the :left-assoc, :right-assoc operators.
  This desugaring is mirror in the CPC signature/Ethos parser.

=== cvc5 internals -> CPC proof 

Relies on:
- cvc5 source code

Things handled at this stage:
- define-fun-rec, desugared to declare-fun + assert forall.
- match, desugared to ITE
- some FP operators renamed
- Currying of ProofRule::SCOPE.

=== Ethos parser

Things handled at this stage:
- Non-essential Eunoia commands (declare-type/define-type).
- Operator properties.
  - :right-assoc-nil, :right-assoc, :left-assoc-nil, :left-assoc, :chainable, :binder, :let-binder
- Desugar n-ary literal ops to binary (e.g. (eo::add a b c) -> (eo::add (eo::add a b) c)).

=== Desugar

Compiles *.eo to *.eo.
The resulting *.eo is desugared to define non-essential Eunoia features as Eunoia programs.
Includes a forward declaration of a side condtion $eo_model_sat.
Optionally, a proof rule can be compiled to a Eunoia program $eor_X which
operates over *formulas* not proofs. Additionally, we may generate a 
Eunoia program $eovc_X which:
- Calls $eo_model_sat and $eor_X.
- Evaluates successfully iff the proof rule is unsound.
This side condition is the target for verification in the Smt_Meta step below.

Relies on:
- eo_desugar.eo template, 343 LOC EO
- desugar.cpp (ethos plugin), 1307 LOC C++
- (Optional) trim_defs.cpp (ethos plugin), 305 LOC C++
  - Slices the signature, preserves S-expressions.
  - Needed to make the VCs more manageable.
- flatten_eval.cpp (ethos utility), 477 LOC C++
  - Converts programs to a list of programs with no nested evaluation.

Things handled at this stage:
- define commands inlined
- Flattening of evaluation
  - All evaluation nested inside of ordinary applications are lifted. This effectively
    ensures that stuckness propagates eagerly through ordinary constant applications.
  - Each instance of eo::requires, eo::ite converted to a program.
- declare-rule
  - Proof type handled as part of the VC generation function ($eovc_X).
- declare-consts
  - $eo_Numeral, $eo_Rational, $eo_String, $eo_Binary as references to builtin types.
- Operator overloading.
  - Introduces "$eoo_X.N" as a convention for overloaded symbols.
- Desugaring template:
  - eo::eq
  - eo::cons
  - eo::list_len, eo::list_concat, eo::list_nth, eo::list_find, eo::list_rev, eo::list_erase,
    eo::list_erase_all, eo::list_setof, eo::list_minclude, eo::list_meq
  - eo::nil
    - Includes an auto-generation of cases for each :right-assoc-nil, :left-assoc-nil operator.
  - eo::dt_constructors, eo::dt_selectors
  - (All user-defined symbol cases of) eo::typeof
    - *Approximates* the internal type system of Eunoia (monomorphizes partial applications).
      - For example, we give a type rule for (= x), not =.
    - Includes an auto-generation of cases for all user symbols ($eo_typeof_main).

=== Model_smt

Compiles *.eo to *.eo.
Includes a definition of $eo_model_sat, which defines SMT-LIB model semantics.

Relies on:
- eo_builtin_smt.eo, 602 LOC EO
  - Defines the SMT-like builtins of Eunoia
  - Declares all terms in the SMT-LIB deep embedding
- model_smt.eo, 322 LOC EO
  - Model semantics $eo_model_sat
  - SMT-LIB input $eo_model_is_input
- model_smt.cpp (ethos plugin), 944 LOC C++
- trim_defs.cpp (ethos plugin), also used above

Things handled at this stage:
- Reduces many Eunoia builtins to SMT-LIB literal semantics
  - eo::not, eo::and, eo::or, eo::xor
  - eo::add, eo::mul, eo::qdiv, eo::zdiv, eo::zmod, eo::is_neg, eo::neg
  - eo::len, eo::concat, eo::extract, eo::find
  - eo::to_z, eo::to_q, eo::to_bin, eo::to_str
  - eo::var, eo::nameof
    - Represents variables as constant $eo_Var.
- Macros that could be defined in terms of those above, we do them here to not
  introduce forward references (i.e. desugaring that calls eo::):
  - eo::is_eq, eo::is_z, eo::is_q, eo::is_bin, eo::is_str, eo::is_bool, eo::is_var
  - eo::gt, eo::cmp
- eo::typeof completed
  - Includes definitions of literal types, and type of variables ($eo_Var).
  - Reference to previously defined $eo_typeof_main.
- Core Eunoia builtins defined.
  - eo::is_ok which reasons about the *deep embedding* of the SMT-LIB datatype we are defining.
    In particular, $eo_is_ok asks whether the deep embedding of the term under test
    in the datatype constructor eo.Stuck.
- SMT-LIB semantics (model_smt.eo).
  - Map utility
    - Used for array or function values. Operations for lookup, canonical update.
    - Specialized for sets. Utilities for basic operations on sets.
  - Sequence utility.
    - Used for sequence values.
  - Defines a core evaluation semantics ($smt_model_eval)
    - Function application.
    - Auto-generated in various forms
      - Term reductions "this operator evaluates based on the evaluation of this term"
        - e.g. (bvsle x1 x2) is (bvsge x2 x1).
      - Constant folding auxialary functions "this operator evaluates the arguments then calls the SMT-LIB operator on the result"
        - e.g. (+ x1 x2) is ($smt_apply_2 "+" ($evaluate x1) ($evaluate x2))
      - Hard-coded cases "this operator uses the custom function defined in this signature".
        - e.g. (select x1 x2) is ($smtx_map_select ($evaluate x1) ($evaluate x2)).
    - Overloading arithmetic uses multi-case programs.
    - Reverts operator overload, recognizes "$eoo_-.2" as SMT-LIB "-".
  - Forward declaration of type enumeration ($smt_model_type_enum)
  - Existential semantics ($smt_eval_quant)


=== Smt_Meta

Compiles *.eo to *.smt2.
Implements a simple type system which distinguishes Eunoia terms,
SMT terms, SMT types and SMT values.
Optimizes for non-recursive programs using define-fun.
Generates a conjecture for a Eunoia program under test (e.g. $eovc_X)
which states the $eovc_X program does not get stuck for some input.
This means we are searching over the *syntactic space* of Eunoia terms
to find terms that witness the semantic unsoundness of the rule.

Relies on:
- smt_meta.smt2 template, 31 LOC SMT2
- smt_meta_reduce.cpp (ethos plugin), 1504 LOC C++

Things handled at this stage:
- The final deep embedding
  - Eunoia Terms (eo.Term)
    - Embeddings for all 3 SMT-LIB constructs below.
  - SMT-LIB Terms (sm.Term)
  - SMT-LIB Types (tsm.Type)
  - SMT-LIB Values (vsm.Value)
    - Note that values are disjoint from terms. Terms can be embedded into
      values using a distinguished constructor eo.Value, which is not allowed
      in inputs.
- Function types become ordinary applications e.g. (-> T1 T2) ---> (_ (_ -> T1) T2).
- Eunoia semantics of pattern matching based on datatype selectors/testers.
- Symbols introduced for deep embedding in Model_Smt $smt_apply_N, $smt_type_N.
- Remaining eo::define and define commands inlined.
- Axiom for eo::hash
- Ambiguously typed functions retain their "opaque" semantics, which is handled at this step.
- :opaque on user symbols becomes part of the deep embedding.
  - For example a constructor like:
      (declare-parameterized-const const ((id Int :opaque) (T Type :opaque)) T)
    becomes the datatype constructor with arity 2:
      (sm.@const (sm.@const.arg1 Int) (sm.@const.arg2 sm.Term))
    whereas:
      (declare-parameterized-const and (-> Bool Bool Bool))
    becomes the nullary constructor:
      (sm.And)

===

Not handled:
- Well foundedness of all Eunoia programs. This can lead to spurious unsoundess in the Smt_Meta step.
  - TODO: well foundedness as a Eunoia program
- Modelling of assume-push/step-pop.
- TODO: modelling of :conclusion-explicit, :assumption.
- TODO: unconstrained semantics of datatype constructors and selectors
- TODO: axiom for type enumeration.
- TODO: we could construct another intermediate *.eo where all types are
  replaced by those in the deep embedding.

===

Future research:
- Fuzz Ethos to make sure it is syncronized with desugaring semantics.
- Lean_Meta or Isabelle_Meta plugin, either:
  - A reimplementation of the above meta-prover in Lean.
  - Use cvc5 to prove meta-theorems and replay them for each proof rule.
- Parametric bitvectors in cvc5 to prove VCs.
- Logos: reimplementation of ethos whose native language is desugared *.eo. It should be formally verified to incorporate some stages of the above pipeline.
- Telos: an SMT solver API to run cvc5 -> proof API -> ethos/logos.
- Alethe to Eunoia.
- Agda_Meta, Deduckti_Meta?
