Run:

./build-debug/run_gen_vc <proof-rule>

At a high-level, the correctness of a Eunoia proof rule can be compiled to
a *.smt2 file, which if unsat, is evidence that the proof rule is sound.
The final encoding uses a deep embedding where:
- A single datatype "sm.Term" is declared, which several builtin constructors.
- All constants in the Eunoia signature are constructors of this datatype.
- Eunoia programs are uninterpreted functions.
- Definitions of Eunoia programs are quantified axioms.
Note that if a Eunoia program is forward declared but not defined, then it is
a free uninterpreted function in the final encoding.

The entire pipeline relies on:
- Bash scripting,
- Ethos (~10k LOC C++), and depends on GMP
  - The majority of its parser is used in the compilation.
- A standard Ethos plugin infrastructure, 133 LOC C++

Below summarizes where certain corner cases are handled when using
cvc5 -> Cpc.eo -> desugared *.eo -> model-smt *.eo -> smt2.

=== cvc5 parsing

Relies on:
- cvc5 parser source code

Things handled at this stage:

- let as a parsing construct, not a binder.
- global variable semantics, i.e. variables are unique up to their name and
  type (different from SMT-LIB?)
- Numeral as Decimal in logics without Integers.
- :named.

=== cvc5 API 

Relies on:
- cvc5 API code

Things handled at this stage:
- Desugaring of :chainable, some of the :left-assoc, :right-assoc operators.
  This desugaring is mirror in the CPC signature/Ethos parser.

=== cvc5 internals -> CPC proof 

Relies on:
- cvc5 source code

Things handled at this stage:
- define-fun-rec, desugared to declare-fun + assert forall.
- match, desugared to ITE
- some FP operators renamed
- Currying of ProofRule::SCOPE.

=== Ethos parser

Things handled at this stage:
- Non-essential Eunoia commands (declare-type/define-type).
- Operator properties.
  - :right-assoc-nil, :right-assoc, :left-assoc-nil, :left-assoc, :chainable, :binder, :let-binder

=== Desugar

Compiles *.eo to *.eo.
The resulting *.eo is desugared to define non-essential Eunoia features as Eunoia programs.
Includes a forward declaration of a side condtion $eo_model_sat.
Optionally, a proof rule can be compiled to a Eunoia program $eor_X which
operates over *formulas* not proofs. Additionally, we may generate a 
Eunoia program $eovc_X which:
- Calls $eo_model_sat and $eor_X.
- Evaluates successfully iff the proof rule is unsound.
This side condition is the target for verification in the Smt_Meta step below.

Relies on:
- eo_desugar.eo template, 296 LOC EO
- desugar.cpp (ethos plugin), 1023 LOC C++
- (Optional) trim_defs.cpp (ethos plugin), 283 LOC C++
  - Slices the signature, preserves S-expressions.
  - Needed to make the VCs more manageable.
- flatten_eval.cpp (ethos utility), 473 LOC C++
  - Converts programs to a list of programs with no nested evaluation.

Things handled at this stage:
- define commands inlined
- Flattening of evaluation
  - All evaluation nested inside of ordinary applications are lifted. This effectively
    ensures that stuckness propagates eagerly through ordinary constant applications.
  - Each instance of eo::requires, eo::ite converted to a program.
- declare-rule
  - Proof type handled as part of the VC generation function ($eovc_X).
- declare-consts
  - $eo_Numeral, $eo_Rational, $eo_String, $eo_Binary as references to builtin types.
- Operator overloading.
  - Introduces "$eoo_X.N" as a convention for overloaded symbols.
- Desugaring template:
  - eo::eq
  - eo::cons
  - eo::list_len, eo::list_concat, eo::list_nth, eo::list_find, eo::list_rev, eo::list_erase,
    eo::list_erase_all, eo::list_setof, eo::list_minclude, eo::list_meq
  - eo::nil
    - Includes an auto-generation of cases for each :right-assoc-nil, :left-assoc-nil operator.
  - eo::dt_constructors, eo::dt_selectors
  - (All user-defined symbol cases of) eo::typeof
    - *Approximates* the internal type system of Eunoia (monomorphizes partial applications).
      - For example, we give a type rule for (= x), not =.
    - Includes an auto-generation of cases for all user symbols ($eo_typeof_main).

- TODO: ite, requires should be handled here, using "nested-eval-elim" plugin.

=== Model_smt

Compiles *.eo to *.eo.
Includes a definition of $eo_model_sat, which defines SMT-LIB model semantics.

Relies on:
- eo_builtin_smt.eo, 525 LOC EO
  - Defines the SMT-like builtins of Eunoia
- model_smt.eo, 220 LOC EO
- model_eo_embed.eo template, 19 LOC
- model_smt.cpp (ethos plugin), 377 LOC C++
- trim_defs.cpp (ethos plugin), also used above

Things handled at this stage:
- Model preamble reduces many Eunoia builtins to SMT-LIB literal semantics (model_smt_preamble.eo)
  - eo::not, eo::and, eo::or, eo::xor
  - eo::add, eo::mul, eo::qdiv, eo::zdiv, eo::zmod, eo::is_neg, eo::neg
  - eo::len, eo::concat, eo::extract, eo::find
  - eo::to_z, eo::to_q, eo::to_bin, eo::to_str
  - eo::var, eo::nameof
    - Represents variables as constant $eo_Var.
- Macros that could be defined in terms of those above, we do them here to not
  introduce forward references (i.e. desugaring that calls eo::):
  - eo::is_eq, eo::is_z, eo::is_q, eo::is_bin, eo::is_str, eo::is_bool, eo::is_var
  - eo::gt, eo::cmp
- eo::typeof completed
  - Includes definitions of literal types, and type of variables ($eo_Var).'
  - Reference to previously defined $eo_typeof_main.
- Core Eunoia builtins defined.
  - eo::is_ok which reasons about the *deep embedding* of the SMT-LIB datatype we are defining.
    In particular, $eo_is_ok asks whether the deep embedding of the term under test
    in the datatype constructor eo.Stuck.
- SMT-LIB semantics (model_smt.eo).
  - Valueness ($smt_is_value)
    - Builtin atomics.
    - Datatypes.
    - Function and array values.
  - Type enumeration ($smt_type_enum)
    - Builtin atomics (Int, String).
    - TODO: datatypes
    - TODO: arrays, functions
  - Existential semantics ($smt_model_eval_exists)
  - Partial function semantics ($smt_model_lookup)
  - Builtin operator semantics
    - Defines a deep embedding of SMT-LIB terms into Eunoia via $smt_Term / $smt_apply_N
  - Overloading arithmetic uses multi-case programs.
  - Reverts operator overload, recognizes "$eoo_-.2" as SMT-LIB "-".
  - Function and array values ($smt_Map), including lookups and valueness.
  - Semantics of parametric bitvector operations


=== Smt_Meta

Compiles *.eo to *.smt2.
Implements a simple type system which distinguishes Eunoia terms,
SMT terms, SMT types and SMT values.
Optimizes for non-recursive programs using define-fun.
Generates a conjecture for a Eunoia program under test (e.g. $eovc_X)
which states the $eovc_X program does not get stuck for some input.
This means we are searching over the *syntactic space* of Eunoia terms
to find terms that witness the semantic unsoundness of the rule.

Relies on:
- smt_meta.smt2 template, 14 LOC SMT2
- smt_meta_reduce.cpp (ethos plugin), 1383 LOC C++

Things handled at this stage:
- The final deep embedding
  - Eunoia Terms (eo.Term)
    - Embeddings for all 3 SMT-LIB constructs below.
  - SMT-LIB Terms (sm.Term)
  - SMT-LIB Types (tsm.Type)
  - SMT-LIB Values (vsm.Value)
    - Note that values are disjoint from terms. Terms can be embedded into
      values, guarded by a value-ness predicate.
- Exception handling based on *datatype selector semantics*.
  - Part of the trusted core is that the model_smt layer may use three distinguished
    selectors (eo.SmtTerm.arg1, eo.SmtType.arg1, eo.SmtValue.arg1) *only* on Eunoia
    terms that we are sure successfully evaluate. This is managed by a try/catch
    pattern in model_smt.eo ($smt_try_X).
- Eunoia semantics of pattern matching based on datatype selectors/testers.
- Symbols introduced for deep embedding in Model_Smt $smt_apply_N, $smt_type_N.
- Remaining eo::define and define commands inlined.
- Axiom for eo::hash
- Axiom for partial function semantics
- Ambiguously typed functions retain their "opaque" semantics, which is handled at this step.
- :opaque on user symbols becomes part of the deep embedding.
  - For example a constructor like:
      (declare-parameterized-const const ((id Int :opaque) (T Type :opaque)) T)
    becomes the datatype constructor with arity 2:
      (sm.@const (sm.@const.arg1 Int) (sm.@const.arg2 sm.Term))
    whereas:
      (declare-parameterized-const and (-> Bool Bool Bool))
    becomes the nullary constructor:
      (sm.And)


- TODO: curried apply -> SMT-LIB apply?

===

Not handled:
- Well foundedness of all Eunoia programs. This can lead to spurious unsoundess in the Smt_Meta step.
  - TODO: well foundedness as a Eunoia program
- Modelling of assume-push/step-pop.
- TODO: modelling of :conclusion-explicit, :assumption.

- TODO: remove type checking from proof rule semantics?
- TODO: type checking as a separate property: type preservation for proof rules.

- TODO: we could construct another intermediate *.eo where all types are
  replaced by those in the deep embedding.

===

Future research:
- Fuzz Ethos to make sure it is syncronized with desugaring semantics.
- Lean_Meta plugin, either:
  - A reimplementation of the above meta-prover in Lean.
  - Use cvc5 to prove meta-theorems and replay them for each proof rule.
- Parametric bitvectors in cvc5 to prove VCs.
- Logos: reimplementation of ethos whose native language is desugared *.eo. It should be formally verified to incorporate some stages of the above pipeline.
- Telos: an SMT solver API to run cvc5 -> proof API -> ethos/logos.
- Alethe to Eunoia.
- Agda_Meta, Deduckti_Meta?
