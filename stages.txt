Run:

./build-debug/run_gen_vc <proof-rule>

At a high-level, the correctness of a Eunoia proof rule can be compiled to
a *.smt2 file, which if unsat, is evidence that the proof rule is sound.
The final encoding uses a deep embedding where:
- A single datatype "sm.Term" is declared, which several builtin constructors.
- All constants in the Eunoia signature are constructors of this datatype.
- Eunoia programs are uninterpreted functions.
- Definitions of Eunoia programs are quantified axioms.
Note that if a Eunoia program is forward declared but not defined, then it is
a free uninterpreted function in the final encoding.

The entire pipeline relies on:
- Bash scripting,
- Ethos for parsing.

=== cvc5 parsing

Relies on:
- cvc5 parser source code

Things handled at this stage:

- Numeral as Decimal in logics without Integers.
- :named.

=== cvc5 API 

Relies on:
- cvc5 API code

Things handled at this stage:
- Desugaring of :chainable, some of the :left-assoc, :right-assoc operators.

=== cvc5 internals -> CPC proof 

Relies on:
- cvc5 source code

Things handled at this stage:
- define-fun-rec, desugared to declare-fun + assert forall.
- match, desugared to ITE
- some FP operators renamed
- Currying of ProofRule::SCOPE.

=== Desugar

Compiles *.eo to *.eo.
The resulting *.eo is desugared to define non-essential Eunoia features as Eunoia programs.
Includes a forward declaration of a side condtion $eo_model_sat.
Optionally, a proof rule can be compiled to a Eunoia program $eor_X which
operates over *formulas* not proofs. Additionally, we may generate a 
Eunoia program $eovc_X which:
- Calls $eo_model_sat and $eor_X.
- Evaluates successfully iff the proof rule is unsound.
This side condition is the target for verification in the Smt_Meta step below.

Relies on:
- eo_desugar.eo template, 286 LOC EO
- desugar.cpp (ethos plugin), 918 LOC C++
- (Optional) trim_defs.cpp (ethos plugin), 258 LOC C++
  - Slices the signature, preserves S-expressions.
  - Needed to make the VCs more manageable.

Things handled at this stage:
- Non-essential Eunoia commands (declare-type/define-type).
- Operator overloading.
  - Introduces "$eoo_X.N" as a convention for overloaded symbols.
- Operator properties.
  - :right-assoc-nil, :right-assoc, :left-assoc-nil, :left-assoc, :chainable, :binder, :let-binder
- declare-rule
  - Proof type handled as part of the VC generation function ($eovc_X).
- declare-consts
  - $eo_Numeral, $eo_Rational, $eo_String, $eo_Binary as references to builtin types.
- eo::eq, eo::is_eq
- eo::is_z, eo::is_q, eo::is_bin, eo::is_str, eo::is_bool, eo::is_var
- eo::gt, eo::cmp
- eo::cons
- eo::list_len, eo::list_concat, eo::list_nth, eo::list_find, eo::list_rev, eo::list_erase, eo::list_erase_all, eo::list_setof, eo::list_minclude, eo::list_meq
- eo::var, eo::nameof
  - Represents variables as constant $eo_Var.
- eo::nil
  - Includes an auto-generation of cases for each :right-assoc-nil, :left-assoc-nil operator.
- eo::typeof
  - *Approximates* the internal type system of Eunoia (monomorphizes
  - Includes an auto-generation of cases for all user symbols ($eo_typeof_main).
  - Includes definitions of literal types, and type of variables ($eo_Var).
- eo::dt_constructors, eo::dt_selectors
- Defines $eo_fail as a stuck term.
- Defines $eo_model_preamble as a placeholder for inserting more definitions of $eo_.

=== Model_smt

Compiles *.eo to *.eo.
Includes a definition of $eo_model_sat, which defines SMT-LIB model semantics.

Relies on:
- model_smt_preamble.eo, 248 LOC EO
- model_eo.eo template, 32 LOC EO
- model_smt.eo, 206 LOC EO
- model_smt.cpp (ethos plugin), 228 LOC C++
- trim_defs.cpp (ethos plugin), also used above

Things handled at this stage:
- Model preamble reduces many Eunoia builtins to SMT-LIB literal semantics (model_smt_preamble.eo)
  - eo::not, eo::and, eo::or, eo::xor
  - eo::add, eo::mul, eo::qdiv, eo::zdiv, eo::zmod, eo::is_neg, eo::neg
  - eo::len, eo::concat, eo::extract, eo::find
  - eo::to_z, eo::to_q, eo::to_bin, eo::to_str
- Custom extensions to SMT-LIB template (model_eo.eo).
  - TODO: Skolem semantics ($eo_const_predicate).
- SMT-LIB semantics (model_smt.eo).
  - Valueness ($smt_is_value)
    - Builtin atomics.
    - Datatypes.
  - Type enumeration ($smt_type_enum)
    - Builtin atomics (Int, String).
    - TODO: datatypes
    - TODO: arrays, functions
  - Existential semantics ($smt_model_eval_exists)
  - Free constant semantics ($smt_model_lookup)
  - Builtin operator semantics
    - Defines a deep embedding of SMT-LIB terms into Eunoia via $smt_Term / $smt_apply_N
    - Defines conversions from Eunoia literals to SMT-LIB values via $smt_to_eo_X/$eo_to_smt_X.
  - overloading arithmetic
  - Reverts operator overload, recognizes "$eoo_-.2" as SMT-LIB "-".
  - TODO: arrays, functions

=== Smt_Meta

Compiles *.eo to *.smt2.
Optimizes for non-recursive programs using define-fun.
Generates a conjecture for a Eunoia program under test (e.g. $eovc_X)
which states the $eovc_X program does not get stuck for some input.
This means we are searching over the *syntactic space* of Eunoia terms
to find terms that witness the semantic unsoundness of the rule.

Relies on:
- smt_meta.smt2 template, 99 LOC SMT2
- smt_meta_reduce.cpp (ethos plugin), 903 LOC C++

Things handled at this stage:
- Distinction between Eunoia terms and SMT-LIB terms.
- Eunoia semantics of "stuckness" (eo.Stuck)
- Eunoia semantics of pattern matching based on datatype selectors/testers.
- Symbols introduced for deep embedding in Model_Smt $smt_Term, $smt_apply_N, $smt_to_eo_X, $eo_to_smt_X.
  - TODO: Indexed SMT-LIB operators are handled as special case?? Maybe Opaque??
- Remaining eo::define and define commands inlined.
- :opaque
- Ambiguously typed functions
- eo::is_ok, eo::ite, eo::requires, eo::hash
- Semantics of parametric bitvector operations

===

Not handled:
- Well foundedness of all Eunoia programs. This can lead to spurious unsoundess in the Smt_Meta step.
  - TODO: well foundedness as a Eunoia program
- Modelling of assume-push/step-pop.
- TODO: modelling of :conclusion-explicit, :assumption.


- TODO: remove type checking from proof rule semantics?
- TODO: type checking as a separate property: type preservation for proof rules.

===

Future research:
- Fuzz Ethos to make sure it is syncronized with desugaring semantics.
- Lean_Meta plugin.
- Parametric bitvectors in cvc5 to prove VCs.
- Logos: reimplementation of ethos whose native language is desugared *.eo. It should be formally verified to incorporate some stages of the above pipeline.
- Telos: an SMT solver API to run cvc5 -> proof API -> ethos/logos.
- Alethe to Eunoia.
- Agda_Meta, Deduckti_Meta?
