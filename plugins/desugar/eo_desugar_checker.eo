;;; utilities

; placeholder
(declare-const $eo_Index Type)

;;; Types

; A Eunoia command
(declare-const $eo_Cmd Type)

; The state
(declare-const $eo_State Type)

;;; Constructors for state

; State
(declare-const $eo_StateObj Type)
(declare-parameterized-const $emb_so.assume ((F Bool :opaque)) $eo_StateObj)
(define $so_assume ((F Bool)) ($emb_so.assume F))
; TODO: add assume-push?
(declare-parameterized-const $emb_so.proven ((F Bool :opaque)) $eo_StateObj)
(define $so_proven ((F Bool)) ($emb_so.proven F))


(declare-const $emb_s.nil $eo_State)
(define $s_nil () $emb_s.nil)
(declare-const $emb_s.fail $eo_State)
(define $s_fail () $emb_s.fail)
(declare-parameterized-const $emb_s.cons
  ((so $eo_StateObj :opaque) (s $eo_State :opaque)) $eo_State)
(define $s_cons ((o $eo_StateObj) (tail $eo_State)) ($emb_s.cons o tail))

(program $eo_StateObj_proven ((F Bool))
  :signature ($eo_StateObj) Bool
  (
  (($eo_StateObj_proven ($so_assume F)) F)
  (($eo_StateObj_proven ($so_proven F)) F)
  )
)

; forward declare (to be implemented natively)
(program $eo_State_proven_nth ()
  :signature ($eo_State $eo_Index) Bool)

; push an assumption to the state
(define $eo_push_assume ((F Bool) (s $eo_State))
  ($s_cons ($so_assume F) s))
; push a formula F proven by a step to the state
; note we check ok, but don't check type Bool currently
(define $eo_push_proven ((F Bool) (proven Bool) (s $eo_State))
  (eo::ite (eo::is_ok F) ($s_cons ($so_proven F) s) $s_fail))

(declare-const $eo_PList Type)
(declare-const $eo_plist_nil $eo_PList)
(declare-const $eo_plist_cons (-> $eo_Index $eo_PList $eo_PList))

; constructs a formula based on a premise list constructor f, a premise list
; and the current state.
(program $eo_mk_premise_list
  ((f (-> Bool Bool Bool)) (n $eo_Index) (pl $eo_PList :list) (S $eo_State))
  :signature ((-> Bool Bool Bool) $eo_PList $eo_State) Bool
  (
  (($eo_mk_premise_list f $eo_plist_nil S)          (eo::nil f Bool))
  (($eo_mk_premise_list f ($eo_plist_cons n pl) S)  
     (eo::cons f ($eo_State_proven_nth S n) ($eo_mk_premise_list f pl S)))
  )
)

; Command constructors

(declare-parameterized-const $emb_cmd.assume ((x Bool :opaque)) $eo_Cmd)
(define $cmd_assume ((x Bool)) ($emb_cmd.assume x))
(declare-parameterized-const $emb_cmd.assume_push ((x Bool :opaque)) $eo_Cmd)
(define $cmd_assume_push ((x Bool)) ($emb_cmd.assume_push x))
(declare-parameterized-const $emb_cmd.check_proven ((x Bool :opaque)) $eo_Cmd)
(define $cmd_check_proven ((x Bool)) ($emb_cmd.check_proven x))
$EO_CMD_DEFS$

$EO_INVOKE_DEFS$

(program $eo_invoke_cmd 
  ((proven Bool) (premises $eo_PList) (S $eo_State)
  (T1 Type) (T2 Type) (T3 Type) (T4 Type) (T5 Type)
  (T6 Type) (T7 Type) (T8 Type) (T9 Type) (T10 Type)
  (a1 T1) (a2 T2) (a3 T3) (a4 T4) (a5 T5) (a6 T6) (a7 T7) (a8 T8) (a9 T9) (a10 T10)
  (n1 $eo_Numeral) (n2 $eo_Numeral) (n3 $eo_Numeral) (n4 $eo_Numeral)
  (n5 $eo_Numeral) (n6 $eo_Numeral) (n7 $eo_Numeral) (n8 $eo_Numeral))
  :signature ($eo_State $eo_Cmd) $eo_State
  (
  ; note that assume / assume_push are identical.
  ; in practice they are only different since the former is intended to mirror
  ; the user assertions in an smt2 script and the latter is not.
  (($eo_invoke_cmd S ($cmd_assume proven))           ($eo_push_assume proven S))
  (($eo_invoke_cmd S ($cmd_assume_push proven))      ($eo_push_assume proven S))
$EO_INVOKE$
  )
)

; Invoke a list of commands
(program $eo_invoke_cmd_list ((S $eo_State) (c $eo_Cmd) (cmds $eo_List))
  :signature ($eo_State $eo_List) $eo_State
  (
  (($eo_invoke_cmd_list $s_fail cmds) $s_fail)
  (($eo_invoke_cmd_list S $eo_List_nil) S)
  (($eo_invoke_cmd_list S ($eo_List_cons c cmds))
     ($eo_invoke_cmd_list ($eo_invoke_cmd s c) cmds))
  )
)
