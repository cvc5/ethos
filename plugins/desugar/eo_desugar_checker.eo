;;; utilities

(declare-const $eo_Pair (-> Type Type Type))
(declare-parameterized-const $eo_pair ((U Type :implicit) (T Type :implicit)) (-> U T ($eo_Pair U T)))

(program $pair_first ((T Type) (S Type) (t T) (s S))
  :signature (($eo_Pair T S)) T
  (
  (($pair_first ($eo_pair t s)) t)
  )
)

(program $pair_second ((T Type) (S Type) (t T) (s S))
  :signature (($eo_Pair T S)) S
  (
  (($pair_second ($eo_pair t s)) s)
  )
)

; Indicates that a formula was not given
(declare-const $eo_NullBool Bool)


; placeholder
(declare-const $eo_Numeral Type)

;;; Types

; A Eunoia command
(declare-const $eo_Cmd Type)

; A Eunoia proof rule
(declare-const $eo_Rule Type)

; The state
(declare-const $eo_State Type)

;;; Constructors for state

; State
(declare-const $eo_StateObj Type)
(declare-parameterized-const $smd_so.assume ((F Bool :opaque)) $eo_StateObj)
(define $so_assume ((F Bool)) ($smd_so.assume F))
(declare-parameterized-const $smd_so.proven ((F Bool :opaque)) $eo_StateObj)
(define $so_proven ((F Bool)) ($smd_so.proven F))


(declare-const $smd_s.nil $eo_State)
(define $s_nil () $smd_s.nil)
(declare-const $smd_s.cons
  (-> $eo_StateObj $eo_State $eo_State) :right-assoc-nil $smd_s.nil)
(define $s_cons ((o $eo_StateObj) (tail $eo_State)) ($smd_s.cons o tail))

(program $eo_StateObj_proven ((F Bool))
  :signature ($eo_StateObj) Bool
  (
  (($eo_StateObj_proven ($so_assume F)) F)
  (($eo_StateObj_proven ($so_proven F)) F)
  )
)
(define $eo_State_proven ((s $eo_State) (n $eo_Numeral))
  ($eo_StateObj_proven (eo::list_nth $smd_s.cons s n)))

; push an assumption to the state
(define $eo_push_assume ((F Bool) (s $eo_State :list))
  ($s_cons ($so_assume F) s))
; pop the last assumption from the state
(program $eo_pop_assume ((F Bool) (tail $eo_State :list) (so $eo_StateObj))
  :signature ($eo_State) ($eo_Pair Bool $eo_State)
  (
  (($eo_pop_assume ($s_cons ($so_assume F) tail)) ($eo_pair F tail))
  (($eo_pop_assume ($s_cons so tail))             ($eo_pop_assume tail))
  ; otherwise stuck if nil
  )
)
; push a formula F proven by a step to the state
(define $eo_push_proven ((F Bool) (proven Bool) (s $eo_State :list))
  (eo::define ((newState ($s_cons ($so_proven F) s)))
    (eo::ite (eo::eq proven $eo_NullBool)
      newState
      (eo::requires F proven newState))))

(define $eo_PList () eo::List)
(define $eo_plist_nil () eo::List::nil)
(define $eo_plist_cons () eo::List::cons)
(define $eo_AList () eo::List)

; constructs a formula based on a premise list constructor f, a premise list
; and the current state.
(program $eo_mk_premise_list
  ((f (-> Bool Bool Bool)) (n $eo_Numeral) (pl $eo_PList :list) (S $eo_State))
  :signature ((-> Bool Bool Bool) $eo_PList $eo_StateObj) Bool
  (
  (($eo_mk_premise_list f $eo_plist_nil S)          (eo::nil f Bool))
  (($eo_mk_premise_list f ($eo_plist_cons n pl) S)  
     (eo::cons f ($eo_State_proven S n) ($eo_mk_premise_list f pl S)))
  )
)

; Rule constructors

(declare-parameterized-const $smd_cmd.assume ((x Bool :opaque)) $eo_Cmd)
(define $cmd_assume ((x Bool)) ($smd_cmd.assume x))
(declare-parameterized-const $smd_cmd.assume-push ((x Bool :opaque)) $eo_Cmd)
(define $cmd_assume-push ((x Bool)) ($smd_cmd.assume-push x))
(declare-parameterized-const $smd_cmd.step
  ((r $eo_Rule :opaque) (proven Bool :opaque) (premises $eo_PList :opaque) (args $eo_AList :opaque))
  $eo_Cmd)
(define $cmd_step
  ((r $eo_Rule) (proven Bool) (premises $eo_PList) (args $eo_AList))
  ($smd_cmd.step r proven premises args))
(declare-parameterized-const $smd_cmd.step-pop
  ((r $eo_Rule :opaque) (proven Bool :opaque) (premises $eo_PList :opaque) (args $eo_AList :opaque))
  $eo_Cmd)
(define $cmd_step-pop
  ((r $eo_Rule) (proven Bool) (premises $eo_PList) (args $eo_AList))
  ($smd_cmd.step-pop r proven premises args))


;$EO_RULE_DEFS$

; proven, assumption, premise list, arg list
(program $eo_invoke_step ()
  :signature (Bool Bool $eo_PList $eo_AList $eo_State) $eo_State
  (
;$EO_RULE_INVOKE$
  )
)

(program $eo_invoke_cmd 
  ((S $eo_State) (F Bool)
   (r $eo_Rule) (proven Bool) (premises $eo_PList) (args $eo_AList))
  :signature ($eo_Cmd $eo_State) $eo_State
  (
  (($eo_invoke_cmd ($cmd_assume F) S)           ($eo_push_assume F S))
  (($eo_invoke_cmd ($cmd_assume-push F) S)      ($eo_push_assume F S))
  (($eo_invoke_cmd ($cmd_step r proven premises args) S)    
     ($eo_push_proven ($eo_invoke_step proven $eo_NullBool premises args S) proven S))
  (($eo_invoke_cmd ($cmd_step-pop r proven premises args) S)
     (eo::define ((ps ($eo_pop_assume S)))
     ($eo_push_proven ($eo_invoke_step proven ($pair_first ps) premises args S) proven ($pair_second ps))))
  )
)

;;;; soundness specification

; placeholder
(declare-parameterized-const $eo_interprets ((F Bool) (val Bool)) Bool)

; specifies whether state is sound
(program $eo_State_is_sound_rec ((ret Bool) (tail $eo_State :list) (F Bool))
  :signature ($eo_State Bool) Bool
  (
  (($eo_State_is_sound_rec $s_nil ret) ret)
  (($eo_State_is_sound_rec ($s_cons ($so_assume F) tail) ret)
    (eo::ite ($eo_interprets F false) true ($eo_State_is_sound_rec tail)))
  (($eo_State_is_sound_rec ($s_cons ($so_proven F) tail) ret)
    ($eo_State_is_sound_rec tail (eo::ite ret (eo::not ($eo_interprets F false)) ret)))
  )
)

(define $eo_State_is_sound ((s $eo_State)) ($eo_State_is_sound_rec s true))
