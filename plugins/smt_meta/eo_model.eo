
; This file is expected to define function $eo_model_sat, which defines whether a (Boolean) term is satisfied by a model.

; Note that it must be written in desugared Eunoia. This means
; that we do not rely on e.g. :right-assoc-nil or :list.
; It also means that certain definitions are pre-expanded,
; for example, String must be written (Seq Char).

; fwd-decl: $eo_model_lookup
; Conceptually, returns the model value for constant with identifier id and type T.
; This is intentionally undefined in this signature.
(program $eo_model_lookup ((T Type))
  :signature (T) T)

; represents an unknown value
(declare-parameterized-const @unknown_value ((T Type) (i Int)) T)

(program $eo_model_enum ((T Type) (i Int) (w Int))
  :signature ((eo::quote T) Int) T
  (
  (($eo_model_enum Int i)         (eo::define ((v (eo::zdiv i 2)))
                                    (eo::ite (eo::eq (eo::zmod i 2) 0) v (eo::neg v))))
  ;(($eo_model_enum Real i)
  (($eo_model_enum (BitVec w) i)  (eo::define ((v (eo::to_bin w i)))
                                    (eo::requires (eo::to_z v) i v)))   ; must not overflow
  (($eo_model_enum (Seq Char) i)  (eo::ite (eo::eq i 0)
                                    ""
                                    (eo::concat (eo::to_str (eo::zmod i 196608)) ($eo_model_enum (Seq Char) (eo::zdiv i 196608)))))
  (($eo_model_enum UnitTuple i)   (eo::requires i 0 tuple.unit))
  ; Array, Set, (Seq T), Tuple
  (($eo_model_enum T i)           (@unknown_value T i))   ; note since this always succeeds, this assumes that unhandled types have infinite type
  )
)

; fwd-decl: $eo_model_evaluate
(program $eo_model_evaluate ((T Type))
  :signature (T) T)

; specification for forall is a (non-computable) function
(program $eo_model_evaluate_forall ((T Type) (x T) (xs $eo_List :list) (F Bool) (i Int))
  :signature (Bool Int) Bool
  (
  (($eo_model_evaluate_forall (forall $eo_List_nil F) i)     ($eo_model_evaluate F))
  (($eo_model_evaluate_forall (forall ($eo_List_cons x xs) F) i)
    (eo::define ((next ($eo_model_enum (eo::typeof x) i)))
    (eo::ite (eo::is_ok next)
      (eo::ite ($eo_model_evaluate ($substitute x next F))
        ($eo_model_evaluate_forall (forall ($eo_List_cons x xs) F) (eo::add i 1))
        false)
      true))) ; out of values
  )
)

; simple atomic types can have better evaluators
; in the smt2, these take a Term that can be constant folded, and constant fold them using the SMT-LIB operator
(program $eo_model_evaluate_int ((T Type)) :signature (T) Int)
(program $eo_model_evaluate_real ((T Type)) :signature (T) Real)
(program $eo_model_evaluate_strings ((T Type)) :signature (T) (Seq Char))

; An evaluator for all terms that we can reason about models.
(program $eo_model_evaluate
  ((T Type) (U Type) (V Type) (x T) (f (-> U T)) (y V) (z V) (u U) (n Int) (F Bool) (xs $eo_List)
   (a1 (Array U V)) (a2 (Array U V))
   (s (Seq Char)) (R RegLan))
  :signature (T) T
  (
  ; @const is the CPC syntax for constants
  (($eo_model_evaluate (@const n T))              ($eo_model_lookup (@const n T)))
  ; For equality, we use $are_distinct_terms which is more general than $run_evaluate.
  ; This side condition is part of the trusted core.
  (($eo_model_evaluate (_ (= y) z))               (eo::define ((fmy ($eo_model_evaluate y)))
                                                  (eo::define ((fmz ($eo_model_evaluate z)))
                                                  (eo::ite (eo::eq fmy fmz)
                                                    true
                                                    (eo::requires ($are_distinct_terms fmy fmz) true false)))))
  ; partial operators
  (($eo_model_evaluate (/ y 0))                   ($eo_model_evaluate (@div_by_zero y)))
  (($eo_model_evaluate (div y 0))                 ($eo_model_evaluate (@int_div_by_zero y)))
  (($eo_model_evaluate (mod y 0))                 ($eo_model_evaluate (@mod_by_zero y)))
  ; other operators go here
  ;(($eo_model_evaluate (select a1 u))
  (($eo_model_evaluate (forall xs F))             ($eo_model_evaluate_forall (forall xs F) 0))
  (($eo_model_evaluate (exists xs F))             ($eo_model_evaluate (not (forall xs (not F)))))
  (($eo_model_evaluate (str.in_re s R))           ($str_eval_str_in_re ($eo_model_evaluate s) ($eo_model_evaluate R)))
  ; TODO: arrays, sets, datatypes
  ; skolems
  (($eo_model_evaluate (@purify x))               ($eo_model_evaluate x))
  (($eo_model_evaluate (@array_deq_diff a1 a2))   (eo::define ((m ($eo_model_lookup (@array_deq_diff a1 a2))))
                                                  (eo::requires ($eo_model_evaluate (= (select a1 m) (select a1 m))) false
                                                     m)))
  ; Use the CPC run_evaluate side condition for all operators returning an atomic value.
  ; This side condition is part of the trusted core.
  (($eo_model_evaluate (f y))           (eo::define ((fme ($eo_model_evaluate f)))
                                        (eo::define ((yme ($eo_model_evaluate y)))
                                        (eo::define ((tme (_ fme yme)))
                                        (eo::define ((ev ($run_evaluate tme)))
                                        (eo::define ((evs ($seq_eval tme)))
                                        (eo::ite (eo::is_ok ev)
                                          ev
                                          (eo::ite (eo::is_ok evs)
                                            evs
                                            tme))))))))
  (($eo_model_evaluate x)               x)
  )
)

; program: $eo_model_sat
; note: Evaluates to true if F is satisfied by the model.
(program $eo_model_sat ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_sat F) ($eo_model_evaluate F))
  )
)

; used to ensure dependencies are set
;(program $eo_test ((F Bool)) ($eo_model_sat F))
