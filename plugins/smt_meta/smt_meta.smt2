(set-logic HO_ALL)

(declare-datatype sm.Term
  (
  ; Core
  (sm.Type)
  (sm.FunType (sm.FunType.arg1 sm.Term) (sm.FunType.arg2 sm.Term))
  (sm.Apply (sm.Apply.arg1 sm.Term) (sm.Apply.arg2 sm.Term))
  (sm.Var (sm.Var.name String) (sm.Var.Type sm.Term))
  (sm.Const (sm.Const.id Int) (sm.Const.Type sm.Term))  ; user constants
  (sm.Stuck)
  ; Booleans
  (sm.BoolType)
  (sm.True)
  (sm.False)
  ; builtin literal types
  (sm.Numeral (sm.Numeral.val Int))
  (sm.Rational (sm.Rational.val Real))
  (sm.Decimal (sm.Decimal.val Real))
  (sm.String (sm.String.val String))
  (sm.Binary (sm.Binary.width Int) (sm.Binary.val Int))
  (sm.Hexadecimal (sm.Hexadecimal.width Int) (sm.Hexadecimal.val Int))
  ; generated by signature
$TERM_DECL$
  )
)

;;; Utilities

; define: $sm_Boolean
(define-fun $sm_Boolean ((x Bool)) sm.Term
  (ite x sm.True sm.False))

; define: $sm_is_Boolean
(define-fun $sm_is_Boolean ((x sm.Term)) Bool
  (or (= x sm.True) (= x sm.False)))

; Stuckness propagates through non-nullary constructors
(define-fun $sm_FunType ((x sm.Term) (y sm.Term)) sm.Term
  (ite (or (= x sm.Stuck) (= y sm.Stuck))
    sm.Stuck
    (sm.FunType x y)))

(define-fun $sm_Apply ((x sm.Term) (y sm.Term)) sm.Term
  (ite (or (= x sm.Stuck) (= y sm.Stuck))
    sm.Stuck
    (sm.Apply x y)))

(define-fun $sm_Const ((x Int) (y sm.Term)) sm.Term
  (ite (= y sm.Stuck)
    sm.Stuck
    (sm.Const x y)))

; TODO: can be improved
(define-fun $sm_mod_pow_2 ((d Int) (n Int)) Int
  (mod d (^ 2 n)))

(define-fun $sm_Binary ((x Int) (y Int)) sm.Term
  (ite (and (<= 0 x) (< x 4294967296))
    (sm.Binary x ($sm_mod_pow_2 y x))
    sm.Stuck))

;;; Core operators

; declare: $eo_typeof
; note: This is a forward declaration
(declare-const $eo_typeof (-> sm.Term sm.Term))

; program: $eo_is_ok
(define-fun $eo_is_ok ((x1 sm.Term)) sm.Term
  ($sm_Boolean (not (= x1 sm.Stuck))))

; program: $eo_ite
(define-fun $eo_ite ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term)) sm.Term
  (ite (= x1 sm.True)
    x2
  (ite (= x1 sm.False)
    x3
    sm.Stuck)))

; program: $eo_requires
(define-fun $eo_requires ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term)) sm.Term
  (ite (and (not (= x1 sm.Stuck)) (not (= x2 sm.Stuck)) (= x1 x2))
    x3
    sm.Stuck))

; program: $eo_hash
; note: This is defined axiomatically.
(declare-const $eo_hash (-> sm.Term sm.Term))
(assert (forall ((x sm.Term))
  (=> (not (= x sm.Stuck))
    ((_ is sm.Numeral) ($eo_hash x)))))
(assert (forall ((x sm.Term) (y sm.Term))
  (=> (and (not (= x sm.Stuck)) (not (= y sm.Stuck))
    (= ($eo_hash x) ($eo_hash y))) (= x y))))

; program: $eo_nameof
(define-fun $eo_nameof ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Var) x1)
    (sm.String (sm.Var.name x1))
    sm.Stuck))

; program: $eo_var
(define-fun $eo_var ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.String) x1) (= ($eo_typeof x2) sm.Type))
    (sm.Var (sm.String.val x1) x2)
    sm.Stuck))

;;; Boolean operators

; program: $eo_and
(define-fun $eo_and ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    ($sm_Boolean (and (= x1 sm.True) (= x2 sm.True)))
  ; TODO
    sm.Stuck))

; program: $eo_or
(define-fun $eo_or ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    ($sm_Boolean (or (= x1 sm.True) (= x2 sm.True)))
  ; TODO
    sm.Stuck))

; program: $eo_xor
(define-fun $eo_xor ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    ($sm_Boolean (xor (= x1 sm.True) (= x2 sm.True)))
  ; TODO
    sm.Stuck))

; program: $eo_not
(define-fun $eo_not ((x1 sm.Term)) sm.Term
  (ite ($sm_is_Boolean x1)
    ($sm_Boolean (= x1 sm.False))
  ; TODO
    sm.Stuck))

;;; Arithmetic operators

; program: $eo_add
(define-fun $eo_add ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    (sm.Numeral (+ (sm.Numeral.val x1) (sm.Numeral.val x2)))
  (ite (and ((_ is sm.Rational) x1) ((_ is sm.Rational) x2))
    (sm.Rational (+ (sm.Rational.val x1) (sm.Rational.val x2)))
  (ite (and ((_ is sm.Decimal) x1) ((_ is sm.Decimal) x2))
    (sm.Decimal (+ (sm.Decimal.val x1) (sm.Decimal.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    ($sm_Binary (sm.Binary.width x1) (+ (sm.Numeral.val x1) (sm.Numeral.val x2)))
    sm.Stuck)))))

; program: $eo_mul
(define-fun $eo_mul ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    (sm.Numeral (* (sm.Numeral.val x1) (sm.Numeral.val x2)))
  (ite (and ((_ is sm.Rational) x1) ((_ is sm.Rational) x2))
    (sm.Rational (* (sm.Rational.val x1) (sm.Rational.val x2)))
  (ite (and ((_ is sm.Decimal) x1) ((_ is sm.Decimal) x2))
    (sm.Decimal (* (sm.Decimal.val x1) (sm.Decimal.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    ($sm_Binary (sm.Binary.width x1) (* (sm.Numeral.val x1) (sm.Numeral.val x2)))
    sm.Stuck)))))

; program: $eo_qdiv
(define-fun $eo_qdiv ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2) (not (= (sm.Numeral.val x2) 0)))
    (sm.Rational (/ (to_real (sm.Numeral.val x1)) (to_real (sm.Numeral.val x2))))
  (ite (and ((_ is sm.Rational) x1) ((_ is sm.Rational) x2) (not (= (sm.Rational.val x2) 0.0)))
    (sm.Rational (/ (sm.Rational.val x1) (sm.Rational.val x2)))
  (ite (and ((_ is sm.Decimal) x1) ((_ is sm.Decimal) x2) (not (= (sm.Decimal.val x2) 0.0)))
    (sm.Rational (/ (sm.Decimal.val x1) (sm.Decimal.val x2)))
    sm.Stuck))))

; program: $eo_zdiv
(declare-const $eo_zdiv (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_zmod
(declare-const $eo_zmod (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_is_neg
(define-fun $eo_is_neg ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    ($sm_Boolean (< (sm.Numeral.val x1) 0))
  (ite ((_ is sm.Rational) x1)
    ($sm_Boolean (< (sm.Rational.val x1) 0.0))
  (ite ((_ is sm.Decimal) x1)
    ($sm_Boolean (< (sm.Decimal.val x1) 0.0))
    sm.Stuck))))

; program: $eo_neg
(define-fun $eo_neg ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    (sm.Numeral (- (sm.Numeral.val x1)))
  (ite ((_ is sm.Rational) x1)
    (sm.Rational (- (sm.Rational.val x1)))
  (ite ((_ is sm.Decimal) x1)
    (sm.Decimal (- (sm.Decimal.val x1)))
  (ite ((_ is sm.Binary) x1)
    ($sm_Binary (sm.Binary.width x1) (- (sm.Binary.val x1)))
    sm.Stuck)))))

;;; String operators

; program: $eo_len
(define-fun $eo_len ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Binary) x1)
    (sm.Numeral (sm.Binary.width x1))
  (ite ((_ is sm.Hexadecimal) x1)
    (sm.Numeral (sm.Hexadecimal.width x1))
  (ite ((_ is sm.String) x1)
    (sm.Numeral (str.len (sm.String.val x1)))
    sm.Stuck))))

; program: $eo_concat
(define-fun $eo_concat ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.String) x1) ((_ is sm.String) x2))
    (sm.String (str.++ (sm.String.val x1) (sm.String.val x2)))
  ; TODO
    sm.Stuck))

; program: $eo_extract
(declare-const $eo_extract (-> sm.Term sm.Term sm.Term sm.Term))
; TODO

; program: $eo_find
(declare-const $eo_find (-> sm.Term sm.Term sm.Term))
; TODO

;;; Conversion operators

; program: $eo_to_z
(define-fun $eo_to_z ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    x1
  (ite ((_ is sm.Rational) x1)
    (sm.Numeral (to_int (sm.Rational.val x1)))
  (ite ((_ is sm.Decimal) x1)
    (sm.Numeral (to_int (sm.Decimal.val x1)))
  (ite ((_ is sm.Binary) x1)
    (sm.Numeral (sm.Binary.val x1))
  (ite ((_ is sm.Hexadecimal) x1)
    (sm.Numeral (sm.Hexadecimal.val x1))
  (ite (and ((_ is sm.String) x1) (= (str.len (sm.String.val x1)) 1))
    (sm.Numeral (str.to_code (sm.String.val x1)))
    sm.Stuck)))))))

; program: $eo_to_q
(define-fun $eo_to_q ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    (sm.Rational (to_real (sm.Numeral.val x1)))
  (ite ((_ is sm.Rational) x1)
    x1
  (ite ((_ is sm.Decimal) x1)
    (sm.Rational (sm.Decimal.val x1))
    sm.Stuck))))

; program: $eo_to_bin
(define-fun $eo_to_bin ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    ($sm_Binary (sm.Numeral.val x1) (sm.Numeral.val x2))
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Binary) x2))
    ($sm_Binary (sm.Numeral.val x1) (sm.Binary.val x2))
    sm.Stuck)))

; program: $eo_to_str
(declare-const $eo_to_str (-> sm.Term sm.Term))
; TODO

;;; List operators

; declare: $eo_nil
; node: this is a forward declaration
(declare-const $eo_nil (-> sm.Term sm.Term sm.Term))

;;; Datatype operators

; declare: $eo_dt_selectors
(declare-const $eo_dt_selectors (-> sm.Term sm.Term))
; TODO

; declare: $eo_dt_constructors
(declare-const $eo_dt_constructors (-> sm.Term sm.Term))
; TODO

;;; User defined symbols

$DEFS$

;;; Meta symbols

; program: $eo_typeof
; note: This is forward declared.
(assert (forall ((x1 sm.Term))
  (= ($eo_typeof x1)
  (ite (= x1 sm.Stuck)
    sm.Stuck
  ;; Core
  (ite (= x1 sm.Type)
    sm.Type
  (ite ((_ is sm.FunType) x1)
    (ite (and (= ($eo_typeof (sm.FunType.arg1 x1)) sm.Type) (= ($eo_typeof (sm.FunType.arg2 x1)) sm.Type))
      sm.Type
      sm.Stuck)
  (ite ((_ is sm.Var) x1)
    (sm.Var.Type x1)
  (ite ((_ is sm.Const) x1)
    (sm.Const.Type x1)
  ;; Booleans
  (ite (= x1 sm.BoolType)
    sm.Type
  (ite (= x1 sm.True)
    sm.BoolType
  (ite (= x1 sm.False)
    sm.BoolType
  ;; literal type rules
$TYPEOF_LITERALS$
  ;; user declarations
$TYPEOF$
  ; fallthrough: generic apply
  (ite ((_ is sm.Apply) x1)
    (let ((ta1 ($eo_typeof (sm.Apply.arg1 x1))))
    (let ((ta2 ($eo_typeof (sm.Apply.arg2 x1))))
    (ite (and ((_ is sm.FunType) ta1) (= (sm.FunType.arg1 ta1) ta2))
      (sm.FunType.arg2 ta1)
      sm.Stuck)))
    sm.Stuck))))))))))
$TYPEOF_END$
))

; program: $eo_nil
; note: This is forward declared above.
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    (= ($eo_nil x1 x2) sm.Stuck)
$NIL$
    (= ($eo_nil x1 x2) sm.Stuck)
)
$NIL_END$
))

;;; Proof definitions

; Predicate for terms for which we have a proof.
(declare-const sm.hasProof (-> sm.Term Bool))

; first argument is an n-ary operator
; second argument is a formula that is an application
(declare-const sm.hasProofList (-> sm.Term sm.Term Bool))
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (= x2 ($eo_nil x1 ($eo_typeof x2)))
    (= (sm.hasProofList x1 x2) true)
$HAS_PROOF_LIST$
    (= (sm.hasProofList x1 x2) false))
))

;;; User defined proof rules

$RULES$
