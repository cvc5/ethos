(set-logic UFDTSNIRA)

; The final embedding of SMT-LIB types that are relevant to the VC.
(declare-datatype tsm.Type
  (

  ; generated by signature
$SM_TYPE_DECL$
  (tsm.None)
  )
)
; The final embedding of SMT-LIB terms that are relevant to the VC.
(declare-datatype sm.Term
  (
  ; TODO: auto-generate this??
  ; declare Const SMT_DT_CONS
  (sm.Const (sm.Const.arg1 Int) (sm.Const.arg2 Int) (sm.Const.arg3 tsm.Type))

  ; generated by signature
$SM_TERM_DECL$
  )
)

; The final embedding of Eunoia terms that are relevant to the VC.
; SMT-LIB terms and types are embedded in this datatype.
(declare-datatype eo.Term
  (
  ; The type of types in Eunoia
  (eo.Type)
  ; The Eunoia function type.
  (eo.FunType (eo.FunType.arg1 eo.Term) (eo.FunType.arg2 eo.Term))
  ; Application of a Eunoia term
  (eo.Apply (eo.Apply.arg1 eo.Term) (eo.Apply.arg2 eo.Term))
  ; The Eunoia representation of an SMT-LIB term
  (eo.SmtTerm (eo.SmtTerm.arg1 sm.Term))
  ; The Eunoia representation of an SMT-LIB type
  (eo.SmtType (eo.SmtType.arg1 tsm.Type))
  ; Defines "stuckness"
  (eo.Stuck)


  ; generated by signature
$SM_EO_TERM_DECL$
  )
)

;;; Utilities

; Stuckness propagates through non-nullary constructors
(define-fun $eo_FunType ((x eo.Term) (y eo.Term)) eo.Term
  (ite (or (= x eo.Stuck) (= y eo.Stuck))
    eo.Stuck
    (eo.FunType x y)))

(define-fun $eo_Apply ((x eo.Term) (y eo.Term)) eo.Term
  (ite (or (= x eo.Stuck) (= y eo.Stuck))
    eo.Stuck
    (eo.Apply x y)))

;;; Core operators

; Note that these cannot be lifted further since their semantics wrt
; stuckness is non-standard.
; TODO: maybe better if these are lifted and made a special case?

; axiom: $eo_is_ok
(define-fun $eo_is_ok ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    (eo.SmtTerm sm.False)
    (eo.SmtTerm sm.True)))

; axiom: $eo_ite
(define-fun $eo_ite ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term)) eo.Term
  (ite (= x1 (eo.SmtTerm sm.True))
    x2
  (ite (= x1 (eo.SmtTerm sm.False))
    x3
    eo.Stuck)))

; axiom: $eo_requires
(define-fun $eo_requires ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term)) eo.Term
  (ite (and (not (= x1 eo.Stuck)) (not (= x2 eo.Stuck)) (= x1 x2))
    x3
    eo.Stuck))

; axiom: $eo_hash
; note: This is defined axiomatically.
(declare-fun $eo_hash (eo.Term) eo.Term)
(assert (! (forall ((x eo.Term))
  (=> (not (= x eo.Stuck))
    (and
      ((_ is eo.SmtTerm) ($eo_hash x))
      ((_ is sm.Numeral) (eo.SmtTerm.arg1 ($eo_hash x)))))) :named sm.hash_numeral))
(assert (! (forall ((x eo.Term) (y eo.Term))
  (=> (and (not (= x eo.Stuck)) (not (= y eo.Stuck))
    (= ($eo_hash x) ($eo_hash y))) (= x y))) :named sm.hash_injective))

;;; User defined symbols

$SM_DEFS$

;;; The verification condition

$SMT_VC$

(check-sat)
