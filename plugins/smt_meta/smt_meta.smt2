(set-logic HO_ALL)

(declare-datatype sm.Term
  (
  ; Core
  (sm.Type)
  (sm.FunType (sm.FunType.arg1 sm.Term) (sm.FunType.arg2 sm.Term))
  (sm.Apply (sm.Apply.arg1 sm.Term) (sm.Apply.arg2 sm.Term))
  (sm.Var (sm.Var.name String) (sm.Var.Type sm.Term))
  (sm.Const (sm.Const.id Int) (sm.Const.Type sm.Term))  ; user constants
  (sm.Stuck)
  ; Booleans
  (sm.BoolType)
  (sm.True)
  (sm.False)
  ; Lists
  (sm.ListType)
  (sm.List.cons)
  (sm.List.nil)
  ; builtin literal types
  (sm.Numeral (sm.Numeral.val Int))
  (sm.Rational (sm.Rational.val Real))
  (sm.Decimal (sm.Decimal.val Real))
  (sm.String (sm.String.val String))
  (sm.Binary (sm.Binary.width Int) (sm.Binary.val Int))
  (sm.Hexadecimal (sm.Hexadecimal.width Int) (sm.Hexadecimal.val Int))
  ; generated by signature
$TERM_DECL$
  )
)

;;; Utilities

; define: $sm_Boolean
(define-fun $sm_Boolean ((x Bool)) sm.Term
  (ite x sm.True sm.False))

; define: $sm_is_Boolean
(define-fun $sm_is_Boolean ((x sm.Term)) Bool
  (or (= x sm.True) (= x sm.False)))

;;; Core operators

; program: $eo_is_ok
(define-fun $eo_is_ok ((x1 sm.Term)) sm.Term
  ($sm_Boolean (not (= x1 sm.Stuck))))

; program: $eo_ite
(declare-const $eo_ite (-> sm.Term sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term))
  (ite (= x1 sm.True)
    (= ($eo_ite x1 x2 x3) x2)
  (ite (= x1 sm.False)
    (= ($eo_ite x1 x2 x3) x3)
    true))
))

; program: $eo_requires
(declare-const $eo_requires (-> sm.Term sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term))
  (ite (and (not (= x1 sm.Stuck)) (not (= x2 sm.Stuck)) (= x1 x2))
    (= ($eo_requires x1 x2 x3) x3)
    (= ($eo_requires x1 x2 x3) sm.Stuck))
))

; program: $eo_hash
; note: This is defined axiomatically.
(declare-const $eo_hash (-> sm.Term sm.Term))
(assert (forall ((x sm.Term))
  (=> (not (= x sm.Stuck))
    ((_ is sm.Numeral) ($eo_hash x)))))
(assert (forall ((x sm.Term) (y sm.Term))
  (=> (and (not (= x sm.Stuck)) (not (= y sm.Stuck))
    (= ($eo_hash x) ($eo_hash y))) (= x y))))

; program: $eo_nameof
(declare-const $eo_nameof (-> sm.Term sm.Term))
; TODO

; program: $eo_var
(declare-const $eo_var (-> sm.Term sm.Term sm.Term))
; TODO

; declare: $eo_typeof
; note: This is a forward declaration
(declare-const $eo_typeof (-> sm.Term sm.Term))

; declare: $eo_typeof_apply
; note: This is a forward declaration
(declare-const $eo_typeof_apply (-> sm.Term sm.Term sm.Term))

;;; Boolean operators

; program: $eo_and
(declare-const $eo_and (-> sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    (= ($eo_and x1 x2) sm.Stuck)
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    (= ($eo_and x1 x2) ($sm_Boolean (and (= x1 sm.True) (= x2 sm.True))))
  ; TODO
    (= ($eo_and x1 x2) sm.Stuck)))
))

; program: $eo_or
(declare-const $eo_or (-> sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    (= ($eo_or x1 x2) sm.Stuck)
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    (= ($eo_or x1 x2) ($sm_Boolean (or (= x1 sm.True) (= x2 sm.True))))
  ; TODO
    (= ($eo_or x1 x2) sm.Stuck)))
))


; program: $eo_xor
(declare-const $eo_xor (-> sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    (= ($eo_xor x1 x2) sm.Stuck)
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    (= ($eo_xor x1 x2) ($sm_Boolean (xor (= x1 sm.True) (= x2 sm.True))))
  ; TODO
    (= ($eo_xor x1 x2) sm.Stuck)))
))

; program: $eo_not
(declare-const $eo_not (-> sm.Term sm.Term))
(assert (forall ((x1 sm.Term))
  (ite (= x1 sm.Stuck)
    (= ($eo_not x1) sm.Stuck)
  (ite ($sm_is_Boolean x1)
    (= ($eo_not x1) ($sm_Boolean (= x1 sm.False)))
  ; TODO
    (= ($eo_not x1) sm.Stuck)))
))

;;; Arithmetic operators

; program: $eo_add
(declare-const $eo_add (-> sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    (= ($eo_add x1 x2) sm.Stuck)
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    (= ($eo_add x1 x2) (sm.Numeral (+ (sm.Numeral.val x1) (sm.Numeral.val x2))))
  ; TODO
    (= ($eo_add x1 x2) sm.Stuck)))
))

; program: $eo_mul
(declare-const $eo_mul (-> sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    (= ($eo_mul x1 x2) sm.Stuck)
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    (= ($eo_mul x1 x2) (sm.Numeral (* (sm.Numeral.val x1) (sm.Numeral.val x2))))
  ; TODO
  ;(ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
  ;  (= ($eo_mul x1 x2) (sm.Binary (sm.Binary.width x1) ( (* (sm.Numeral.val x1) (sm.Numeral.val x2))))))
    (= ($eo_mul x1 x2) sm.Stuck)))
))

; program: $eo_qdiv
(declare-const $eo_qdiv (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_zdiv
(declare-const $eo_zdiv (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_zmod
(declare-const $eo_zmod (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_is_neg
(declare-const $eo_is_neg (-> sm.Term sm.Term))
(assert (forall ((x1 sm.Term))
  (ite (= x1 sm.Stuck)
    (= ($eo_is_neg x1) sm.Stuck)
  (ite ((_ is sm.Numeral) x1)
    (= ($eo_is_neg x1) ($sm_Boolean (< (sm.Numeral.val x1) 0)))
  (ite ((_ is sm.Rational) x1)
    (= ($eo_is_neg x1) ($sm_Boolean (< (sm.Rational.val x1) 0.0)))
  (ite ((_ is sm.Decimal) x1)
    (= ($eo_is_neg x1) ($sm_Boolean (< (sm.Decimal.val x1) 0.0)))
    (= ($eo_is_neg x1) sm.Stuck)))))
))

; program: $eo_neg
(declare-const $eo_neg (-> sm.Term sm.Term))
(assert (forall ((x1 sm.Term))
  (ite (= x1 sm.Stuck)
    (= ($eo_neg x1) sm.Stuck)
  (ite ((_ is sm.Numeral) x1)
    (= ($eo_neg x1) (sm.Numeral (- (sm.Numeral.val x1))))
  (ite ((_ is sm.Rational) x1)
    (= ($eo_is_neg x1) (sm.Rational (- (sm.Rational.val x1))))
  (ite ((_ is sm.Decimal) x1)
    (= ($eo_is_neg x1) (sm.Decimal (- (sm.Decimal.val x1))))
  ; TODO
    (= ($eo_neg x1) sm.Stuck)))))
))

;;; String operators

; program: $eo_len
(declare-const $eo_len (-> sm.Term sm.Term))
(assert (forall ((x1 sm.Term))
  (ite (= x1 sm.Stuck)
    (= ($eo_len x1) sm.Stuck)
  (ite ((_ is sm.Binary) x1)
    (= ($eo_len x1) (sm.Numeral (sm.Binary.width x1)))
  (ite ((_ is sm.Hexadecimal) x1)
    (= ($eo_len x1) (sm.Numeral (sm.Hexadecimal.width x1)))
  (ite ((_ is sm.String) x1)
    (= ($eo_len x1) (sm.Numeral (str.len (sm.String.val x1))))
    (= ($eo_len x1) sm.Stuck)))))
))

; program: $eo_concat
(declare-const $eo_concat (-> sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    (= ($eo_concat x1 x2) sm.Stuck)
  (ite (and ((_ is sm.String) x1) ((_ is sm.String) x2))
    (= ($eo_concat x1 x2) (sm.String (str.++ (sm.String.val x1) (sm.String.val x2))))
  ; TODO
    (= ($eo_concat x1 x2) sm.Stuck)))
))

; program: $eo_extract
(declare-const $eo_extract (-> sm.Term sm.Term sm.Term sm.Term))
; TODO

; program: $eo_find
(declare-const $eo_find (-> sm.Term sm.Term sm.Term))
; TODO

;;; Conversion operators

; program: $eo_to_z
(declare-const $eo_to_z (-> sm.Term sm.Term))
; TODO

; program: $eo_to_q
(declare-const $eo_to_q (-> sm.Term sm.Term))
; TODO

; program: $eo_to_bin
(declare-const $eo_to_bin (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_to_str
(declare-const $eo_to_str (-> sm.Term sm.Term))
; TODO

;;; List operators

; declare: $eo_nil
; node: this is a forward declaration
(declare-const $eo_nil (-> sm.Term sm.Term sm.Term))

;;; Datatype operators

; declare: $eo_dt_selectors
(declare-const $eo_dt_selectors (-> sm.Term sm.Term))

; declare: $eo_dt_constructors
(declare-const $eo_dt_constructors (-> sm.Term sm.Term))

;;; User defined symbols

$DEFS$

;;; Meta symbols

; program: $eo_typeof
; note: This is forward declared.
(assert (forall ((x1 sm.Term))
  (ite (= x1 sm.Stuck)
    (= ($eo_typeof x1) sm.Stuck)
  ;; Core
  (ite (= x1 sm.Type)
    (= ($eo_typeof x1) sm.Type)
  (ite ((_ is sm.FunType) x1)
    ; (eo::requires (eo::typeof x1) Type (eo::requires (eo::typeof x2) Type Type))
    (= ($eo_typeof x1) ($eo_requires ($eo_typeof (sm.FunType.arg1 x1)) sm.Type ($eo_requires ($eo_typeof (sm.FunType.arg2 x1)) sm.Type sm.Type)))
  (ite ((_ is sm.Apply) x1)
    (= ($eo_typeof x1) ($eo_typeof_apply (sm.Apply.arg1 x1) (sm.Apply.arg2 x1)))
  (ite ((_ is sm.Var) x1)
    (= ($eo_typeof x1) (sm.Var.Type x1))
  (ite ((_ is sm.Const) x1)
    (= ($eo_typeof x1) (sm.Const.Type x1))
  ;; Booleans
  (ite (= x1 sm.BoolType)
    (= ($eo_typeof x1) sm.Type)
  (ite (= x1 sm.True)
    (= ($eo_typeof x1) sm.BoolType)
  (ite (= x1 sm.False)
    (= ($eo_typeof x1) sm.BoolType)
  ;; lists
  (ite (= x1 sm.ListType)
    (= ($eo_typeof x1) sm.Type)
  ; note: sm.List.cons has non-ground type, hence omitted
  (ite ((_ is sm.List.nil) x1)
    (= ($eo_typeof x1) sm.ListType)
  ;; literal type rules
$TYPEOF_LITERALS$
  ;; user declarations
$TYPEOF$
    (= ($eo_typeof x1) sm.Stuck)
)))))))))))
$TYPEOF_END$
))

; program: $eo_typeof_apply
; TODO

; program: $eo_nil
; note: This is forward declared above.
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    (= ($eo_nil x1 x2) sm.Stuck)
$NIL$
    (= ($eo_nil x1 x2) sm.Stuck)
)
$NIL_END$
))

;;; Proof definitions

; Predicate for terms for which we have a proof.
(declare-const sm.hasProof (-> sm.Term Bool))

; first argument is an n-ary operator
; second argument is a formula that is an application
(declare-const sm.hasProofList (-> sm.Term sm.Term Bool))
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (= x2 ($eo_nil x1 ($eo_typeof x2)))
    (= (sm.hasProofList x1 x2) true)
$HAS_PROOF_LIST$
    (= (sm.hasProofList x1 x2) false))
))

;;; User defined proof rules

$RULES$
