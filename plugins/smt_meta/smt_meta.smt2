(set-logic HO_ALL)

(declare-datatype sm.Term
  (
  ; Core
  (sm.Type)
  (sm.FunType (sm.FunType.arg1 sm.Term) (sm.FunType.arg2 sm.Term))
  (sm.Apply (sm.Apply.arg1 sm.Term) (sm.Apply.arg2 sm.Term))
  (sm.Var (sm.Var.name String) (sm.Var.Type sm.Term))
  (sm.Const (sm.Const.id Int) (sm.Const.Type sm.Term))  ; user constants
  (sm.Stuck)
  ; Booleans
  (sm.BoolType)
  (sm.True)
  (sm.False)
  ; Lists
  (sm.ListType)
  (sm.List.cons)
  (sm.List.nil)
  ; builtin literal types
  (sm.Numeral (sm.Numeral.val Int))
  (sm.Rational (sm.Rational.val Real))
  (sm.Decimal (sm.Decimal.val Real))
  (sm.String (sm.String.val String))
  (sm.Binary (sm.Binary.width Int) (sm.Binary.val Int))
  (sm.Hexadecimal (sm.Hexadecimal.width Int) (sm.Hexadecimal.val Int))
  ; generated by signature
$TERM_DECL$
  )
)

;;; Core operators

; program: $eo_is_ok
(define-fun $eo_is_ok ((x1 sm.Term)) sm.Term
  (ite (= x1 sm.Stuck) sm.False sm.True))

; program: $eo_ite
(declare-const $eo_ite (-> sm.Term sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term))
  (ite (= x1 sm.True)
    (= ($eo_ite x1 x2 x3) x2)
  (ite (= x1 sm.False)
    (= ($eo_ite x1 x2 x3) x3)
    true))
))

; program: $eo_requires
(declare-const $eo_requires (-> sm.Term sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term))
  (ite (and (not (= x1 sm.Stuck)) (not (= x2 sm.Stuck)) (= x1 x2))
    (= ($eo_requires x1 x2 x3) x3)
    (= ($eo_requires x1 x2 x3) sm.Stuck))
))

; program: $eo_hash
; note: This is defined axiomatically.
(declare-const $eo_hash (-> sm.Term sm.Term))
(assert (forall ((x sm.Term))
  (=> (not (= x sm.Stuck))
    ((_ is sm.Numeral) ($eo_hash x)))))
(assert (forall ((x sm.Term) (y sm.Term))
  (=> (and (not (= x sm.Stuck)) (not (= y sm.Stuck))
    (= ($eo_hash x) ($eo_hash y))) (= x y))))

; program: $eo_nameof
(declare-const $eo_nameof (-> sm.Term sm.Term))
; TODO

; program: $eo_var
(declare-const $eo_var (-> sm.Term sm.Term sm.Term))
; TODO

;;; Boolean operators

; program: $eo_and
(declare-const $eo_and (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_or
(declare-const $eo_or (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_xor
(declare-const $eo_xor (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_not
(declare-const $eo_not (-> sm.Term sm.Term))
; TODO

;;; Arithmetic operators

; program: $eo_add
(declare-const $eo_add (-> sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    (= ($eo_add x1 x2) sm.Stuck)
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    (= ($eo_add x1 x2) (sm.Numeral (+ (sm.Numeral.val x1) (sm.Numeral.val x2))))
    (= ($eo_add x1 x2) sm.Stuck)))
))

; program: $eo_mul
(declare-const $eo_mul (-> sm.Term sm.Term sm.Term))
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    (= ($eo_mul x1 x2) sm.Stuck)
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    (= ($eo_mul x1 x2) (sm.Numeral (* (sm.Numeral.val x1) (sm.Numeral.val x2))))
    (= ($eo_mul x1 x2) sm.Stuck)))
))

; program: $eo_qdiv
(declare-const $eo_qdiv (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_zdiv
(declare-const $eo_zdiv (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_zmod
(declare-const $eo_zmod (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_is_neg
(declare-const $eo_is_neg (-> sm.Term sm.Term))
; TODO

; program: $eo_neg
(declare-const $eo_neg (-> sm.Term sm.Term))
(assert (forall ((x1 sm.Term))
  (ite (= x1 sm.Stuck)
    (= ($eo_neg x1) sm.Stuck)
  (ite ((_ is sm.Numeral) x1)
    (= ($eo_neg x1) (sm.Numeral (- (sm.Numeral.val x1))))
    (= ($eo_neg x1) sm.Stuck)))
))

;;; String operators

; program: $eo_len
(declare-const $eo_len (-> sm.Term sm.Term))
; TODO

; program: $eo_concat
(declare-const $eo_concat (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_extract
(declare-const $eo_extract (-> sm.Term sm.Term sm.Term sm.Term))
; TODO

; program: $eo_find
(declare-const $eo_find (-> sm.Term sm.Term sm.Term))
; TODO

;;; Conversion operators

; program: $eo_to_z
(declare-const $eo_to_z (-> sm.Term sm.Term))
; TODO

; program: $eo_to_q
(declare-const $eo_to_q (-> sm.Term sm.Term))
; TODO

; program: $eo_to_bin
(declare-const $eo_to_bin (-> sm.Term sm.Term sm.Term))
; TODO

; program: $eo_to_str
(declare-const $eo_to_str (-> sm.Term sm.Term))
; TODO

; program: $eo_typeof_apply
(declare-const $eo_typeof_apply (-> sm.Term sm.Term sm.Term))
; TODO

; declare: $eo_typeof
(declare-const $eo_typeof (-> sm.Term sm.Term))

; declare: $eo_nil
(declare-const $eo_nil (-> sm.Term sm.Term sm.Term))


; user defined symbols
$DEFS$

; program: $eo_typeof
; note: This is forward declared.
(assert (forall ((x1 sm.Term))
  (ite (= x1 sm.Stuck)
    (= ($eo_typeof x1) sm.Stuck)
  ; Core
  (ite (= x1 sm.Type)
    (= ($eo_typeof x1) sm.Type)
  (ite ((_ is sm.FunType) x1)
    ; (eo::requires (eo::typeof x1) Type (eo::requires (eo::typeof x2) Type Type))
    (= ($eo_typeof x1) ($eo_requires ($eo_typeof (sm.FunType.arg1 x1)) sm.Type ($eo_requires ($eo_typeof (sm.FunType.arg2 x1)) sm.Type sm.Type)))
  (ite ((_ is sm.Apply) x1)
    (= ($eo_typeof x1) ($eo_typeof_apply (sm.Apply.arg1 x1) (sm.Apply.arg2 x1)))
  (ite ((_ is sm.Var) x1)
    (= ($eo_typeof x1) (sm.Var.Type x1))
  (ite ((_ is sm.Const) x1)
    (= ($eo_typeof x1) (sm.Const.Type x1))
  ; Booleans
  (ite (= x1 sm.BoolType)
    (= ($eo_typeof x1) sm.Type)
  (ite (= x1 sm.True)
    (= ($eo_typeof x1) sm.BoolType)
  (ite (= x1 sm.False)
    (= ($eo_typeof x1) sm.BoolType)
  ; lists
  (ite (= x1 sm.ListType)
    (= ($eo_typeof x1) sm.Type)
  ;;; sm.List.cons has non-ground type, hence omitted
  (ite ((_ is sm.List.nil) x1)
    (= ($eo_typeof x1) sm.ListType)
  ; literal type rules
$TYPEOF_LITERALS$
  ; user declarations
$TYPEOF$
    (= ($eo_typeof x1) sm.Stuck)
)))))))))))
$TYPEOF_END$
))

; program: $eo_nil
; note: This is forward declared above.
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    (= ($eo_nil x1 x2) sm.Stuck)
$NIL$
    (= ($eo_nil x1 x2) sm.Stuck)
)
$NIL_END$
))

; Predicate for terms for which we have a proof.
(declare-const sm.hasProof (-> sm.Term Bool))

; first argument is an n-ary operator
; second argument is a formula that is an application
(declare-const sm.hasProofList (-> sm.Term sm.Term Bool))
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (ite (= x2 ($eo_nil x1 ($eo_typeof x2)))
    (= (sm.hasProofList x1 x2) true)
$HAS_PROOF_LIST$
    (= (sm.hasProofList x1 x2) false))
))

$RULES$
