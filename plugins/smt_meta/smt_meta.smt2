(set-logic UFDTSNIRA)

; TODO: types vs terms
;(declare-datatype sm.Type
;  (
;  )
;)
(declare-datatype sm.Term
  (
  ; The type of types  TODO: maybe this is Eunoia??
  (sm.Type)
  ; Application of an SMT-LIB term
  (sm.Apply (sm.Apply.arg1 sm.Term) (sm.Apply.arg2 sm.Term))

  ; generated by signature
$SM_TERM_DECL$
  )
)

; A Eunoia internal term
(declare-datatype eo.Term
  (
  ; Application of a Eunoia term
  (eo.Apply (eo.Apply.arg1 eo.Term) (eo.Apply.arg2 eo.Term))
  ; generated by signature
$SM_EO_TERM_DECL$
  )
)

; convert to SMT
(define-fun eo.to_smt ((x eo.Term)) sm.Term (eo.SmtTerm.arg1 x))
(define-fun smt.to_eo ((x sm.Term)) eo.Term (eo.SmtTerm x))

;;; Utilities

; Stuckness propagates through non-nullary constructors
;(define-fun $sm_FunType ((x sm.Term) (y sm.Term)) sm.Term
;  (ite (or (= x sm.Stuck) (= y sm.Stuck))
;    sm.Stuck
;    (sm.FunType x y)))

(define-fun $eo_Apply ((x eo.Term) (y eo.Term)) eo.Term
  (ite (or (= x eo.Stuck) (= y eo.Stuck))
    eo.Stuck
    (eo.Apply x y)))

;;; Definitions of forward declared programs in SMT preamble

; note: should never be called on negative numbers
(declare-fun $sm_mk_pow2 (Int) Int)
(assert (! (forall ((i Int))
  (= ($sm_mk_pow2 i) (ite (<= i 0) 1 (* 2 ($sm_mk_pow2 (- i 1)))))) :named sm.mk_pow2))

(define-fun $sm_mk_bit ((x Int) (i Int)) Bool
  (= (mod (div x ($sm_mk_pow2 i)) 2) 1))

(declare-fun $sm_mk_binary_and (Int Int Int) Int)
(assert (! (forall ((w Int) (x1 Int) (x2 Int))
  (= ($sm_mk_binary_and w x1 x2)
    (ite (= w 0) 0
    (ite (= w 1) (ite (and (= x1 1) (= x2 1)) 1 0)
      (+ ($sm_mk_binary_and (- w 1) x1 x2) (* ($sm_mk_pow2 w)
         (ite (and ($sm_mk_bit x1 w) ($sm_mk_bit x2 w)) 1 0))))))) :named sm.mk_bin_and))

; ((w Int) (x1 Int) (x2 Int))
(declare-fun $sm_mk_binary_or (Int Int Int) Int) ; TODO

; ((w Int) (x1 Int) (x2 Int))
(declare-fun $sm_mk_binary_xor (Int Int Int) Int) ; TODO

; ((w Int) (x1 Int))
(declare-fun $sm_mk_binary_not (Int Int) Int) ; TODO

; ((x1 Int) (l Int) (h Int))
(declare-fun $sm_mk_binary_extract (Int Int Int) Int) ; TODO

; ((w Int) (x Int) (x1 Int) (x2 Int))
(declare-fun $sm_mk_binary_concat (Int Int Int Int) Int) ; TODO


;;; Literal conversions
; All these methods should only be used for sm.Term

; smt-define: $eo_mk_bool
(define-fun $eo_mk_bool ((x Bool)) eo.Term
  (smt.to_eo (ite x sm.True sm.False)))

; program: $eo_mk_numeral
(define-fun $eo_mk_numeral ((n Int)) eo.Term
  (smt.to_eo (sm.Numeral n)))

; program: $eo_mk_rational
;(define-fun $eo_mk_rational ((r Real)) eo.Term
;  (smt.to_eo (sm.Rational r)))

; program: $eo_mk_string
;(define-fun $eo_mk_string ((s String)) eo.Term
;  (smt.to_eo (sm.String s)))

; program: $eo_mk_binary
(define-fun $eo_mk_binary ((w Int) (n Int)) eo.Term
  (ite (and (<= 0 w) (< w 4294967296))
    (smt.to_eo (sm.Binary w (mod n ($sm_mk_pow2 w))))
    eo.Stuck))

;;; Core operators

; axiom: $eo_is_ok
(define-fun $eo_is_ok ((x1 eo.Term)) eo.Term
  ($eo_mk_bool (not (= x1 eo.Stuck))))

; axiom: $eo_ite
(define-fun $eo_ite ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term)) eo.Term
  (ite (= x1 (eo.SmtTerm sm.True))
    x2
  (ite (= x1 (eo.SmtTerm sm.False))
    x3
    eo.Stuck)))

; axiom: $eo_requires
(define-fun $eo_requires ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term)) eo.Term
  (ite (and (not (= x1 eo.Stuck)) (not (= x2 eo.Stuck)) (= x1 x2))
    x3
    eo.Stuck))

; axiom: $eo_hash
; note: This is defined axiomatically.
; TODO: break dependence on sm.Numeral??
(declare-fun $eo_hash (eo.Term) eo.Term)
(assert (! (forall ((x eo.Term))
  (=> (not (= x eo.Stuck))
    (and
      ((_ is eo.SmtTerm) ($eo_hash x))
      ((_ is sm.Numeral) (eo.to_smt ($eo_hash x)))))) :named sm.hash_numeral))
(assert (! (forall ((x eo.Term) (y eo.Term))
  (=> (and (not (= x eo.Stuck)) (not (= y eo.Stuck))
    (= ($eo_hash x) ($eo_hash y))) (= x y))) :named sm.hash_inj))

;;; User defined symbols

$SM_DEFS$

;;; The verification condition

$SMT_VC$

(check-sat)
