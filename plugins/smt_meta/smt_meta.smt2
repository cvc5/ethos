(set-logic UFDTSNIRA)

; A Eunoia internal term
(declare-datatype eo.Term
  (
  ; Application of a Eunoia term
  (eo.Apply (eo.Apply.arg1 eo.Term) (eo.Apply.arg2 eo.Term))
  ; A term used to define the semantics of SMT-LIB.
  (eo.SmtTerm (eo.SmtTerm.val sm.Term))
  ; Represents "stuckness"
  (eo.Stuck)
  ; generated by signature
$SM_EO_TERM_DECL$
  ; none
  (eo.None)
  )
)

;(declare-datatype sm.Type
;  (
;  )
;)
(declare-datatype sm.Term
  (
  ; Core
  (sm.Type)
  (sm.FunType (sm.FunType.arg1 sm.Term) (sm.FunType.arg2 sm.Term))
  (sm.Apply (sm.Apply.arg1 sm.Term) (sm.Apply.arg2 sm.Term))
  ; Booleans
  (sm.BoolType)
  (sm.True)
  (sm.False)
  ; builtin literal types
  (sm.Numeral (sm.Numeral.val Int))
  (sm.Rational (sm.Rational.val Real))
  (sm.String (sm.String.val String))
  (sm.Binary (sm.Binary.width Int) (sm.Binary.val Int))

  ; Eunoia terms (these are not legal SMT-LIB terms).
  ; A term used to define the semantics of SMT-LIB.
  (sm.EoTerm (eo.EoTerm.val eo.Term))
  ; Represents "stuckness"
  (sm.Stuck)
  ; generated by signature
$SM_TERM_DECL$
  )
)

;;; Literal conversions

; smt-define: $smt_to_eo_bool
(define-fun $smt_to_eo_bool ((x Bool)) sm.Term
  (ite x sm.True sm.False))
  
; smt-define: $smt_from_eo_bool
(define-fun $smt_from_eo_bool ((x sm.Term)) Bool
  (= x sm.True))

; smt-define: $sm_is_Boolean
(define-fun $sm_is_Boolean ((x sm.Term)) Bool
  (or (= x sm.True) (= x sm.False)))
  
; smt-define: $smt_to_eo_z
(define-fun $smt_to_eo_z ((x Int)) sm.Term
  (sm.Numeral x))
  
; smt-define: $smt_from_eo_z
(define-fun $smt_from_eo_z ((x sm.Term)) Int
  (sm.Numeral.val x))

; smt-define: $smt_to_eo_q
(define-fun $smt_to_eo_q ((x Real)) sm.Term
  (sm.Rational x))
  
; smt-define: $smt_from_eo_q
(define-fun $smt_from_eo_q ((x sm.Term)) Real
  (sm.Rational.val x))

; smt-define: $smt_to_eo_str
(define-fun $smt_to_eo_str ((x String)) sm.Term
  (sm.String x))
  
; smt-define: $smt_from_eo_str
(define-fun $smt_from_eo_str ((x sm.Term)) String
  (sm.String.val x))

;;; Utilities

; Stuckness propagates through non-nullary constructors
(define-fun $sm_FunType ((x sm.Term) (y sm.Term)) sm.Term
  (ite (or (= x sm.Stuck) (= y sm.Stuck))
    sm.Stuck
    (sm.FunType x y)))

(define-fun $sm_Apply ((x sm.Term) (y sm.Term)) sm.Term
  (ite (or (= x sm.Stuck) (= y sm.Stuck))
    sm.Stuck
    (sm.Apply x y)))

(declare-fun $sm_pow2_eval (Int) Int)
; note: should never be called on negative numbers
(assert (! (forall ((i Int))
  (= ($sm_pow2_eval i) (ite (<= i 0) 1 (* 2 ($sm_pow2_eval (- i 1)))))) :named sm.eval_pow2))

(define-fun $sm_Binary ((w Int) (x Int)) sm.Term
  (ite (and (<= 0 w) (< w 4294967296))
    (sm.Binary w (mod x ($sm_pow2_eval w)))
    sm.Stuck))

(define-fun $sm_bit ((x Int) (i Int)) Bool
  (= (mod (div x ($sm_pow2_eval i)) 2) 1))

(declare-fun $sm_Binary_and (Int Int Int) Int)
(assert (! (forall ((w Int) (x1 Int) (x2 Int))
  (= ($sm_Binary_and w x1 x2)
    (ite (= w 0) 0
    (ite (= w 1) (ite (and (= x1 1) (= x2 1)) 1 0)
      (+ ($sm_Binary_and (- w 1) x1 x2) (* ($sm_pow2_eval w)
         (ite (and ($sm_bit x1 w) ($sm_bit x2 w)) 1 0))))))) :named sm.eval_bin_and))


; ((w Int) (x1 Int) (x2 Int))
(declare-fun $sm_Binary_or (Int Int Int) Int) ; TODO

; ((w Int) (x1 Int) (x2 Int))
(declare-fun $sm_Binary_xor (Int Int Int) Int) ; TODO

; ((w Int) (x1 Int))
(declare-fun $sm_Binary_not (Int Int) Int) ; TODO

; ((w1 Int) (x1 Int) (w2 Int) (x2 Int))
(define-fun $sm_Binary_concat ((w1 Int) (x1 Int) (w2 Int) (x2 Int)) sm.Term
    sm.Stuck) ; TODO

; ((w Int) (x Int) (x1 Int) (x2 Int))
(define-fun $sm_Binary_extract ((w Int) (x Int) (x1 Int) (x2 Int)) sm.Term
    sm.Stuck) ; TODO

;;; Core operators

; axiom: $eo_is_ok
(define-fun $eo_is_ok ((x1 sm.Term)) sm.Term
  ($smt_to_eo_bool (not (= x1 sm.Stuck))))

; axiom: $eo_ite
(define-fun $eo_ite ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term)) sm.Term
  (ite (= x1 sm.True)
    x2
  (ite (= x1 sm.False)
    x3
    sm.Stuck)))

; axiom: $eo_requires
(define-fun $eo_requires ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term)) sm.Term
  (ite (and (not (= x1 sm.Stuck)) (not (= x2 sm.Stuck)) (= x1 x2))
    x3
    sm.Stuck))

; axiom: $eo_hash
; note: This is defined axiomatically.
(declare-fun $eo_hash (sm.Term) sm.Term)
(assert (! (forall ((x sm.Term))
  (=> (not (= x sm.Stuck))
    ((_ is sm.Numeral) ($eo_hash x)))) :named sm.hash_numeral))
(assert (! (forall ((x sm.Term) (y sm.Term))
  (=> (and (not (= x sm.Stuck)) (not (= y sm.Stuck))
    (= ($eo_hash x) ($eo_hash y))) (= x y))) :named sm.hash_inj))

;;; Boolean operators

; axiom: $eo_not
(define-fun $eo_not ((x1 sm.Term)) sm.Term
  (ite ($sm_is_Boolean x1)
    ($smt_to_eo_bool (= x1 sm.False))
  (ite ((_ is sm.Binary) x1)
    (let ((w (sm.Binary.width x1)))
      ($sm_Binary w ($sm_Binary_not w (sm.Binary.val x1))))
    sm.Stuck)))

; axiom: $eo_and
(define-fun $eo_and ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    ($smt_to_eo_bool (and (= x1 sm.True) (= x2 sm.True)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    (let ((w (sm.Binary.width x1)))
      ($sm_Binary w
      ($sm_Binary_and w (sm.Binary.val x1) (sm.Binary.val x2))))
    sm.Stuck)))

; axiom: $eo_or
(define-fun $eo_or ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    ($smt_to_eo_bool (or (= x1 sm.True) (= x2 sm.True)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    (let ((w (sm.Binary.width x1)))
      ($sm_Binary w
      ($sm_Binary_or w (sm.Binary.val x1) (sm.Binary.val x2))))
    sm.Stuck)))

; axiom: $eo_xor
(define-fun $eo_xor ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    ($smt_to_eo_bool (xor (= x1 sm.True) (= x2 sm.True)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    (let ((w (sm.Binary.width x1)))
      ($sm_Binary w
      ($sm_Binary_xor w (sm.Binary.val x1) (sm.Binary.val x2))))
    sm.Stuck)))

;;; Arithmetic operators

; axiom: $eo_add
(define-fun $eo_add ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    (sm.Numeral (+ (sm.Numeral.val x1) (sm.Numeral.val x2)))
  (ite (and ((_ is sm.Rational) x1) ((_ is sm.Rational) x2))
    (sm.Rational (+ (sm.Rational.val x1) (sm.Rational.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    ($sm_Binary (sm.Binary.width x1) (+ (sm.Binary.val x1) (sm.Binary.val x2)))
    sm.Stuck))))

; axiom: $eo_mul
(define-fun $eo_mul ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    (sm.Numeral (* (sm.Numeral.val x1) (sm.Numeral.val x2)))
  (ite (and ((_ is sm.Rational) x1) ((_ is sm.Rational) x2))
    (sm.Rational (* (sm.Rational.val x1) (sm.Rational.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    ($sm_Binary (sm.Binary.width x1) (* (sm.Binary.val x1) (sm.Binary.val x2)))
    sm.Stuck))))

; axiom: $eo_qdiv
(define-fun $eo_qdiv ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2) (not (= (sm.Numeral.val x2) 0)))
    (sm.Rational (/ (to_real (sm.Numeral.val x1)) (to_real (sm.Numeral.val x2))))
  (ite (and ((_ is sm.Rational) x1) ((_ is sm.Rational) x2) (not (= (sm.Rational.val x2) 0.0)))
    (sm.Rational (/ (sm.Rational.val x1) (sm.Rational.val x2)))
    sm.Stuck)))

; axiom: $eo_zdiv
(define-fun $eo_zdiv ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2) (not (= (sm.Numeral.val x2) 0)))
    (sm.Numeral (div (sm.Numeral.val x1) (sm.Numeral.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)) (not (= (sm.Binary.val x2) 0)))
    ($sm_Binary (sm.Binary.width x1) (div (sm.Binary.val x1) (sm.Binary.val x2)))
    sm.Stuck)))

; axiom: $eo_zmod
(define-fun $eo_zmod ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2) (not (= (sm.Numeral.val x2) 0)))
    (sm.Numeral (mod (sm.Numeral.val x1) (sm.Numeral.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)) (not (= (sm.Binary.val x2) 0)))
    ($sm_Binary (sm.Binary.width x1) (mod (sm.Binary.val x1) (sm.Binary.val x2)))
    sm.Stuck)))

; axiom: $eo_is_neg
(define-fun $eo_is_neg ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    ($smt_to_eo_bool (< (sm.Numeral.val x1) 0))
  (ite ((_ is sm.Rational) x1)
    ($smt_to_eo_bool (< (sm.Rational.val x1) 0.0))
    sm.Stuck)))

; axiom: $eo_neg
(define-fun $eo_neg ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    (sm.Numeral (- (sm.Numeral.val x1)))
  (ite ((_ is sm.Rational) x1)
    (sm.Rational (- (sm.Rational.val x1)))
    sm.Stuck)))

;;; String operators

; axiom: $eo_len
(define-fun $eo_len ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Binary) x1)
    (sm.Numeral (sm.Binary.width x1))
  (ite ((_ is sm.String) x1)
    (sm.Numeral (str.len (sm.String.val x1)))
    sm.Stuck)))

; axiom: $eo_concat
(define-fun $eo_concat ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.String) x1) ((_ is sm.String) x2))
    (sm.String (str.++ (sm.String.val x1) (sm.String.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2))
    ($sm_Binary_concat (sm.Binary.width x1) (sm.Binary.val x1) (sm.Binary.width x2) (sm.Binary.val x2))
    sm.Stuck)))

; axiom: $eo_extract
(define-fun $eo_extract ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term)) sm.Term
  (ite (and ((_ is sm.String) x1) ((_ is sm.Numeral) x2) ((_ is sm.Numeral) x3))
    (let ((n2 (sm.Numeral.val x2)))
    (let ((n3 (sm.Numeral.val x3)))
    (sm.String (str.substr (sm.String.val x1) n2 (+ (- n3 n2) 1)))))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Numeral) x2) ((_ is sm.Numeral) x3))
    ($sm_Binary_extract (sm.Binary.width x1) (sm.Binary.val x1) (sm.Binary.val x2) (sm.Binary.val x3))
    sm.Stuck)))

; axiom: $eo_find
(define-fun $eo_find ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.String) x1) ((_ is sm.String) x2))
    (sm.Numeral (str.indexof (sm.String.val x1) (sm.String.val x2) 0))
    sm.Stuck))

;;; Conversion operators

; axiom: $eo_to_z
(define-fun $eo_to_z ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    x1
  (ite ((_ is sm.Rational) x1)
    (sm.Numeral (to_int (sm.Rational.val x1)))
  (ite ((_ is sm.Binary) x1)
    (sm.Numeral (sm.Binary.val x1))
  (ite (and ((_ is sm.String) x1) (= (str.len (sm.String.val x1)) 1))
    (sm.Numeral (str.to_code (sm.String.val x1)))
    sm.Stuck)))))

; axiom: $eo_to_q
(define-fun $eo_to_q ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    (sm.Rational (to_real (sm.Numeral.val x1)))
  (ite ((_ is sm.Rational) x1)
    x1
    sm.Stuck)))

; axiom: $eo_to_bin
(define-fun $eo_to_bin ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    ($sm_Binary (sm.Numeral.val x1) (sm.Numeral.val x2))
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Binary) x2))
    ($sm_Binary (sm.Numeral.val x1) (sm.Binary.val x2))
    sm.Stuck)))

; axiom: $eo_to_str
(define-fun $eo_to_str ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    (sm.String (str.from_code (sm.Numeral.val x1)))
  (ite ((_ is sm.String) x1)
    x1
  ; TODO?
    sm.Stuck)))

;;; User defined symbols

$SM_DEFS$

;;; The verification condition

$SMT_VC$

(check-sat)
