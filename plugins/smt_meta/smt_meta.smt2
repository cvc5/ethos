(set-logic UFDTSLIRA)

(declare-datatype sm.Term
  (
  ; Core
  (sm.Type)
  (sm.FunType (sm.FunType.arg1 sm.Term) (sm.FunType.arg2 sm.Term))
  (sm.Apply (sm.Apply.arg1 sm.Term) (sm.Apply.arg2 sm.Term))
  (sm.Var (sm.Var.name String) (sm.Var.Type sm.Term))
  (sm.Const (sm.Const.id Int) (sm.Const.Type sm.Term))  ; user constants
  (sm.Stuck)
  ; Booleans
  (sm.BoolType)
  (sm.True)
  (sm.False)
  ; builtin literal types
  (sm.Numeral (sm.Numeral.val Int))
  (sm.Rational (sm.Rational.val Real))
  (sm.Decimal (sm.Decimal.val Real))
  (sm.String (sm.String.val String))
  (sm.Binary (sm.Binary.width Int) (sm.Binary.val Int))
  (sm.Hexadecimal (sm.Hexadecimal.width Int) (sm.Hexadecimal.val Int))
  ; generated by signature
$TERM_DECL$
  )
)

;;; Utilities

; define: $sm_Boolean
(define-fun $sm_Boolean ((x Bool)) sm.Term
  (ite x sm.True sm.False))

; define: $sm_is_Boolean
(define-fun $sm_is_Boolean ((x sm.Term)) Bool
  (or (= x sm.True) (= x sm.False)))

; Stuckness propagates through non-nullary constructors
(define-fun $sm_FunType ((x sm.Term) (y sm.Term)) sm.Term
  (ite (or (= x sm.Stuck) (= y sm.Stuck))
    sm.Stuck
    (sm.FunType x y)))

(define-fun $sm_Apply ((x sm.Term) (y sm.Term)) sm.Term
  (ite (or (= x sm.Stuck) (= y sm.Stuck))
    sm.Stuck
    (sm.Apply x y)))

(define-fun $sm_Const ((x Int) (y sm.Term)) sm.Term
  (ite (= y sm.Stuck)
    sm.Stuck
    (sm.Const x y)))

(define-fun $sm_mod_pow_2 ((x Int) (w Int)) Int
  (mod x (^ 2 w)))  ; TODO: improve?

(define-fun $sm_Binary ((w Int) (x Int)) sm.Term
  (ite (and (<= 0 w) (< w 4294967296))
    (sm.Binary w ($sm_mod_pow_2 x w))
    sm.Stuck))

(define-fun $sm_Binary_and ((w Int) (x1 Int) (x2 Int)) sm.Term
    sm.Stuck) ; TODO

(define-fun $sm_Binary_or ((w Int) (x1 Int) (x2 Int)) sm.Term
    sm.Stuck) ; TODO

(define-fun $sm_Binary_xor ((w Int) (x1 Int) (x2 Int)) sm.Term
    sm.Stuck) ; TODO

(define-fun $sm_Binary_not ((w Int) (x1 Int)) sm.Term
    sm.Stuck) ; TODO

(define-fun $sm_Binary_concat ((w1 Int) (x1 Int) (w2 Int) (x2 Int)) sm.Term
    sm.Stuck) ; TODO

(define-fun $sm_Binary_extract ((w Int) (x Int) (x1 Int) (x2 Int)) sm.Term
    sm.Stuck) ; TODO

;;; Core operators

; program: $eo_is_ok
(define-fun $eo_is_ok ((x1 sm.Term)) sm.Term
  ($sm_Boolean (not (= x1 sm.Stuck))))

; program: $eo_ite
(define-fun $eo_ite ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term)) sm.Term
  (ite (= x1 sm.True)
    x2
  (ite (= x1 sm.False)
    x3
    sm.Stuck)))

; program: $eo_requires
(define-fun $eo_requires ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term)) sm.Term
  (ite (and (not (= x1 sm.Stuck)) (not (= x2 sm.Stuck)) (= x1 x2))
    x3
    sm.Stuck))

; program: $eo_hash
; note: This is defined axiomatically.
(declare-fun $eo_hash (sm.Term) sm.Term)
(assert (forall ((x sm.Term))
  (=> (not (= x sm.Stuck))
    ((_ is sm.Numeral) ($eo_hash x)))))
(assert (forall ((x sm.Term) (y sm.Term))
  (=> (and (not (= x sm.Stuck)) (not (= y sm.Stuck))
    (= ($eo_hash x) ($eo_hash y))) (= x y))))

; program: $eo_nameof
(define-fun $eo_nameof ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Var) x1)
    (sm.String (sm.Var.name x1))
    sm.Stuck))

; fwd-decl: $eo_var
; note: this method is not recursive but relies on $eo_typeof, which
;       is part of the desugaring step.
(declare-fun $eo_var (sm.Term sm.Term) sm.Term)

;;; Boolean operators

; program: $eo_and
(define-fun $eo_and ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    ($sm_Boolean (and (= x1 sm.True) (= x2 sm.True)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    ($sm_Binary_and (sm.Binary.width x1) (sm.Binary.val x1) (sm.Binary.val x2))
    sm.Stuck)))

; program: $eo_or
(define-fun $eo_or ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    ($sm_Boolean (or (= x1 sm.True) (= x2 sm.True)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    ($sm_Binary_or (sm.Binary.width x1) (sm.Binary.val x1) (sm.Binary.val x2))
    sm.Stuck)))

; program: $eo_xor
(define-fun $eo_xor ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2))
    ($sm_Boolean (xor (= x1 sm.True) (= x2 sm.True)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    ($sm_Binary_xor (sm.Binary.width x1) (sm.Binary.val x1) (sm.Binary.val x2))
    sm.Stuck)))

; program: $eo_not
(define-fun $eo_not ((x1 sm.Term)) sm.Term
  (ite ($sm_is_Boolean x1)
    ($sm_Boolean (= x1 sm.False))
  (ite ((_ is sm.Binary) x1)
    ($sm_Binary_not (sm.Binary.width x1) (sm.Binary.val x1))
    sm.Stuck)))

;;; Arithmetic operators

; program: $eo_add
(define-fun $eo_add ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    (sm.Numeral (+ (sm.Numeral.val x1) (sm.Numeral.val x2)))
  (ite (and ((_ is sm.Rational) x1) ((_ is sm.Rational) x2))
    (sm.Rational (+ (sm.Rational.val x1) (sm.Rational.val x2)))
  (ite (and ((_ is sm.Decimal) x1) ((_ is sm.Decimal) x2))
    (sm.Decimal (+ (sm.Decimal.val x1) (sm.Decimal.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    ($sm_Binary (sm.Binary.width x1) (+ (sm.Binary.val x1) (sm.Binary.val x2)))
    sm.Stuck)))))

; program: $eo_mul
(define-fun $eo_mul ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    (sm.Numeral (* (sm.Numeral.val x1) (sm.Numeral.val x2)))
  (ite (and ((_ is sm.Rational) x1) ((_ is sm.Rational) x2))
    (sm.Rational (* (sm.Rational.val x1) (sm.Rational.val x2)))
  (ite (and ((_ is sm.Decimal) x1) ((_ is sm.Decimal) x2))
    (sm.Decimal (* (sm.Decimal.val x1) (sm.Decimal.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))
    ($sm_Binary (sm.Binary.width x1) (* (sm.Binary.val x1) (sm.Binary.val x2)))
    sm.Stuck)))))

; program: $eo_qdiv
(define-fun $eo_qdiv ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2) (not (= (sm.Numeral.val x2) 0)))
    (sm.Rational (/ (to_real (sm.Numeral.val x1)) (to_real (sm.Numeral.val x2))))
  (ite (and ((_ is sm.Rational) x1) ((_ is sm.Rational) x2) (not (= (sm.Rational.val x2) 0.0)))
    (sm.Rational (/ (sm.Rational.val x1) (sm.Rational.val x2)))
  (ite (and ((_ is sm.Decimal) x1) ((_ is sm.Decimal) x2) (not (= (sm.Decimal.val x2) 0.0)))
    (sm.Rational (/ (sm.Decimal.val x1) (sm.Decimal.val x2)))
    sm.Stuck))))

; program: $eo_zdiv
(define-fun $eo_zdiv ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2) (not (= (sm.Numeral.val x2) 0)))
    (sm.Numeral (div (sm.Numeral.val x1) (sm.Numeral.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)) (not (= (sm.Binary.val x2) 0)))
    ($sm_Binary (sm.Binary.width x1) (div (sm.Binary.val x1) (sm.Binary.val x2)))
    sm.Stuck)))

; program: $eo_zmod
(define-fun $eo_zmod ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2) (not (= (sm.Numeral.val x2) 0)))
    (sm.Numeral (mod (sm.Numeral.val x1) (sm.Numeral.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2) (= (sm.Binary.width x1) (sm.Binary.width x2)) (not (= (sm.Binary.val x2) 0)))
    ($sm_Binary (sm.Binary.width x1) (mod (sm.Binary.val x1) (sm.Binary.val x2)))
    sm.Stuck)))

; program: $eo_is_neg
(define-fun $eo_is_neg ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    ($sm_Boolean (< (sm.Numeral.val x1) 0))
  (ite ((_ is sm.Rational) x1)
    ($sm_Boolean (< (sm.Rational.val x1) 0.0))
  (ite ((_ is sm.Decimal) x1)
    ($sm_Boolean (< (sm.Decimal.val x1) 0.0))
    sm.Stuck))))

; program: $eo_neg
(define-fun $eo_neg ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    (sm.Numeral (- (sm.Numeral.val x1)))
  (ite ((_ is sm.Rational) x1)
    (sm.Rational (- (sm.Rational.val x1)))
  (ite ((_ is sm.Decimal) x1)
    (sm.Decimal (- (sm.Decimal.val x1)))
  (ite ((_ is sm.Binary) x1)
    ($sm_Binary (sm.Binary.width x1) (- (sm.Binary.val x1)))
    sm.Stuck)))))

;;; String operators

; program: $eo_len
(define-fun $eo_len ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Binary) x1)
    (sm.Numeral (sm.Binary.width x1))
  (ite ((_ is sm.Hexadecimal) x1)
    (sm.Numeral (sm.Hexadecimal.width x1))
  (ite ((_ is sm.String) x1)
    (sm.Numeral (str.len (sm.String.val x1)))
    sm.Stuck))))

; program: $eo_concat
(define-fun $eo_concat ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.String) x1) ((_ is sm.String) x2))
    (sm.String (str.++ (sm.String.val x1) (sm.String.val x2)))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Binary) x2))
    ($sm_Binary_concat (sm.Binary.width x1) (sm.Binary.val x1) (sm.Binary.width x2) (sm.Binary.val x2))
    sm.Stuck)))

; program: $eo_extract
(define-fun $eo_extract ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term)) sm.Term
  (ite (and ((_ is sm.String) x1) ((_ is sm.Numeral) x2) ((_ is sm.Numeral) x3))
    (let ((n2 (sm.Numeral.val x2)))
    (let ((n3 (sm.Numeral.val x3)))
    (sm.String (str.substr (sm.String.val x1) n2 (+ (- n3 n2) 1)))))
  (ite (and ((_ is sm.Binary) x1) ((_ is sm.Numeral) x2) ((_ is sm.Numeral) x3))
    ($sm_Binary_extract (sm.Binary.width x1) (sm.Binary.val x1) (sm.Binary.val x2) (sm.Binary.val x3))
    sm.Stuck)))

; program: $eo_find
(define-fun $eo_find ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.String) x1) ((_ is sm.String) x2))
    (sm.Numeral (str.indexof (sm.String.val x1) (sm.String.val x2) 0))
    sm.Stuck))

;;; Conversion operators

; program: $eo_to_z
(define-fun $eo_to_z ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    x1
  (ite ((_ is sm.Rational) x1)
    (sm.Numeral (to_int (sm.Rational.val x1)))
  (ite ((_ is sm.Decimal) x1)
    (sm.Numeral (to_int (sm.Decimal.val x1)))
  (ite ((_ is sm.Binary) x1)
    (sm.Numeral (sm.Binary.val x1))
  (ite ((_ is sm.Hexadecimal) x1)
    (sm.Numeral (sm.Hexadecimal.val x1))
  (ite (and ((_ is sm.String) x1) (= (str.len (sm.String.val x1)) 1))
    (sm.Numeral (str.to_code (sm.String.val x1)))
    sm.Stuck)))))))

; program: $eo_to_q
(define-fun $eo_to_q ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    (sm.Rational (to_real (sm.Numeral.val x1)))
  (ite ((_ is sm.Rational) x1)
    x1
  (ite ((_ is sm.Decimal) x1)
    (sm.Rational (sm.Decimal.val x1))
    sm.Stuck))))

; program: $eo_to_bin
(define-fun $eo_to_bin ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Numeral) x2))
    ($sm_Binary (sm.Numeral.val x1) (sm.Numeral.val x2))
  (ite (and ((_ is sm.Numeral) x1) ((_ is sm.Binary) x2))
    ($sm_Binary (sm.Numeral.val x1) (sm.Binary.val x2))
    sm.Stuck)))

; program: $eo_to_str
(define-fun $eo_to_str ((x1 sm.Term)) sm.Term
  (ite ((_ is sm.Numeral) x1)
    (sm.String (str.from_code (sm.Numeral.val x1)))
  (ite ((_ is sm.String) x1)
    x1
  ; TODO?
    sm.Stuck)))

;;; User defined symbols

$DEFS$

;;; Meta symbols

; program: $eo_var
(assert (forall ((x1 sm.Term) (x2 sm.Term))
  (= ($eo_var x1 x2)
  (ite (and ((_ is sm.String) x1) (= ($eo_typeof x2) sm.Type))
    (sm.Var (sm.String.val x1) x2)
    sm.Stuck))))
    
; program: $eo_typeof
; note: This is forward in the signature.
(assert (forall ((x1 sm.Term))
  (= ($eo_typeof x1)
  (ite (= x1 sm.Stuck)
    sm.Stuck
  ;; literal type rules
$TYPEOF_LITERALS$
    ($eo_typeof_main x1)))
$TYPEOF_END$
))

(check-sat)
