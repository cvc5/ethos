
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_eo

; This portion gives a template for defining the model semantics of
; a Eunoia signature. The signature model_smt.eo uses this signature
; to define (a user extension of) the standard SMT-LIB semantics.
;
; In the end we define:
; <user signature>
; <this file, instantiated based on the above signature>
; <model_smt.eo>
;
; Note that we instantiate model_smt.eo directly (SMT_EVAL_CASES)
; based on a controlled template, namely which standard SMT-LIB operators
; are present in the user signature, where *names* are taken literally.
; That is, if the user declares "+", then it may appear in the model
; evaluation function in the instantiated version of model_smt.eo.

; Returns a predicate describing the properties of symbols
; that cannot be assigned a total semantics. For example,
; this is what defines skolem symbols.
(program $eo_const_predicate ((k $smt_builtin_Int) (i $smt_builtin_Int) (T $eo_Term) (x $eo_Term))
  :signature ($smt_builtin_Int $smt_builtin_Int $eo_Term $eo_Term) $eo_Term
  (
$EO_CONST_PREDICATE_CASES$
  ; return stuckness, this will be handled upstream
  (($eo_const_predicate k i T x) $eo_stuck)
  )
)

; This method can be used to define evaluation functions
; that cannot be described in terms of SMT-LIB conventions.
; TODO: not necessary for CPC?
(program $eo_model_eval ((t $eo_Term))
  :signature ($eo_Term) $eo_Term
  (
$EO_EVAL_CASES$
  ; return stuckness, this will be handled upstream
  (($eo_model_eval t) $eo_stuck)
  )
)
; Lookup the predicate the constant can be assumed to have.
; If the kind is 0, it is an SMT-LIB input constant, we return true.
; Otherwise, we lookup the predicate for the skolem, which may be
; user-defined. Note this need not be a valid formula due to the
; definition of $smtx_model_eval, which checks whether the predicate
; is satisfied in the model.
; If this is undefined, we return true.
(program $smtx_const_predicate
  ((k $smt_builtin_Int) (id $smt_builtin_Int) (T $smt_Type) (val $smt_Term))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_Type $smt_Term) $smt_builtin_Bool
  (
  ; TODO
  (($smtx_const_predicate k id T val) $smt_builtin_true)
    ($sm_is_true ; wrong
      ($smt_try_eo
        ($eo_const_predicate k id ($eo_smt_type T) ($eo_smt_term val))
        $sm_mk_true)))
  )
)
