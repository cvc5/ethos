; This is both a valid *.smt2 and *.eo file after filling in the templates.
; For consistency we name it *.eo.

; The final embedding of SMT-LIB types that are relevant to the VC.
(declare-datatype tsm.Type
  (
  ; the Boolean type
  (tsm.Bool)
  ; uninterpreted sorts
  (tsm.USort (tsm.USort.arg1 Int))
  ; The application of SMT-LIB types
  (tsm.Apply (tsm.Apply.arg1 tsm.Type) (tsm.Apply.arg2 tsm.Type))
$SM_TYPE_DECL$
  ; error sort
  (tsm.NullSort (tsm.NullSort.arg1 Int))
  )
)

; carrying the literal types?
$SM_LITERAL_TYPE_DECL$

; The final embedding of SMT-LIB terms that are relevant to the VC.
; In other words, this defines the Herbrand universe.
(declare-datatype sm.Term
  (
$SM_TERM_DECL$
  )
)

; The final embedding of Eunoia terms that are relevant to the VC.
; SMT-LIB terms, types and values are embedded in this datatype.
; We require a mutually recursive datatype, since these are
; inter-dependent.
(declare-datatypes ((eo.Term 0) (vsm.Value 0) (msm.Map 0))
  (
  (
  ; The type of types in Eunoia
  (eo.Type)
$SM_EO_TERM_DECL$
  )
  (
  ; map with an index type
  ; valueness: $smtx_map_is_value
  (vsm.Map (vsm.Map.arg1 tsm.Type) (vsm.Map.arg2 msm.Map))
  ; uninterpreted constants
  ; valueness: $smtx_usort_is_value
  (vsm.UValue (vsm.UValue.arg1 tsm.Type) (vsm.UValue.arg2 Int))
  ; an SMT value represented by an SMT-LIB term, e.g. Int/Real/String.
  ; valueness: $smtx_is_value
  (vsm.Term (vsm.Term.arg1 sm.Term))
  ; A non-value
  (vsm.NotValue)
  )
  (
  ; (msm.Map.cons i e M) maps i -> e, as well as mappings in M
  (msm.Map.cons (msm.Map.cons.arg1 vsm.Value) (msm.Map.cons.arg2 vsm.Value) (msm.Map.cons.arg3 msm.Map))
  ; (msm.Map.default e) maps all remaining elements in the sort to e
  (msm.Map.default (msm.Map.default.arg1 vsm.Value))
  ))
)
