; The final embedding of SMT-LIB types that are relevant to the VC.
(declare-datatype tsm.Type
  (
  ; the Boolean type
  (tsm.BoolType)
  ; uninterpreted sorts
  (tsm.USort (tsm.USort.arg1 Int))
  ; error sort
  (tsm.NullSort)
  ; generated by signature
$SM_TYPE_DECL$
  )
)

; carrying the literal types?
$SM_LITERAL_TYPE_DECL$

; The final embedding of SMT-LIB terms that are relevant to the VC.
(declare-datatype sm.Term
  (
  ; the apply
  (sm.Apply (sm.Apply.arg1 sm.Term) (sm.Apply.arg2 sm.Term))
  ; Booleans
  ; NOTE: these are inlined for efficiency and to ensure there are no Boolean subterms
  (sm.True)
  (sm.False)
  ; builtin literals
  (sm.Numeral (sm.Numeral.arg1 $smt_builtin_Int))
  (sm.Rational (sm.Rational.arg1 $smt_builtin_Real))
  (sm.String (sm.String.arg1 $smt_builtin_String))
  (sm.Binary (sm.Binary.arg1 $smt_builtin_Int) (sm.Binary.arg2 $smt_builtin_Int))
  ; free constants
  (sm.Const (sm.Const.arg1 $smt_builtin_Int) (sm.Const.arg2 $smt_builtin_Int) (sm.Const.arg3 tsm.Type))
  ; skolems
  (sm.Skolem (sm.Skolem.arg1 $smt_builtin_Int) (sm.Skolem.arg2 $smt_builtin_Int) (sm.Skolem.arg3 tsm.Type))
  ; generated by signature
$SM_TERM_DECL$
  )
)

; The final embedding of Eunoia terms that are relevant to the VC.
; SMT-LIB terms, types and values are embedded in this datatype.
; We require a mutually recursive datatype, since these are
; inter-dependent.
(declare-datatypes ((eo.Term 0) (vsm.Value 0) (@Map 0))
  (
  (
  ; The type of types in Eunoia
  (eo.Type)
  ; The Eunoia function type.
  (eo.FunType (eo.FunType.arg1 eo.Term) (eo.FunType.arg2 eo.Term))
  ; Application of a Eunoia term
  (eo.Apply (eo.Apply.arg1 eo.Term) (eo.Apply.arg2 eo.Term))
  ; The Eunoia representation of an SMT-LIB term
  (eo.SmtTerm (eo.SmtTerm.arg1 sm.Term))
  ; The Eunoia representation of an SMT-LIB type
  (eo.SmtType (eo.SmtType.arg1 tsm.Type))
  ; The Eunoia representation of an SMT-LIB value
  ;(eo.SmtValue (eo.SmtValue.arg1 vsm.Value))
  ; Defines "stuckness"
  (eo.Stuck)
  ; generated by signature
$SM_EO_TERM_DECL$
  )
  (
  ; map with an index type
  ; valueness: $smtx_map_is_value
  (vsm.Map (vsm.Map.arg1 @Map) (vsm.Map.arg2 $smt_Type))
  ; uninterpreted constants
  ; valueness: $smtx_usort_is_value
  (vsm.UConst (vsm.UConst.arg1 $smt_Type) (i $smt_builtin_Int))
  ; an SMT value represented by an SMT-LIB term, e.g. Int/Real/String.
  ; valueness: $smtx_is_value
  (vsm.Term (vsm.Term.arg1 $smt_Term))
  ; A non-value
  (vsm.NotValue)
  )
  (
  ; (@Map_cons i e M) maps i -> e, as well as mappings in M
  (@Map_cons (@Map_cons.arg1 vsm.Value) (@Map_cons.arg2 vsm.Value) (@Map_cons.arg3 @Map))
  ; (@Map_default e) maps all remaining elements in the sort to e
  (@Map_default (@Map_default.arg1 vsm.Value))
  ))
)

;;; Utilities

; TODO: convert to Eunoia

(define $eo_is_stuck ((x eo.Term))
  ($smt_apply_2 "=" x eo.Stuck))

; Stuckness propagates through non-nullary constructors
(define $eo_FunType ((x eo.Term) (y eo.Term))
  ($smt_apply_3 "ite"
    ($smt_builtin_or ($eo_is_stuck x) ($eo_is_stuck y))
    eo.Stuck
    (eo.FunType x y)))

(define $eo_Apply ((x eo.Term) (y eo.Term))
  ($smt_apply_3 "ite"
    ($smt_builtin_or ($eo_is_stuck x) ($eo_is_stuck y))
    eo.Stuck
    (eo.Apply x y)))

;;; Core operators

; Note that these cannot be lifted further since their semantics wrt
; stuckness is based on the deep embedding of Eunoia terms into SMT-LIB
; datatypes

; axiom: $eo_is_ok
(define $eo_is_ok ((x1 eo.Term)) eo.Term
  ($smt_apply_3 "ite" ($eo_is_stuck x1)
    (eo.SmtTerm sm.False)
    (eo.SmtTerm sm.True)))

; axiom: $eo_ite
(define-fun $eo_ite ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term)) eo.Term
  ($smt_apply_3 "ite" ($smt_apply_2 "=" x1 (eo.SmtTerm sm.True))
    x2
  ($smt_apply_3 "ite" ($smt_apply_2 "=" x1 (eo.SmtTerm sm.False))
    x3
    eo.Stuck)))

; axiom: $eo_requires
(define-fun $eo_requires ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term)) eo.Term
  ($smt_apply_3 "ite"
    ($smt_apply_2 "and"
      ($smt_builtin_not ($eo_is_stuck x1))
      ($smt_apply_2 "and"
        ($smt_builtin_not ($eo_is_stuck x2))
        ($smt_apply_2 "=" x1 x2)))
    x3
    eo.Stuck))
