;;;; TEMPORARY
;(declare-const $smt_builtin_Int Type)
;(declare-const $smt_builtin_Real Type)
;(declare-const $smt_builtin_String Type)
;;;; TEMPORARY

; The final embedding of SMT-LIB types that are relevant to the VC.
(declare-datatype tsm.new.Type
  (
  ; the Boolean type
  (tsm.new.BoolType)
  ; uninterpreted sorts
  (tsm.new.USort (tsm.new.USort.arg1 $smt_builtin_Int))
  ; error sort
  (tsm.new.NullSort)
$SM_TYPE_DECL$
  )
)

; carrying the literal types?
$SM_LITERAL_TYPE_DECL$

; The final embedding of SMT-LIB terms that are relevant to the VC.
(declare-datatype sm.new.Term
  (
  ; the apply
  (sm.new.Apply (sm.new.Apply.arg1 sm.new.Term) (sm.new.Apply.arg2 sm.new.Term))
  ; Booleans
  ; NOTE: these are inlined for efficiency and to ensure there are no Boolean subterms
  (sm.new.True)
  (sm.new.False)
  ; builtin literals
  (sm.new.Numeral (sm.new.Numeral.arg1 $smt_builtin_Int))
  (sm.new.Rational (sm.new.Rational.arg1 $smt_builtin_Real))
  (sm.new.String (sm.new.String.arg1 $smt_builtin_String))
  (sm.new.Binary (sm.new.Binary.arg1 $smt_builtin_Int) (sm.new.Binary.arg2 $smt_builtin_Int))
  ; free constants
  (sm.new.Const (sm.new.Const.arg1 $smt_builtin_Int) (sm.new.Const.arg2 $smt_builtin_Int) (sm.new.Const.arg3 tsm.new.Type))
  ; skolems
  (sm.new.Skolem (sm.new.Skolem.arg1 $smt_builtin_Int) (sm.new.Skolem.arg2 $smt_builtin_Int) (sm.new.Skolem.arg3 tsm.new.Type))
$SM_TERM_DECL$
  )
)

; The final embedding of Eunoia terms that are relevant to the VC.
; SMT-LIB terms, types and values are embedded in this datatype.
; We require a mutually recursive datatype, since these are
; inter-dependent.
(declare-datatypes ((eo.new.Term 0) (vsm.new.Value 0) (@Map 0))
  (
  (
  ; The type of types in Eunoia
  (eo.new.Type)
  ; The Eunoia function type.
  (eo.new.FunType (eo.new.FunType.arg1 eo.new.Term) (eo.new.FunType.arg2 eo.new.Term))
  ; Application of a Eunoia term
  (eo.new.Apply (eo.new.Apply.arg1 eo.new.Term) (eo.new.Apply.arg2 eo.new.Term))
  ; The Eunoia representation of an SMT-LIB term
  (eo.new.SmtTerm (eo.new.SmtTerm.arg1 sm.new.Term))
  ; The Eunoia representation of an SMT-LIB type
  (eo.new.SmtType (eo.new.SmtType.arg1 tsm.new.Type))
  ; The Eunoia representation of an SMT-LIB value
  ;(eo.new.SmtValue (eo.new.SmtValue.arg1 vsm.new.Value))
  ; "stuckness"
  (eo.new.Stuck)
$SM_EO_TERM_DECL$
  )
  (
  ; map with an index type
  ; valueness: $smtx_map_is_value
  (vsm.new.Map (vsm.new.Map.arg1 @Map) (vsm.new.Map.arg2 tsm.new.Type))
  ; uninterpreted constants
  ; valueness: $smtx_usort_is_value
  (vsm.new.UConst (vsm.new.UConst.arg1 tsm.new.Type) (i $smt_builtin_Int))
  ; an SMT value represented by an SMT-LIB term, e.g. Int/Real/String.
  ; valueness: $smtx_is_value
  (vsm.new.Term (vsm.new.Term.arg1 sm.new.Term))
  ; A non-value
  (vsm.new.NotValue)
  )
  (
  ; (@Map_cons i e M) maps i -> e, as well as mappings in M
  (@Map_cons (@Map_cons.arg1 vsm.new.Value) (@Map_cons.arg2 vsm.new.Value) (@Map_cons.arg3 @Map))
  ; (@Map_default e) maps all remaining elements in the sort to e
  (@Map_default (@Map_default.arg1 vsm.new.Value))
  ))
)

(program $get_meta_type ((T Type) (t T))
  :signature (T) Type
  (
  (($get_meta_type t) $eo_Term)
  )
)

; This will be replaced by the datatype sm.Term in the final encoding.
(declare-const $smt_Term Type)

; An SMT-LIB type.
; This will be replaced by the datatype tsm.Type in the final encoding.
(declare-const $smt_Type Type)

; An SMT-LIB value.
; This will be replaced by the datatype vsm.Value in the final encoding.
(declare-const $smt_Value Type)



