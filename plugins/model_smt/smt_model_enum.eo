

; type enumeration

; note: The methods in this section are only included (based on trim-defs) if
; the verification condition is reasoning about quantified formulas

; we have no incorporate of irrational values, which can be soundly approximated using
; $vsm_UValue.
;(define $smt_irrat_enum ((i $smt_Numeral))
;  ($vsm_UValue $smt_Rational i))

; NOTE: the "stuckness" of this method defines cardinality for types!!!!!!!
; Thus it is different from the other methods in this signature, which use
; stuckness as a no-op in a callback.
(program $eo_enum_type ((T $eo_Term) (i $smt_builtin_Int))
  :signature ($eo_Term $smt_builtin_Int) $eo_Term
  (
  ; enumeration of standard SMT types
  ;(($eo_enum_type $smt_Numeral i)     (eo::define ((v (eo::zdiv i 2)))
  ;                                      ($smt_apply_3 "ite" ($smt_apply_= (eo::zmod i 2) 0) v (eo::neg v))))
  ;(($eo_enum_type $smt_String i)      ($smt_apply_3 "ite" ($smt_apply_= i 0)
  ;                                      ""
  ;                                      (eo::concat (eo::to_str (eo::zmod i 196608)) ($eo_enum_type $smt_String (eo::zdiv i 196608)))))
  ; rationals are treated as Real, meaning we interleave rational/irrational.
  ;(($eo_enum_type $smt_Rational i)    (eo::define ((ir (eo::zdiv i 2)))
  ;                                    (eo::define ((isRat ($smt_apply_= (eo::zmod ir 2) 0)))
  ;                                    (eo::define ((i (eo::zdiv ir 2)))
  ;                                    (eo::define ((v ($smt_apply_3 "ite" isRat ($eo_rat_to_num ($smt_rat_enum i)) ($smt_irrat_enum i))))
  ;                                      ($smt_apply_3 "ite" ($smt_apply_= (eo::zmod i 2) 0) v (eo::neg v)))))))
  ; Note that $smt_BitVec must be mapped to the user's definition of binaries.
  ; Note this method gets stuck if i > 2^w, indicating we have run out of values.
  ;(($eo_enum_type ($smt_BitVec w) i) (eo::define ((v (eo::to_bin w i)))
  ;                                      ($eo_requires (eo::to_z v) i v)))
  ; TODO: functions, datatypes
  ; Try to enumerate the type, if we fail, we return $vsm_UValue.
  ; Note that this essentially assumes that unhandled types are uninterpreted
  ; and have infinite cardinality (since this does not get stuck).
  ;(($eo_enum_type T i)                ($eo_smt_value ($vsm_uconst T i)))
  ; FIXME
  (($eo_enum_type T i) T)
  )
)

; program: ($smtx_enum_type_contains_rec T t i)
; Returns true if t is contained in the type enumeration of T, starting from i.
;(program $eo_enum_type_contains_rec ((T $smt_Type) (t $smt_Term) (i $smt_builtin_Int))
;  :signature ($smt_Type $smt_Term $smt_builtin_Int) Bool
;  (
;  (($smtx_enum_type_contains_rec T t i)   (eo::define ((v ($smtx_enum_type T i)))
;                                          ($smt_apply_3 "ite" ($eo_is_ok v)
;                                          ($smt_apply_3 "ite" ($smt_apply_= v t)
;                                            true
;                                            ($smtx_enum_type_contains_rec T i ($smt_apply_2 "+" i 1)))
;                                          false)))
;  )
;)



;;; Definitions of Type enumeration

;;; SMT term list

; A list of SMT terms, defined as a datatype for convienience in this signature.
(declare-datatype @STermList
  (
  (@STermList_cons (@STermList_cons.arg1 $smt_Term) (@STermList_cons.arg2 @STermList))
  (@STermList_nil)
  )
)

; Concatenate lists of SMT terms.
(program $smtx_list_concat ((x $smt_Term) (y @STermList) (z @STermList))
  :signature (@STermList @STermList) @STermList
  (
  (($smtx_list_concat (@STermList_cons x y) z)  (@STermList_cons x ($smtx_list_concat y z)))
  (($smtx_list_concat @STermList_nil z)         z)
  )
)

;;; Rational pair

; A rational pair, used for enumerating reals
(declare-datatype @RatPair
  (
  (@RatPair_mk (@RatPair_mk.arg1 $smt_builtin_Int) (@RatPair_mk.arg2 $smt_builtin_Int))
  )
)

; TODO: lift
; Based on Calkinâ€“Wilf tree.
; NOTE: this method is only necessary if reasoning about the enumeration of Reals,
; this is only necessary if we are proving soundness of a proof rule that involves
; quantified reals.
;(program $eo_rat_enum_rec
;  ((i $smt_Numeral) (n $smt_Numeral) (d $smt_Numeral) (r @smt_RatPair) (rs @sterm_list))
;  :signature ($smt_Numeral @sterm_list) @smt_RatPair
;  (
;  (($eo_rat_enum_rec 0 (@sterm_list_cons r rs)) r)
;  (($eo_rat_enum_rec i (@sterm_list_cons (@smt_ratPair n d) rs))
;     (eo::define ((r1 (@smt_ratPair (eo::add n d) d)))
;     (eo::define ((r2 (@smt_ratPair n (eo::add n d))))
;      ($eo_rat_enum_rec (eo::add i -1)
;        ($eo_list_concat rs (@sterm_list_cons r1 (@sterm_list_cons r2 @sterm_list_nil)))))))
;  )
;)

;(define $smt_rat_enum ((i $smt_Numeral))
;  ($eo_rat_enum_rec i (@sterm_list_cons (@smt_ratPair 1 1) @sterm_list_nil)))

;(program $eo_rat_to_num ((n $smt_Numeral) (d $smt_Numeral))
;  :signature ($smt_Numeral) $smt_Rational
;  (
;  (($eo_rat_to_num (@smt_ratPair n d)) ($eo_qdiv n d))
;  )
;)

; Since $smtx_methods never get stuck, all finite types must be defined in
; $eo_enum_type.
(program $smtx_enum_type ((T $smt_Type) (i $smt_builtin_Int))
  :signature ($smt_Type $smt_builtin_Int) $smt_Term
  (
  ; enumeration of standard SMT types
  ;(($smtx_enum_type $smt_builtin_Int i) (eo::define ((v ($smt_builtin_div i 2)))
  ;                                        ($smt_apply_3 "ite" ($smt_apply_= ($smt_builtin_mod i 2) 0)
  ;                                          v
  ;                                          ($smt_builtin_- v))))
  ;(($smtx_enum_type $smt_String i)      ($smt_apply_3 "ite" ($smt_apply_= i 0)
  ;                                      ""
  ;                                      (eo::concat (eo::to_str (eo::zmod i 196608)) ($smtx_enum_type $smt_String (eo::zdiv i 196608)))))
  ; rationals are treated as Real, meaning we interleave rational/irrational.
  ;(($smtx_enum_type $smt_Rational i)    (eo::define ((ir (eo::zdiv i 2)))
  ;                                    (eo::define ((isRat ($smt_apply_= (eo::zmod ir 2) 0)))
  ;                                    (eo::define ((i (eo::zdiv ir 2)))
  ;                                    (eo::define ((v ($smt_apply_3 "ite" isRat ($smtx_rat_to_num ($smt_rat_enum i)) ($smt_irrat_enum i))))
  ;                                      ($smt_apply_3 "ite" ($smt_apply_= (eo::zmod i 2) 0) v (eo::neg v)))))))

  ; TODO: functions, datatypes
  ; Try to enumerate the type, if we fail, we return an Uninterpreted sort value.
  ; Note that this essentially assumes that unhandled types are uninterpreted
  ; and have infinite cardinality (since this does not get stuck).
  ; (($smtx_enum_type T i)               ($vsm_UValue T i))
  ; FIXME!!!
  (($smtx_enum_type T i) T)
  )
)
(program $smtx_enum_type_final ((T $smt_Type) (i $smt_builtin_Int))
  :signature ($smt_Type $smt_builtin_Int) $smt_Value
  (
  ; TODO
  (($smtx_enum_type_final T i)               ($vsm_uconst T i))
  )
)


; program: $smtx_eval_quant
; specification for exists is a (non-computable) function
; The last argument is whether we are check exists (resp. forall).
(program $smtx_eval_quant
  ((T Type) (x T) (xs @STermList) (F $smt_Term) (i $smt_builtin_Int) (isExists $smt_builtin_Bool))
  :signature (@STermList $smt_Term $smt_builtin_Int $smt_builtin_Bool) $smt_builtin_Bool
  (
  (($smtx_eval_quant @STermList_nil F i isExists)
    ; base case: we have processed all variables, recurse, negate if isExists is false.
    ($smt_apply_= ($smtx_model_eval F) isExists))  ; we are now fully instantiated, look at the body
  (($smtx_eval_quant (@STermList_cons x xs) F i isExists)
    ; get the next value in the type enumeration
    (eo::define ((next ($smtx_enum_type ($smtx_typeof x) i)))
    ; if it exists
    ($smt_apply_3 "ite" ($eo_is_ok next)
      ; evaluate the body for this value. if this is a forcing value, return it
      ($smt_apply_3 "ite" ($smt_apply_= ($smtx_model_eval ($smtx_substitute x next F)) isExists)
        isExists
        ; otherwise recurse for the next value in the type enumeration for the current variable
        ($smtx_eval_quant (@STermList_cons x xs) F ($smt_apply_1 "+ 1" i) isExists))
      ($smt_apply_1 "not" isExists)))) ; out of values.
  )
)
