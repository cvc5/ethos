; This file defines a deep embedding of SMT-LIB into Eunoia.
; It is used for two purposes:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin Eunoia functions, e.g. eo::add.
; 2. It is used as a tool for defining the model semantics of SMT-LIB.


; All of the functions in this file will be handled by smt_meta.

;;; declarations to define literal types

(define $smt_Numeral () $eo_Numeral)
(define $smt_Rational () $eo_Rational)
(define $smt_String () $eo_String)

;;; TEMPORARY to make this file self contained
;(declare-const $smt_Numeral Type)
;(declare-const $smt_Rational Type)
;(declare-const $smt_String Type)
;(declare-const $smd_eo.Stuck Type)
;;; TEMPORARY

(declare-const $smt_unknown_type Type)

; Bit-vectors
; NOTE: we currently define $smt_BitVec
;(declare-parameterized-const $smt_BitVec ((n $smt_Numeral :opaque)) Type)
; $smt_Binary remains undefined
(define $smt_Binary () $smt_unknown_type)

; note: decimal and hexadecimal omitted for now.

; A Eunoia term
(declare-const $eo_Term Type)

; An SMT-LIB term.
(declare-const $smt_Term Type)

(declare-parameterized-const $smd_eo.SmtTerm ((t $smt_Term :opaque)) $eo_Term)
(declare-const $smd_eo.Stuck $eo_Term)
; Note the Bool type is "inlined" into the final signature
(declare-const $smd_sm.BoolType $smt_Term)
(declare-const $smd_sm.True $smt_Term)
(declare-const $smd_sm.False $smt_Term)
(declare-parameterized-const $smd_sm.Numeral ((n $eo_Numeral :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Rational ((r $eo_Rational :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.String ((s $eo_String :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Binary ((w $eo_Numeral :opaque) (v $eo_Numeral :opaque)) $smt_Term)

; Placeholders
(program eo.to_smt ((T Type)) :signature (T) $smt_Term)

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_apply_1
  ((W1 Type :implicit))
  (-> $smt_String W1 $smt_Term))
(declare-parameterized-const $smt_apply_2
  ((W1 Type :implicit) (W2 Type :implicit))
  (-> $smt_String W1 W2 $smt_Term))
(declare-parameterized-const $smt_apply_3
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit))
  (-> $smt_String W1 W2 W3 $smt_Term))
(declare-parameterized-const $smt_apply_4
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit))
  (-> $smt_String W1 W2 W3 W4 $smt_Term))
(declare-parameterized-const $smt_apply_5
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit))
  (-> $smt_String W1 W2 W3 W4 W5 $smt_Term))

; Convert from Eunoia to an SMT value
; These assume the Eunoia term is a literal of the correct type.
; All uses of the $smt_from_eo_* methods must ensure this is the case
; Convert Eunoia Boolean to an smt Boolean.
(declare-const $smt_from_eo_bool (-> Bool $smt_Term))
; Convert Eunoia Numeral to an smt Integer.
(declare-const $smt_from_eo_z (-> $smt_Numeral $smt_Term))
; Convert Eunoia Rational to an smt Real.
(declare-const $smt_from_eo_q (-> $smt_Rational $smt_Term))
; Convert Eunoia String to an smt String.
(declare-const $smt_from_eo_str (-> $smt_String $smt_Term))
; Convert Eunoia Binary to an smt-meta representation of Binary.
(declare-const $smt_from_eo_bin (-> $smt_Binary $smt_Term))
; Convert smt2 term to a Eunoia Boolean.
(declare-const $smt_to_eo_bool (-> $smt_Term Bool))
; Convert smt2 term to a Eunoia numeral.
(declare-const $smt_to_eo_z (-> $smt_Term $smt_Numeral))
; Convert smt2 term to a Eunoia rational.
(declare-const $smt_to_eo_q (-> $smt_Term $smt_Rational))
; Convert smt2 term to a Eunoia string.
(declare-const $smt_to_eo_str (-> $smt_Term $smt_String))
; Convert smt2 term to a Eunoia binary.
(declare-const $smt_to_eo_bin (-> $smt_Term $smt_Binary))

; Testers that use lower level sm.Term datatype, both for simplicity and efficiency.
; These rely on "is sm.Numeral" referring to the SMT-LIB operator (_ is sm.Numeral)
; in the final encoding.
; Boolean relies on the $sm_is_Boolean define-fun in the SMT meta signature.
(define $smt_is_bool ((T Type :implicit) (t T))
  ($smt_apply_2 "or"
    ; treat "= sm.True" as a unary function, ditto for "= sm.False"
    ($smt_apply_1 "= sm.True" (eo.to_smt t))
    ($smt_apply_1 "= sm.False" (eo.to_smt t))))
(define $smt_get_bool ((T Type :implicit) (t T))
  ($smt_apply_1 "= sm.True" (eo.to_smt t)))
(define $smt_is_z ((T Type :implicit) (t T))
  ($smt_apply_2 "and"
    ($smt_apply_1 "is eo.SmtTerm" t)
    ($smt_apply_1 "is sm.Numeral" (eo.to_smt t))))
(define $smt_is_q ((T Type :implicit) (t T))
  ($smt_apply_2 "and"
    ($smt_apply_1 "is eo.SmtTerm" t)
    ($smt_apply_1 "is sm.Rational" (eo.to_smt t))))
(define $smt_is_str ((T Type :implicit) (t T))
  ($smt_apply_2 "and"
    ($smt_apply_1 "is eo.SmtTerm" t)
    ($smt_apply_1 "is sm.String" (eo.to_smt t))))
(define $smt_is_bin ((T Type :implicit) (t T))
  ($smt_apply_2 "and"
    ($smt_apply_1 "is eo.SmtTerm" t)
    ($smt_apply_1 "is sm.Binary" (eo.to_smt t))))
; decomposing binaries
(define $smt_bin_width ((T Type :implicit) (t T)) ($smt_apply_1 "sm.Binary.width" (eo.to_smt t)))
(define $smt_bin_val ((T Type :implicit) (t T)) ($smt_apply_1 "sm.Binary.val" (eo.to_smt t)))
;
(define $smt_eo_is_bool ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_bool t)))
(define $smt_eo_is_z ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_z t)))
(define $smt_eo_is_q ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_q t)))
(define $smt_eo_is_str ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_str t)))
(define $smt_eo_is_bin ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_bin t)))

;;;

; Defining parametric bitvector operators

; This operator computes the Eunoia representation of an SMT-LIB literal.
; TODO: does this actually need to be defined here???
(program $sm_mk_pow2 ((i $smt_Numeral))
  :signature ($smt_Numeral) $smt_Numeral
  (
  (($sm_mk_pow2 i) ($smt_apply_3 "ite"
                     ($smt_apply_2 "<=" i 0)
                      1
                      ($smt_apply_2 "*" 2 ($sm_mk_pow2 ($smt_apply_2 "-" i 1)))))
  )
)

(program $sm_mk_binary_and ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_mk_binary_or ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_mk_binary_xor ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_mk_binary_not ()
  :signature ($smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_mk_binary_concat ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_mk_binary_extract ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)

;;; Utilities

; TODO: do these need to be defined??
(program $eo_mk_bool ((x Bool))
  :signature (Bool) $eo_Term
  (
  (($eo_mk_bool x) ($smd_eo.SmtTerm ($smt_apply_3 "ite" x $smd_sm.True $smd_sm.False)))
  )
)
(program $eo_mk_numeral ((x $smt_Numeral))
  :signature ($smt_Numeral) $eo_Term
  (
  (($eo_mk_numeral x) ($smd_eo.SmtTerm ($smd_sm.Numeral x)))
  )
)
(program $eo_mk_rational ((x $smt_Rational))
  :signature ($smt_Rational) $eo_Term
  (
  (($eo_mk_rational x) ($smd_eo.SmtTerm ($smd_sm.Rational x)))
  )
)
(program $eo_mk_string ((x $smt_String))
  :signature ($smt_String) $eo_Term
  (
  (($eo_mk_string x) ($smd_eo.SmtTerm ($smd_sm.String x)))
  )
)
(program $eo_mk_binary ((w $eo_Numeral) (n $eo_Numeral))
  :signature ($eo_Numeral $eo_Numeral) $eo_Term
  (
  (($eo_mk_binary w n) (eo::requires
                         ($smt_apply_2 "and"
                           ($smt_apply_2 "<=" ($eo_mk_numeral 0) w)
                           ($smt_apply_2 "<=" w ($eo_mk_numeral 4294967296)))
                         true
                         ($smd_eo.SmtTerm ($smd_sm.Binary w
                           ($smt_apply_2 "mod" n ($sm_mk_pow2 w))))))
  )
)
;;; Utilities

; Apply SMT-LIB operator Boolean connective "op" to Eunoia terms x1 and x2.
; Return the Eunoia term.
(define $sm_eo_apply_bool_op_2 ((op $smt_String) (x1 Bool) (x2 Bool))
  ($smt_to_eo_bool ($smt_apply_2 op
    ($smt_from_eo_bool x1)
    ($smt_from_eo_bool x2))))

; An SMT-LIB formula corresponding to Eunoia terms being an integer division operation.
; Return the SMT-LIB Boolean.
(define $smt_eo_is_z_div_op ((x1 $smt_Numeral) (x2 $smt_Numeral))
  ($smt_apply_3 "and"
    ($smt_is_z x1)
    ($smt_is_z x2)
    ($smt_apply_1 "not" ($smt_apply_2 "=" x2 ($smt_apply_1 "eo.SmtTerm" 0)))))

; An SMT-LIB formula corresponding to Eunoia terms being a real division operation.
; Return the SMT-LIB Boolean.
(define $smt_eo_is_q_div_op ((x1 $smt_Rational) (x2 $smt_Rational))
  ($smt_apply_3 "and"
    ($smt_is_q x1)
    ($smt_is_q x2)
    ($smt_apply_1 "not" ($smt_apply_2 "=" x2 ($smt_apply_1 "eo.SmtTerm" 0/1)))))

; An SMT-LIB formula corresponding to Eunoia terms being the binaries of the same width.
; Return the SMT-LIB Boolean.
(define $smt_eo_is_bin_same_width ((x1 $smt_Binary) (x2 $smt_Binary))
  ($smt_apply_3 "and"
    ($smt_is_bin x1)
    ($smt_is_bin x2)
    ($smt_apply_2 "=" ($smt_bin_width x1) ($smt_bin_width x2))))

; Apply SMT-LIB operator (-> Int Int Int) "op" to Eunoia terms x1 and x2.
; Return the Eunoia term.
(define $sm_eo_apply_z_op_2 ((op $smt_String) (x1 Bool) (x2 Bool))
  ($smt_to_eo_z ($smt_apply_2 op
    ($smt_from_eo_z x1)
    ($smt_from_eo_z x2))))

; Apply SMT-LIB operator (-> Real Real Real) "op" to Eunoia terms x1 and x2.
; Return the Eunoia term.
(define $sm_eo_apply_q_op_2 ((op $smt_String) (x1 Bool) (x2 Bool))
  ($smt_to_eo_q ($smt_apply_2 op
    ($smt_from_eo_q x1)
    ($smt_from_eo_q x2))))

(define $smt_try_eval_o_arith_unary
  ((W1 Type :implicit) (U Type :implicit) (op $smt_String) (x1 W1) (u U))
  ($smt_apply_3 "ite" ($smt_is_z x1)
    ($smt_to_eo_z ($smt_apply_1 op ($smt_from_eo_z x1)))
  ($smt_apply_3 "ite" ($smt_is_q x1)
    ($smt_to_eo_q ($smt_apply_1 op ($smt_from_eo_q x1)))
    u)))

(define $smt_try_eval_o_arith
  ((W1 Type :implicit) (W2 Type :implicit) (U Type :implicit) (op $smt_String) (x1 W1) (x2 W2) (u U))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_z x1) ($smt_is_z x2))
    ($sm_eo_apply_z_op_2 op x1 x2)
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_q x1) ($smt_is_q x2))
    ($sm_eo_apply_q_op_2 op x1 x2)
    u)))

(define $smt_try_eval_o_arith_pred
  ((W1 Type :implicit) (W2 Type :implicit) (U Type :implicit) (op $smt_String) (x1 W1) (x2 W2) (u U))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_z x1) ($smt_is_z x2))
    ($smt_to_eo_bool ($smt_apply_2 op ($smt_from_eo_z x1) ($smt_from_eo_z x2)))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_q x1) ($smt_is_q x2))
    ($smt_to_eo_bool ($smt_apply_2 op ($smt_from_eo_q x1) ($smt_from_eo_q x2)))
    u)))

; optimized check for if a term is Boolean?
(define $eo_check_bool ((x $eo_Term))
  ($smt_apply_2 "or" ($smt_apply_1 "= sm.True" x) ($smt_apply_1 "= sm.False" x)))

; We are now ready to define the builtins of Eunoia

;;; Boolean operators

; axiom: $eo_not
(program $eo_not ((w $eo_Numeral) (n $eo_Numeral))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_not ($smd_eo.SmtTerm $smd_sm.True))         ($smd_eo.SmtTerm $smd_sm.False))
  (($eo_not ($smd_eo.SmtTerm $smd_sm.False))        ($smd_eo.SmtTerm $smd_sm.True))
  (($eo_not ($smd_eo.SmtTerm ($smd_sm.Binary w n))) ($eo_mk_binary ($sm_mk_binary_not w n) w))
  )
)
;(define $eo_not ((T Type :implicit) (x1 T))
;  ($smt_apply_3 "ite" ($smt_is_bool x1)
;    ($smt_to_eo_bool ($smt_apply_1 "not" ($smt_from_eo_bool x1)))
;  ($smt_apply_3 "ite" ($smt_is_bin x1)
;    (eo::define ((w ($smt_bin_width x1)))
;      ($eo_mk_binary ($sm_mk_binary_not w ($smt_bin_val x1)) w))
;    $smd_eo.Stuck)))

; axiom: $eo_and
(program $eo_and ((b1 $eo_Term) (b2 $eo_Term) (w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_and ($smd_eo.SmtTerm ($smd_sm.Binary w n1)) ($smd_eo.SmtTerm ($smd_sm.Binary w n2)))
     ($eo_mk_binary ($sm_mk_binary_and w n1 n2) w))
  (($eo_and b1 b2)
     ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_bool b1) ($smt_is_bool b2))
       ($eo_mk_bool ($smt_apply_2 "and" ($smt_get_bool b1) ($smt_get_bool b2)))
       $smd_eo.Stuck))
  )
)

; axiom: $eo_or
(program $eo_or ((b1 $eo_Term) (b2 $eo_Term) (w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_or ($smd_eo.SmtTerm ($smd_sm.Binary w n1)) ($smd_eo.SmtTerm ($smd_sm.Binary w n2)))
     ($eo_mk_binary ($sm_mk_binary_or w n1 n2) w))
  (($eo_or b1 b2)
     (eo::ite ($smt_apply_2 "and" ($smt_is_bool b1) ($smt_is_bool b2))
       ($eo_mk_bool ($smt_apply_2 "or" ($smt_get_bool b1) ($smt_get_bool b2)))
       $smd_eo.Stuck))
  )
)

; axiom: $eo_xor
(program $eo_xor ((b1 $eo_Term) (b2 $eo_Term) (w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_xor ($smd_eo.SmtTerm ($smd_sm.Binary w n1)) ($smd_eo.SmtTerm ($smd_sm.Binary w n2)))
     ($eo_mk_binary ($sm_mk_binary_or w n1 n2) w))
  (($eo_xor b1 b2)
     (eo::ite ($smt_apply_2 "and" ($smt_is_bool b1) ($smt_is_bool b2))
       ($eo_mk_bool ($smt_apply_2 "xor" ($smt_get_bool b1) ($smt_get_bool b2)))
       $smd_eo.Stuck))
  )
)


;;; Arithmetic operators

; axiom: $eo_add
(define $eo_add ((T Type :implicit) (x1 T) (x2 T))
  ; first try (overloaded) arithmetic
  ($smt_try_eval_o_arith "+" x1 x2
  ; if that fails, try binary
  ($smt_apply_3 "ite" ($smt_eo_is_bin_same_width x1 x2)
    ($eo_mk_binary ($smt_apply_2 "+" ($smt_bin_val x1) ($smt_bin_val x2)) ($smt_bin_width x1))
    $smd_eo.Stuck)))

; axiom: $eo_mul
(define $eo_mul ((T Type :implicit) (x1 T) (x2 T))
  ; first try (overloaded) arithmetic
  ($smt_try_eval_o_arith "*" x1 x2
  ; if that fails, try binary
  ($smt_apply_3 "ite" ($smt_eo_is_bin_same_width x1 x2)
    ($eo_mk_binary ($smt_apply_2 "*" ($smt_bin_val x1) ($smt_bin_val x2)) ($smt_bin_width x1))
    $smd_eo.Stuck)))

; axiom: $eo_qdiv
(define $eo_qdiv ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_eo_is_z_div_op x1 x2)
    ($smt_to_eo_q ($smt_apply_2 "/" ($smt_apply_1 "to_real" ($smt_from_eo_z x1)) ($smt_apply_1 "to_real" ($smt_from_eo_z x2))))
  ($smt_apply_3 "ite" ($smt_eo_is_q_div_op x1 x2)
    ($sm_eo_apply_q_op_2 "/" x1 x2)
    $smd_eo.Stuck)))

; axiom: $eo_zdiv
(define $eo_zdiv ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_eo_is_z_div_op x1 x2)
    ($sm_eo_apply_z_op_2 "div" x1 x2)
  ($smt_apply_3 "ite" ($smt_eo_is_bin_same_width x1 x2)
    ($eo_mk_binary ($smt_apply_2 "div" ($smt_bin_val x1) ($smt_bin_val x2)) ($smt_bin_width x1))
    $smd_eo.Stuck)))

; axiom: $eo_zmod
(define $eo_zmod ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_eo_is_z_div_op x1 x2)
    ($sm_eo_apply_z_op_2 "mod" x1 x2)
  ($smt_apply_3 "ite" ($smt_eo_is_bin_same_width x1 x2)
    ($eo_mk_binary ($smt_apply_2 "mod" ($smt_bin_val x1) ($smt_bin_val x2)) ($smt_bin_width x1))
    $smd_eo.Stuck)))

; axiom: $eo_is_neg
(define $eo_is_neg ((T Type :implicit) (x1 T))
  ($smt_apply_3 "ite" ($smt_is_z x1)
    ($smt_to_eo_bool ($smt_apply_2 "<" ($smt_from_eo_z x1) ($smt_from_eo_z ($eo_mk_numeral 0))))
  ($smt_apply_3 "ite" ($smt_is_q x1)
    ($smt_to_eo_bool ($smt_apply_2 "<" ($smt_from_eo_q x1) ($smt_from_eo_q ($eo_mk_rational 0/1))))
    $smd_eo.Stuck)))

; axiom: $eo_neg
(define $eo_neg ((T Type :implicit) (x1 T))
  ($smt_try_eval_o_arith_unary "-" x1 $smd_eo.Stuck))

;;; String operators

; axiom: $eo_len
(define $eo_len ((T Type :implicit) (x1 T))
  ($smt_apply_3 "ite" ($smt_is_bin x1)
    ($smt_to_eo_z ($smt_bin_width x1))
  ($smt_apply_3 "ite" ($smt_is_str x1)
    ($smt_to_eo_z ($smt_apply_1 "str.len" ($smt_from_eo_str x1)))
    $smd_eo.Stuck)))

; axiom: $eo_concat
(define $eo_concat ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_str x1) ($smt_is_str x2))
    ($smt_to_eo_str ($smt_apply_2 "str.++" ($smt_from_eo_str x1) ($smt_from_eo_str x2)))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_bin x1) ($smt_is_bin x2))
    (eo::define ((w1 ($smt_bin_width x1)))
    (eo::define ((w2 ($smt_bin_width x2)))
      ($eo_mk_binary
        ($sm_mk_binary_concat w1 ($smt_bin_val x1) w2 ($smt_bin_val x2))
        ($smt_apply_2 "+" w1 w2))))
    $smd_eo.Stuck)))

; axiom: $eo_extract
(define $eo_extract ((T Type :implicit) (x1 T) (x2 $smt_Numeral) (x3 $smt_Numeral))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_z x2) ($smt_is_z x3))
    ($smt_apply_3 "ite" ($smt_is_str x1)
      (eo::define ((n2 ($smt_from_eo_z x2)))
      (eo::define ((n3 ($smt_from_eo_z x3)))
      ($smt_to_eo_str ($smt_apply_3 "str.substr" ($smt_from_eo_str x1) n2 ($smt_apply_2 "+" ($smt_apply_2 "-" n3 n2) 1)))))
    ($smt_apply_3 "ite" ($smt_is_bin x1)
      ($sm_mk_binary_extract ($smt_bin_width x1) ($smt_bin_val x1) ($smt_bin_val x2) ($smt_bin_val x3))
      $smd_eo.Stuck))
    $smd_eo.Stuck))

; axiom: $eo_find
(define $eo_find ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_str x1) ($smt_is_str x2))
    ($smt_to_eo_z ($smt_apply_3 "str.indexof" ($smt_from_eo_str x1) ($smt_from_eo_str x2) ($smt_from_eo_z ($smt_apply_1 "eo.SmtTerm" 0))))
    $smd_eo.Stuck))

;;; Conversion operators

; axiom: $eo_to_z
(define $eo_to_z ((T Type :implicit) (x1 T))
  ($smt_apply_3 "ite" ($smt_is_z x1)
    x1
  ($smt_apply_3 "ite" ($smt_is_q x1)
    ($smt_to_eo_z ($smt_apply_2 "to_int" ($smt_from_eo_q x1)))
  ($smt_apply_3 "ite" ($smt_is_bin x1)
    ($smt_to_eo_z ($smt_bin_val x1))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_str x1) ($smt_apply_2 "=" ($smt_apply_1 "str.len" ($smt_from_eo_str x1)) ($smt_from_eo_z ($smt_apply_1 "eo.SmtTerm" 1))))
    ($smt_to_eo_z ($smt_apply_1 "str.to_code" ($smt_from_eo_str x1)))
    $smd_eo.Stuck)))))

; axiom: $eo_to_q
(define $eo_to_q ((T Type :implicit) (x1 T))
  ($smt_apply_3 "ite" ($smt_is_z x1)
    ($smt_to_eo_q ($smt_apply_1 "to_real" ($smt_from_eo_z x1)))
  ($smt_apply_3 "ite" ($smt_is_q x1)
    x1
    $smd_eo.Stuck)))

; axiom: $eo_to_bin
(define $eo_to_bin ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_z x1) ($smt_is_z x2))
    ($eo_mk_binary ($smt_from_eo_z x1) ($smt_from_eo_z x2))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_z x1) ($smt_is_z x2))
    ($eo_mk_binary ($smt_from_eo_z x1) ($smt_bin_val x2))
    $smd_eo.Stuck)))

; axiom: $eo_to_str
(define $eo_to_str ((T Type :implicit) (x1 T))
  ($smt_apply_3 "ite" ($smt_is_z x1)
    ($smt_to_eo_str ($smt_apply_1 "str.from_code" ($smt_from_eo_z x1)))
  ($smt_apply_3 "ite" ($smt_is_str x1)
    x1
  ; TODO?
    $smd_eo.Stuck)))
