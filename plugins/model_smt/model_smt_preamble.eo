; This file defines a deep embedding of SMT-LIB into Eunoia.
; It is used for two purposes:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin Eunoia functions, e.g. $eo_add.
; 2. It is used to define the end signature for defining the model semantics of SMT-LIB.

; All of the functions in this file will be handled by smt_meta.

;;; declarations to define literal types

; TODO: remove this and use $smt_Term instead???
; The type of $smt_apply_* terms
(declare-const $smt_unknown_type Type)

; The operator of $smt_apply_* terms
(define $smt_id () $eo_String)

; note: decimal and hexadecimal omitted for now.

;;; Deep embedding of SMT-LIB operator applications into Eunoia

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_type_0
  ((op $smt_id :opaque))
  Type)
(declare-parameterized-const $smt_type_1
  ((W1 Type :implicit) (op $smt_id :opaque) (x1 W1 :opaque))
  Type)
(declare-parameterized-const $smt_apply_0
  ((op $smt_id :opaque))
  $smt_unknown_type)
(declare-parameterized-const $smt_apply_1
  ((W1 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque)) $smt_unknown_type)
(declare-parameterized-const $smt_apply_2
  ((W1 Type :implicit) (W2 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque)) $smt_unknown_type)
(declare-parameterized-const $smt_apply_3
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque)) $smt_unknown_type)
(declare-parameterized-const $smt_apply_4
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque)) $smt_unknown_type)
(declare-parameterized-const $smt_apply_5
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque) (x5 W5 :opaque)) $smt_unknown_type)

; builtin types, which print as e.g. "sm.Int".
(declare-parameterized-const $smt_builtin_type_0
  ((op $smt_id :opaque))
  Type)
; NOTE: the fact that x1 is not opaque indicates that
; bitvectors print as (_ BitVec w) not (BitVec w).
(declare-parameterized-const $smt_builtin_type_1
  ((W1 Type :implicit) (op $smt_id :opaque) (x1 W1))
  Type)

(define $smt_builtin_Bool () ($smt_type_0 "Bool"))
(define $smt_builtin_Int () ($smt_type_0 "Int"))
(define $smt_builtin_Real () ($smt_type_0 "Real"))
(define $smt_builtin_String () ($smt_type_0 "String"))
(define $smt_builtin_true () ($smt_apply_0 "true"))
(define $smt_builtin_false () ($smt_apply_0 "false"))
(define $smt_builtin_= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "=" x1 x2))
(define $smt_builtin_ite ((W Type :implicit) (b $smt_builtin_Bool) (x1 W) (x2 W)) ($smt_apply_3 "ite" b x1 x2))
(define $smt_builtin_z_zero () ($smt_apply_0 "0"))
(define $smt_builtin_+ ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "+" x1 x2))
(define $smt_builtin_- ((W Type :implicit) (x1 W)) ($smt_apply_1 "-" x1))
(define $smt_builtin_div ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "div" x1 x2))
(define $smt_builtin_mod ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "mod" x1 x2))
(define $smt_builtin_not ((b $smt_builtin_Bool)) ($smt_apply_1 "not" b))
(define $smt_builtin_and ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "and" b1 b2))
(define $smt_builtin_or ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "or" b1 b2))

; TODO: =, ite

; In this signature, we heavily use references to the Datatypes corresponding
; to the final deep embeddings of Eunoia terms (eo.Term) and SMT-LIB terms
; (sm.Term), where the latter is a subfield type of the former.
; Opaque arguments of a symbol X will be an argument of the constructor eo.X
; (respectively sm.X). Symbols with no

; We introduce datatype constructors for these datatypes ($smd_eo.X and $smd_sm.X)
; respectively. It is important that we mark their arguments as :opaque, as this
; correctly models the pattern matching in the smt-meta later.

; Note that these datatypes will be renamed and replaced by their definitions
; which is hardcoded into smt_meta.smt2.
; We could also have these auto-generated, but leads to complications when it
; comes to printing the argument types, as e.g. the argument to sm.Numeral is
; an SMT-LIB numeral, not a symbolic SMT term.

;;;;;;;;;;;;;;;; datatype begin

;;; Deep embedding of SMT-LIB terms

; TODO: move up to own signature

; An SMT-LIB term.
; This will be replaced by the datatype sm.Term in the final encoding.
(declare-const $smt_Term Type)

; An SMT-LIB type.
; This will be replaced by the datatype tsm.Type in the final encoding.
(declare-const $smt_Type Type)

; An SMT-LIB value.
; This will be replaced by the datatype vsm.Value in the final encoding.
(declare-const $smt_Value Type)

; Note the Bool type is "inlined" into the final signature
(declare-const $smd_sm.True $smt_Term)
(declare-const $smd_sm.False $smt_Term)
(declare-parameterized-const $smd_sm.Numeral ((n $smt_builtin_Int :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Rational ((r $smt_builtin_Real :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.String ((s ($smt_type_0 "String") :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Binary ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $smt_Term)

; A skolem, identified by kind, identifier and Type.
; The kind 0 is reserved for standard SMT-LIB symbols introduced
; by the user by declare-const. The other kinds of free symbols
; can be custom defined based on the Eunoia signature (see method
; $eo_const_predicate in model_eo.eo).
(declare-parameterized-const $smd_sm.Skolem
  ((k $smt_builtin_Int :opaque) (id $smt_builtin_Int :opaque) (T $smt_Type :opaque))
  $smt_Term)
(define $sm_Const
  ((k $smt_builtin_Int :opaque) (id $smt_builtin_Int :opaque) (T $smt_Type :opaque))
  ($smd_sm.Skolem k id T))

; A free constant
(declare-parameterized-const $smd_sm.Const
  ((id $smt_builtin_Int :opaque) (T $smt_Type :opaque))
  $smt_Term)
(define $sm_Const
  ((id $smt_builtin_Int :opaque) (T $smt_Type :opaque))
  ($smd_sm.Const id T))

; represents an uninterpreted value
; This must be a constructor in the final sm.Term.
(declare-parameterized-const $smd_sm.usort_value
  ((T $smt_Type :opaque) (i $smt_builtin_Int :opaque)) $smt_Term)
(define $sm_usort_value
  ((id $smt_builtin_Int :opaque) (T $smt_Type :opaque))
  ($smd_sm.usort_value id T))

; The Eunoia representation of an SMT-LIB term.
(declare-parameterized-const $smd_sm.Apply
  ((t1 $smt_Term :opaque) (t2 $smt_Term :opaque)) $smt_Term)
(define $sm_apply_term ((t1 $smt_Term) (t2 $smt_Term))
  ($smd_sm.Apply t1 t2))

;;; Deep embedding of SMT-LIB types

; The Boolean type
(declare-const $smd_tsm.BoolType $smt_Type)
(define $smt_BoolType () $smd_tsm.BoolType)

; Function types
(declare-parameterized-const $smd_tsm.FunType
  ((T1 $smt_Type :opaque) (T2 $smt_Type :opaque)) $smt_Type)
(define $smt_fun_type ((T1 $smt_Type) (T2 $smt_Type))
  ($smd_tsm.FunType T1 T2))

; Uninterpreted sorts
(declare-parameterized-const $smd_tsm.USort
  ((id $smt_builtin_Int :opaque)) $smt_Type)
(define $smt_USort ((id $smt_builtin_Int)) ($smd_tsm.USort id))

; The sort of a term that doesn't have an SMT-LIB type.
; This is used as an error condition
(declare-parameterized-const $smd_tsm.NullSort
  ((id $smt_builtin_Int :opaque)) $smt_Type)
(define $smt_NullSort ((id $smt_builtin_Int)) ($smd_tsm.NullSort id))

;;; Deep embedding of Eunoia terms

; $eo_Term is declared in eo_desugar.eo

; The Eunoia representation of an SMT-LIB term.
(declare-parameterized-const $smd_eo.SmtTerm ((t $smt_Term :opaque)) $eo_Term)
(define $eo_smt_term ((t $smt_Term)) ($smd_eo.SmtTerm t))

; The Eunoia representation of an SMT-LIB type.
(declare-parameterized-const $smd_eo.SmtType ((t $smt_Type :opaque)) $eo_Term)
(define $eo_smt_type ((T $smt_Type)) ($smd_eo.SmtType T))

; The Eunoia representation of an SMT-LIB value.
(declare-parameterized-const $smd_eo.SmtValue ((t $smt_Type :opaque)) $eo_Term)
(define $eo_smt_value ((T $smt_Type)) ($smd_eo.SmtValue T))

; The Eunoia representation of "stuckness".
(declare-const $smd_eo.Stuck $eo_Term)
(define $eo_mk_stuck () $smd_eo.Stuck)

;;;;;;;;;;;;;;;; datatype end

;;; External datatype access
  
(define $sm_mk_true () $smd_sm.True)
(define $sm_mk_false () $smd_sm.False)
(define $sm_mk_bool ((c $smt_builtin_Bool))
  ($smt_apply_3 "ite" c $sm_mk_true $sm_mk_false))
(define $sm_mk_z ((n $smt_builtin_Int))
  ($smt_apply_1 "sm.Numeral" n))
(define $sm_mk_q ((r $smt_builtin_Real))
  ($smt_apply_1 "sm.Rational" r))
(define $sm_mk_str ((s $smt_builtin_String))
  ($smt_apply_1 "sm.String" s))

;(define $smt_Int () ($smt_builtin_type_0 "Int"))
;(define $smt_Real () ($smt_builtin_type_0 "Real"))
;(define $smt_BitVec ((w $smt_builtin_Int)) (_ ($smt_builtin_type_1 "BitVec") w))
;(define $smt_String () ($smt_builtin_type_0 "String"))

; NOTE: we compile to equality directly, although we could use (_ sm.True) here.
(define $sm_is_true ((b $smt_Term)) ($smt_apply_2 "=" b $sm_mk_true))
(define $sm_is_false ((b $smt_Term)) ($smt_apply_2 "=" b $sm_mk_false))
; Assumes that t is a Boolean term
(define $sm_is_bool ((T Type :implicit) (t T))
  ($smt_builtin_or ($sm_is_true t) ($sm_is_false t)))
(define $sm_is_z ((T Type :implicit) (t T))
  ($smt_apply_1 "(_ is sm.Numeral)" t))
(define $sm_is_q ((T Type :implicit) (t T))
  ($smt_apply_1 "(_ is sm.Rational)" t))
(define $sm_is_str ((T Type :implicit) (t T))
  ($smt_apply_1 "(_ is sm.String)" t))

;;; Defining parametric bitvector operators

; The operators in this section are needed to reason about the parametric
; operations on the Eunoia binary literal type.

(program $sm_mk_pow2 ((i $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($sm_mk_pow2 i)  ($smt_apply_3 "ite" ($smt_apply_2 "<=" i 0)
                      1
                      ($smt_apply_2 "*" 2 ($sm_mk_pow2 ($smt_apply_2 "-" i 1)))))
  )
)
(program $sm_mk_bit ((x $smt_builtin_Int) (i $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Bool
  (
  ; (= (mod (div x ($sm_mk_pow2 i)) 2) 1)
  (($sm_mk_bit x i) ($smt_apply_1 "= 1" ($smt_apply_2 "mod" ($smt_builtin_div x ($sm_mk_pow2 i)) 2)))
  )
)
(program $sm_mk_binary_and ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($sm_mk_binary_and w n1 n2)
     ($smt_apply_3 "ite" ($smt_apply_2 "=" w 0) 0
     ($smt_apply_3 "ite" ($smt_apply_2 "=" w 1)
       ($smt_apply_3 "ite" ($smt_builtin_and ($smt_apply_2 "=" n1 1) ($smt_apply_2 "=" n2 1)) 1 0)
       ($smt_apply_2 "+"
         ($sm_mk_binary_and ($smt_apply_2 "-" w 1) n1 n2)
         ($smt_apply_2 "*" ($sm_mk_pow2 w)
            ($smt_apply_3 "ite" ($smt_builtin_and ($sm_mk_bit n1 w) ($sm_mk_bit n2 w)) 1 0))))))
  )
)
(program $sm_mk_binary_or ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_xor ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_not ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_max ((w $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($sm_mk_binary_max w) ($smt_apply_1 "- 1" ($sm_mk_pow2 w)))
  )
)
(program $sm_mk_binary_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_extract
  ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)

;;; Utilities

(define $eo_true () ($eo_smt_term $sm_mk_true))
(define $eo_false () ($eo_smt_term $sm_mk_false))
(define $eo_mk_bool ((x $smt_builtin_Bool))
  ($eo_smt_term ($sm_mk_bool x)))
(define $eo_mk_numeral ((x $smt_builtin_Int))
  ($eo_smt_term ($smd_sm.Numeral x)))
(define $eo_mk_rational ((x $smt_builtin_Real))
  ($eo_smt_term ($smd_sm.Rational x)))
(define $eo_mk_string ((x $smt_builtin_String))
  ($eo_smt_term ($smd_sm.String x)))
(define $eo_binary ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  ($eo_smt_term ($smd_sm.Binary x1 x2)))
; different from above, this may get stuck
(program $eo_mk_binary ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $eo_Term
  (
  (($eo_mk_binary w n)
    ($smt_apply_3 "ite" ($smt_builtin_and ($smt_apply_1 "<= 0" w) ($smt_apply_1 ">= 4294967296" w))
      ($eo_binary w ($smt_apply_2 "mod" n ($sm_mk_pow2 w)))
      $eo_mk_stuck))
  )
)

