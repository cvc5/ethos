; This file defines a deep embedding of SMT-LIB into Eunoia.
; It is used for two purposes:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin Eunoia functions, e.g. eo::add.
; 2. It is used as a tool for defining the model semantics of SMT-LIB.


; All of the functions in this file will be handled by smt_meta.

;;; declarations to define literal types

(define $smt_Numeral () $eo_Numeral)
(define $smt_Rational () $eo_Rational)
(define $smt_String () $eo_String)

;;; TEMPORARY to make this file self contained
;(declare-const $smt_Numeral Type)
;(declare-const $smt_Rational Type)
;(declare-const $smt_String Type)
;(declare-const $smd_eo.Stuck Type)
;;; TEMPORARY

(declare-const $smt_unknown_type Type)

; Bit-vectors
; NOTE: we currently define $smt_BitVec
;(declare-parameterized-const $smt_BitVec ((n $smt_Numeral :opaque)) Type)
; $smt_Binary remains undefined
(define $smt_Binary () $smt_unknown_type)

; note: decimal and hexadecimal omitted for now.

; A Eunoia term
(declare-const $eo_Term Type)

; An SMT-LIB term.
(declare-const $smt_Term Type)

(declare-parameterized-const $smd_eo.SmtTerm ((t $smt_Term :opaque)) $eo_Term)
(declare-const $smd_eo.Stuck $eo_Term)
; Note the Bool type is "inlined" into the final signature
(declare-const $smd_sm.BoolType $smt_Term)
(declare-const $smd_sm.True $smt_Term)
(declare-const $smd_sm.False $smt_Term)
(declare-parameterized-const $smd_sm.Numeral ((n $eo_Numeral :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Rational ((r $eo_Rational :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.String ((s $eo_String :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Binary ((w $eo_Numeral :opaque) (v $eo_Numeral :opaque)) $smt_Term)

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_apply_1
  ((W1 Type :implicit))
  (-> $smt_String W1 $smt_Term))
(declare-parameterized-const $smt_apply_2
  ((W1 Type :implicit) (W2 Type :implicit))
  (-> $smt_String W1 W2 $smt_Term))
(declare-parameterized-const $smt_apply_3
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit))
  (-> $smt_String W1 W2 W3 $smt_Term))
(declare-parameterized-const $smt_apply_4
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit))
  (-> $smt_String W1 W2 W3 W4 $smt_Term))
(declare-parameterized-const $smt_apply_5
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit))
  (-> $smt_String W1 W2 W3 W4 W5 $smt_Term))

; Boolean relies on the $sm_is_Boolean define-fun in the SMT meta signature.
; This is an optimization to avoid Booleans in the final datatype.
(define $smt_is_bool ((T Type :implicit) (t T))
  ($smt_apply_2 "or"
    ; treat "= sm.True" as a unary function, ditto for "= sm.False"
    ($smt_apply_1 "= sm.True" ($smt_apply_1 "eo.to_smt" t))
    ($smt_apply_1 "= sm.False" ($smt_apply_1 "eo.to_smt" t))))
(define $smt_get_bool ((T Type :implicit) (t T))
  ($smt_apply_1 "= sm.True" ($smt_apply_1 "eo.to_smt" t)))

;;;

; Defining parametric bitvector operators

; This operator computes the Eunoia representation of an SMT-LIB literal.
; TODO: does this actually need to be defined here???
(program $sm_mk_pow2 ((i $smt_Numeral))
  :signature ($smt_Numeral) $smt_Numeral
  (
  (($sm_mk_pow2 i) ($smt_apply_3 "ite"
                     ($smt_apply_2 "<=" i 0)
                      1
                      ($smt_apply_2 "*" 2 ($sm_mk_pow2 ($smt_apply_2 "-" i 1)))))
  )
)

(program $sm_mk_binary_and ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_mk_binary_or ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_mk_binary_xor ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_mk_binary_not ()
  :signature ($smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_mk_binary_max ()
  :signature ($smt_Numeral) $smt_Numeral)
(program $sm_mk_binary_concat ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_mk_binary_extract ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)

;;; Utilities

; TODO: do these need to be defined??
(program $eo_mk_bool ((x Bool))
  :signature (Bool) $eo_Term
  (
  (($eo_mk_bool x) ($smd_eo.SmtTerm ($smt_apply_3 "ite" x $smd_sm.True $smd_sm.False)))
  )
)
(program $eo_mk_numeral ((x $smt_Numeral))
  :signature ($smt_Numeral) $eo_Term
  (
  (($eo_mk_numeral x) ($smd_eo.SmtTerm ($smd_sm.Numeral x)))
  )
)
(program $eo_mk_rational ((x $smt_Rational))
  :signature ($smt_Rational) $eo_Term
  (
  (($eo_mk_rational x) ($smd_eo.SmtTerm ($smd_sm.Rational x)))
  )
)
(program $eo_mk_string ((x $smt_String))
  :signature ($smt_String) $eo_Term
  (
  (($eo_mk_string x) ($smd_eo.SmtTerm ($smd_sm.String x)))
  )
)
(program $eo_mk_binary ((w $eo_Numeral) (n $eo_Numeral))
  :signature ($eo_Numeral $eo_Numeral) $eo_Term
  (
  (($eo_mk_binary w n) (eo::requires
                         ($smt_apply_2 "and"
                           ($smt_apply_2 "<=" ($eo_mk_numeral 0) w)
                           ($smt_apply_2 "<=" w ($eo_mk_numeral 4294967296)))
                         true
                         ($smd_eo.SmtTerm ($smd_sm.Binary w
                           ($smt_apply_2 "mod" n ($sm_mk_pow2 w))))))
  )
)
; Convert Eunoia Boolean to an smt Boolean.
(program $smt_from_eo_bool () :signature (Bool) $smt_Term)
; Convert Eunoia Numeral to an smt Integer.
(program $smt_from_eo_z () :signature ($smt_Numeral) $smt_Term)
; Convert Eunoia Rational to an smt Real.
(program $smt_from_eo_q () :signature ($smt_Rational) $smt_Term)
; Convert Eunoia String to an smt String.
(program $smt_from_eo_str () :signature ($smt_String) $smt_Term)


;;; Utilities

; We are now ready to define the builtins of Eunoia

;;; Boolean operators

; axiom: $eo_not
(program $eo_not ((w $eo_Numeral) (n $eo_Numeral))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_not ($smd_eo.SmtTerm $smd_sm.True))         ($smd_eo.SmtTerm $smd_sm.False))
  (($eo_not ($smd_eo.SmtTerm $smd_sm.False))        ($smd_eo.SmtTerm $smd_sm.True))
  (($eo_not ($smd_eo.SmtTerm ($smd_sm.Binary w n))) ($eo_mk_binary w ($sm_mk_binary_not w n)))
  )
)

; axiom: $eo_and
(program $eo_and ((b1 $eo_Term) (b2 $eo_Term) (w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_and ($smd_eo.SmtTerm ($smd_sm.Binary w n1)) ($smd_eo.SmtTerm ($smd_sm.Binary w n2)))
     ($eo_mk_binary w ($sm_mk_binary_and w n1 n2)))
  (($eo_and b1 b2)
     ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_bool b1) ($smt_is_bool b2))
       ($eo_mk_bool ($smt_apply_2 "and" ($smt_get_bool b1) ($smt_get_bool b2)))
       $smd_eo.Stuck))
  )
)

; axiom: $eo_or
(program $eo_or ((b1 $eo_Term) (b2 $eo_Term) (w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_or ($smd_eo.SmtTerm ($smd_sm.Binary w n1)) ($smd_eo.SmtTerm ($smd_sm.Binary w n2)))
     ($eo_mk_binary w ($sm_mk_binary_or w n1 n2)))
  (($eo_or b1 b2)
     ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_bool b1) ($smt_is_bool b2))
       ($eo_mk_bool ($smt_apply_2 "or" ($smt_get_bool b1) ($smt_get_bool b2)))
       $smd_eo.Stuck))
  )
)

; axiom: $eo_xor
(program $eo_xor ((b1 $eo_Term) (b2 $eo_Term) (w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_xor ($smd_eo.SmtTerm ($smd_sm.Binary w n1)) ($smd_eo.SmtTerm ($smd_sm.Binary w n2)))
     ($eo_mk_binary w ($sm_mk_binary_or w n1 n2)))
  (($eo_xor b1 b2)
     ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_bool b1) ($smt_is_bool b2))
       ($eo_mk_bool ($smt_apply_2 "xor" ($smt_get_bool b1) ($smt_get_bool b2)))
       $smd_eo.Stuck))
  )
)


;;; Arithmetic operators

(program $eo_add ((w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral) (r1 $eo_Rational) (r2 $eo_Rational))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_add ($smd_eo.SmtTerm ($smd_sm.Numeral n1)) ($smd_eo.SmtTerm ($smd_sm.Numeral n2)))
    ($eo_mk_numeral ($smt_apply_2 "+" n1 n2)))
  (($eo_add ($smd_eo.SmtTerm ($smd_sm.Rational r1)) ($smd_eo.SmtTerm ($smd_sm.Rational r2)))
    ($eo_mk_rational ($smt_apply_2 "+" r1 r2)))
  (($eo_add ($smd_eo.SmtTerm ($smd_sm.Binary w n1)) ($smd_eo.SmtTerm ($smd_sm.Binary w n2)))
    ($eo_mk_binary w ($smt_apply_2 "+" n1 n2)))
  )
)

(program $eo_mul ((w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral) (r1 $eo_Rational) (r2 $eo_Rational))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_mul ($smd_eo.SmtTerm ($smd_sm.Numeral n1)) ($smd_eo.SmtTerm ($smd_sm.Numeral n2)))
    ($eo_mk_numeral ($smt_apply_2 "*" n1 n2)))
  (($eo_mul ($smd_eo.SmtTerm ($smd_sm.Rational r1)) ($smd_eo.SmtTerm ($smd_sm.Rational r2)))
    ($eo_mk_rational ($smt_apply_2 "*" r1 r2)))
  (($eo_mul ($smd_eo.SmtTerm ($smd_sm.Binary w n1)) ($smd_eo.SmtTerm ($smd_sm.Binary w n2)))
    ($eo_mk_binary w ($smt_apply_2 "*" n1 n2)))
  )
)

(program $eo_qdiv ((w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral) (r1 $eo_Rational) (r2 $eo_Rational))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_qdiv ($smd_eo.SmtTerm ($smd_sm.Numeral n1)) ($smd_eo.SmtTerm ($smd_sm.Numeral n2)))
    (eo::define ((r1 ($smt_apply_1 "to_real" n1)))
    (eo::define ((r2 ($smt_apply_1 "to_real" n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $smd_eo.Stuck
      ($eo_mk_rational ($smt_apply_2 "/" r1 r2))))))
  (($eo_qdiv ($smd_eo.SmtTerm ($smd_sm.Rational r1)) ($smd_eo.SmtTerm ($smd_sm.Rational r2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0/1" r2)
      $smd_eo.Stuck
      ($eo_mk_rational ($smt_apply_2 "/" r1 r2))))
  )
)


(program $eo_zdiv ((w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_zdiv ($smd_eo.SmtTerm ($smd_sm.Numeral n1)) ($smd_eo.SmtTerm ($smd_sm.Numeral n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $smd_eo.Stuck
      ($eo_mk_numeral ($smt_apply_2 "div" n1 n2))))
  (($eo_zdiv ($smd_eo.SmtTerm ($smd_sm.Binary w n1)) ($smd_eo.SmtTerm ($smd_sm.Binary w n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      ($eo_mk_binary w ($sm_mk_binary_max w))
      ($eo_mk_binary w ($smt_apply_2 "div" n1 n2))))
  )
)

(program $eo_zmod ((w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_zmod ($smd_eo.SmtTerm ($smd_sm.Numeral n1)) ($smd_eo.SmtTerm ($smd_sm.Numeral n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $smd_eo.Stuck
      ($eo_mk_numeral ($smt_apply_2 "mod" n1 n2))))
  (($eo_zmod ($smd_eo.SmtTerm ($smd_sm.Binary w n1)) ($smd_eo.SmtTerm ($smd_sm.Binary w n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      ($smd_eo.SmtTerm ($smd_sm.Binary w n1))
      ($eo_mk_binary w ($smt_apply_2 "mod" n1 n2))))
  )
)

(program $eo_is_neg ((n1 $eo_Numeral) (r1 $eo_Rational))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_is_neg ($smd_eo.SmtTerm ($smd_sm.Numeral n1)))
    ($eo_mk_bool ($smt_apply_1 "> 0 " n1)))
  (($eo_is_neg ($smd_eo.SmtTerm ($smd_sm.Rational r1)))
    ($eo_mk_bool ($smt_apply_1 "> 0/1" r1)))
  )
)

; axiom: $eo_neg
(program $eo_neg ((n1 $eo_Numeral) (r1 $eo_Rational))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_neg ($smd_eo.SmtTerm ($smd_sm.Numeral n1)))
    ($eo_mk_numeral ($smt_apply_1 "- " n1)))
  (($eo_neg ($smd_eo.SmtTerm ($smd_sm.Rational r1)))
    ($eo_mk_rational ($smt_apply_1 "-" r1)))
  )
)


;;; String operators

(program $eo_len ((s1 $eo_String) (w $eo_Numeral) (n1 $eo_Numeral))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_len ($smd_eo.SmtTerm ($smd_sm.String s1)))
    ($eo_mk_numeral ($smt_apply_1 "str.len" s1)))
  (($eo_len ($smd_eo.SmtTerm ($smd_sm.Binary w n1)))
    ($eo_mk_numeral w))
  )
)

(program $eo_concat
  ((w1 $eo_Numeral) (n1 $eo_Numeral) (w2 $eo_Numeral) (n2 $eo_Numeral) (s1 $eo_String) (s2 $eo_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_concat ($smd_eo.SmtTerm ($smd_sm.String s1)) ($smd_eo.SmtTerm ($smd_sm.String s2)))
     ($eo_mk_string ($smt_apply_2 "str.++" s1 s2)))
  (($eo_concat ($smd_eo.SmtTerm ($smd_sm.Binary w1 n1)) ($smd_eo.SmtTerm ($smd_sm.Binary w2 n2)))
     ($eo_mk_binary ($smt_apply_2 "+" w1 w2) ($sm_mk_binary_concat w1 n1 w2 n2)))
  )
)

(program $eo_extract
  ((s1 $eo_String) (w1 $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral) (n3 $eo_Numeral))
  :signature ($eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($eo_extract ($smd_eo.SmtTerm ($smd_sm.String s1)) ($smd_eo.SmtTerm ($smd_sm.Numeral n2)) ($smd_eo.SmtTerm ($smd_sm.Numeral n3)))
     ($eo_mk_string ($smt_apply_3 "str.substr" s1 n2 ($smt_apply_2 "+ 1" ($smt_apply_2 "-" n3 n2)))))
  (($eo_extract ($smd_eo.SmtTerm ($smd_sm.Binary w1 n1)) ($smd_eo.SmtTerm ($smd_sm.Numeral n2)) ($smd_eo.SmtTerm ($smd_sm.Numeral n3)))
     ($eo_mk_binary ($smt_apply_1 "+ 1" ($smt_apply_2 "-" n3 n2)) ($sm_mk_binary_extract w1 n1 n2 n3)))
  )
)

(program $eo_find((s1 $eo_String) (s2 $eo_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_find ($smd_eo.SmtTerm ($smd_sm.String s1)) ($smd_eo.SmtTerm ($smd_sm.String s2)))
     ($eo_mk_string ($smt_apply_3 "str.indexof" s1 s2 0)))  ; TODO: is this right??
  )
)


; axiom: $eo_find
;(define $eo_find ((T Type :implicit) (x1 T) (x2 T))
;  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_str x1) ($smt_is_str x2))
;    ($smt_to_eo_z ($smt_apply_3 "str.indexof" ($smt_from_eo_str x1) ($smt_from_eo_str x2) ($smt_from_eo_z ($smt_apply_1 "eo.SmtTerm" 0))))
;    $smd_eo.Stuck))

;;; Conversion operators

(program $eo_to_z ((n1 $eo_Numeral) (r1 $eo_Rational) (s1 $eo_String) (w $eo_Numeral))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_z ($smd_eo.SmtTerm ($smd_sm.Numeral n1)))
    ($eo_mk_numeral n1))
  (($eo_to_z ($smd_eo.SmtTerm ($smd_sm.Rational r1)))
    ($eo_mk_numeral ($smt_apply_2 "to_int" r1)))
  (($eo_to_z ($smd_eo.SmtTerm ($smd_sm.String s1)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 1" ($smt_apply_1 "str.len" s1))
      ($eo_mk_numeral ($smt_apply_1 "str.to_code" s1))
      $smd_eo.Stuck))
  (($eo_to_z ($smd_eo.SmtTerm ($smd_sm.Binary w n1)))
    ($eo_mk_numeral n1))
  )
)

(program $eo_to_q ((n1 $eo_Numeral) (r1 $eo_Rational) (s1 $eo_String) (w $eo_Numeral))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_q ($smd_eo.SmtTerm ($smd_sm.Numeral n1)))
    ($eo_mk_rational ($smt_apply_1 "to_real" n1)))
  (($eo_to_q ($smd_eo.SmtTerm ($smd_sm.Rational r1)))
    ($eo_mk_rational r1))
  )
)

(program $eo_to_bin ((w $eo_Numeral) (w1 $eo_Numeral) (n1 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_to_bin ($smd_eo.SmtTerm ($smd_sm.Numeral w)) ($smd_eo.SmtTerm ($smd_sm.Numeral n1)))
    ($eo_mk_binary w n1))
  (($eo_to_bin ($smd_eo.SmtTerm ($smd_sm.Numeral w)) ($smd_eo.SmtTerm ($smd_sm.Binary w1 n1)))
    ($eo_mk_binary w n1))
  )
)

(program $eo_to_str ((n1 $eo_Numeral) (s1 $eo_String))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_str ($smd_eo.SmtTerm ($smd_sm.Numeral n1)))
    ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_apply_1 "<= 0" n1) ($smt_apply_1 "> 196608" n1))
      ($eo_mk_string ($smt_apply_1 "str.from_code" n1))
      $smd_eo.Stuck))
  (($eo_to_str ($smd_eo.SmtTerm ($smd_sm.String s1)))
    ($eo_mk_string s1))
  ; TODO: technically others here
  )
)
