; This file defines a deep embedding of SMT-LIB into Eunoia.
; It is used for two purposes:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin Eunoia functions, e.g. $eo_add.
; 2. It is used as a tool for defining the model semantics of SMT-LIB.


; All of the functions in this file will be handled by smt_meta.

;;; declarations to define literal types

; TODO: remove this and use $smt_Term instead???
; The type of $smt_apply_* terms
(declare-const $smt_unknown_type Type)
; The operator of $smt_apply_* terms
;(declare-const $smt_String Type)
(define $smt_String () $eo_String)

; note: decimal and hexadecimal omitted for now.

;;; Deep embedding of SMT-LIB operator applications into Eunoia

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_type_0
  ((op $smt_String :opaque))
  Type)
(declare-parameterized-const $smt_type_1
  ((W1 Type :implicit) (op $smt_String :opaque) (x1 W1 :opaque))
  Type)
(declare-parameterized-const $smt_apply_0
  ((op $smt_String :opaque))
  $smt_unknown_type)
(declare-parameterized-const $smt_apply_1
  ((W1 Type :implicit)
   (op $smt_String :opaque) (x1 W1 :opaque)) $smt_unknown_type)
(declare-parameterized-const $smt_apply_2
  ((W1 Type :implicit) (W2 Type :implicit)
   (op $smt_String :opaque) (x1 W1 :opaque) (x2 W2 :opaque)) $smt_unknown_type)
(declare-parameterized-const $smt_apply_3
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit)
   (op $smt_String :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque)) $smt_unknown_type)
(declare-parameterized-const $smt_apply_4
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit)
   (op $smt_String :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque)) $smt_unknown_type)
(declare-parameterized-const $smt_apply_5
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit)
   (op $smt_String :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque) (x5 W5 :opaque)) $smt_unknown_type)

; TODO:
(define $smt_builtin_Bool () ($smt_type_0 "Bool"))
(define $smt_builtin_Int () ($smt_type_0 "Int"))
(define $smt_builtin_Real () ($smt_type_0 "Real"))
(define $smt_builtin_String () ($smt_type_0 "String"))
(define $smt_builtin_true () ($smt_apply_0 "true"))
(define $smt_builtin_false () ($smt_apply_0 "false"))
(define $smt_builtin_= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "=" x1 x2))
(define $smt_builtin_ite ((W Type :implicit) (b $smt_builtin_Bool) (x1 W) (x2 W)) ($smt_apply_3 "ite" b x1 x2))
(define $smt_builtin_+ ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "+" x1 x2))
(define $smt_builtin_not ((b $smt_builtin_Bool)) ($smt_apply_1 "not" b))
(define $smt_builtin_and ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "and" b1 b2))
(define $smt_builtin_or ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "or" b1 b2))


; In this signature, we heavily use references to the Datatypes corresponding
; to the final deep embeddings of Eunoia terms (eo.Term) and SMT-LIB terms
; (sm.Term), where the latter is a subfield type of the former.
; Opaque arguments of a symbol X will be an argument of the constructor eo.X
; (respectively sm.X). Symbols with no

; We introduce datatype constructors for these datatypes ($smd_eo.X and $smd_sm.X)
; respectively. It is important that we mark their arguments as :opaque, as this
; correctly models the pattern matching in the smt-meta later.

; Note that these datatypes will be renamed and replaced by their definitions
; which is hardcoded into smt_meta.smt2.
; We could also have these auto-generated, but leads to complications when it
; comes to printing the argument types, as e.g. the argument to sm.Numeral is
; an SMT-LIB numeral, not a symbolic SMT term.

;;; Deep embedding of SMT-LIB terms

; TODO: move up to own signature

; An SMT-LIB term.
(declare-const $smt_Term Type)

; An SMT-LIB type.
(declare-const $smt_Type Type)

; Note the Bool type is "inlined" into the final signature
(declare-const $smd_sm.True $smt_Term)
(declare-const $smd_sm.False $smt_Term)
(declare-parameterized-const $smd_sm.Numeral ((n $smt_builtin_Int :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Rational ((r $smt_builtin_Real :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.String ((s ($smt_type_0 "String") :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Binary ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $smt_Term)

; A free constant. Constants are identified by:
; (1) Their kind (numeral k),
; (2) Their identifier (numeral i),
; (3) Their type.
; The kind 0 is reserved for standard SMT-LIB symbols introduced
; by the user by declare-const. The other kinds of free symbols
; can be custom defined based on the Eunoia signature (see method
; $eo_const_predicate in model_eo.eo).
(declare-parameterized-const $smd_sm.Const
  ((k $smt_builtin_Int :opaque) (id $smt_builtin_Int :opaque) (T $smt_Type :opaque))
  $smt_Term)

; represents an uninterpreted value
; This must be a constructor in the final sm.Term.
(declare-parameterized-const $smd_sm.usort_value
  ((T $smt_Type :opaque) (i $smt_builtin_Int :opaque)) $smt_Term)

; The Eunoia representation of an SMT-LIB term.
(declare-parameterized-const $smd_sm.Apply
  ((t1 $smt_Term :opaque) (t $smt_Term :opaque)) $smt_Term)

;;; Deep embedding of SMT-LIB types

; The Boolean type
(declare-const $smd_tsm.BoolType $smt_Type)

; Function types
(declare-parameterized-const $smd_tsm.FunType
  ((T1 $smt_Type :opaque) (T2 $smt_Type :opaque)) $smt_Type)

; Uninterpreted sorts
(declare-parameterized-const $smd_tsm.USort
  ((id $smt_builtin_Int :opaque)) $smt_Type)

; Uninterpreted sorts
(declare-parameterized-const $smd_tsm.UnknownSort
  ((id $smt_builtin_Int :opaque)) $smt_Type)

;;; Deep embedding of Eunoia terms

; $eo_Term is forward declared in eo_desugar.eo

; The Eunoia representation of an SMT-LIB term.
(declare-parameterized-const $smd_eo.SmtTerm ((t $smt_Term :opaque)) $eo_Term)
(declare-parameterized-const $smd_eo.SmtType ((t $smt_Type :opaque)) $eo_Term)
; The Eunoia representation of "stuckness".
(declare-const $smd_eo.Stuck $eo_Term)

;;; Utilities
  
(define $sm_mk_true () $smd_sm.True)
(define $sm_mk_false () $smd_sm.False)
(define $sm_mk_bool ((c $smt_builtin_Bool))
  ($smt_apply_3 "ite" c $sm_mk_true $sm_mk_false))

(define $eo_smt_term ((t $smt_Term)) ($smd_eo.SmtTerm t))
(define $eo_smt_type ((T $smt_Type)) ($smd_eo.SmtType T))

  ;;;;;;;;;;;;;;;;; no smd_ below here?


;;; Defining parametric bitvector operators

; The operators in this section are needed to reason about the parametric
; operations on the Eunoia binary literal type.

(program $sm_mk_pow2 ((i $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($sm_mk_pow2 i)  ($smt_apply_3 "ite" ($smt_apply_2 "<=" i 0)
                      1
                      ($smt_apply_2 "*" 2 ($sm_mk_pow2 ($smt_apply_2 "-" i 1)))))
  )
)
(program $sm_mk_bit ((x $smt_builtin_Int) (i $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) ($smt_type_0 "Bool")
  (
  ; (= (mod (div x ($sm_mk_pow2 i)) 2) 1)
  (($sm_mk_bit x i) ($smt_apply_1 "= 1" ($smt_apply_2 "mod" ($smt_apply_2 "div" x ($sm_mk_pow2 i)) 2)))
  )
)
(program $sm_mk_binary_and ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($sm_mk_binary_and w n1 n2)
     ($smt_apply_3 "ite" ($smt_apply_2 "=" w 0) 0
     ($smt_apply_3 "ite" ($smt_apply_2 "=" w 1)
       ($smt_apply_3 "ite" ($smt_builtin_and ($smt_apply_2 "=" n1 1) ($smt_apply_2 "=" n2 1)) 1 0)
       ($smt_apply_2 "+"
         ($sm_mk_binary_and ($smt_apply_2 "-" w 1) n1 n2)
         ($smt_apply_2 "*" ($sm_mk_pow2 w)
            ($smt_apply_3 "ite" ($smt_builtin_and ($sm_mk_bit n1 w) ($sm_mk_bit n2 w)) 1 0))))))
  )
)
(program $sm_mk_binary_or ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_xor ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_not ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_max ((w $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($sm_mk_binary_max w) ($smt_apply_1 "- 1" ($sm_mk_pow2 w)))
  )
)
(program $sm_mk_binary_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_extract
  ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)

;;; Utilities

(define $eo_mk_bool ((x ($smt_type_0 "Bool")))
  ($eo_smt_term ($sm_mk_bool x)))
(program $eo_mk_numeral ((x $smt_builtin_Int))
  :signature ($smt_builtin_Int) $eo_Term
  (
  (($eo_mk_numeral x) ($eo_smt_term ($smd_sm.Numeral x)))
  )
)
(program $eo_mk_rational ((x ($smt_type_0 "Real")))
  :signature (($smt_type_0 "Real")) $eo_Term
  (
  (($eo_mk_rational x) ($eo_smt_term ($smd_sm.Rational x)))
  )
)
(program $eo_mk_string ((x ($smt_type_0 "String")))
  :signature (($smt_type_0 "String")) $eo_Term
  (
  (($eo_mk_string x) ($eo_smt_term ($smd_sm.String x)))
  )
)
(program $eo_mk_binary ((w $eo_Numeral) (n $eo_Numeral))
  :signature ($smt_builtin_Int $smt_builtin_Int) $eo_Term
  (
  (($eo_mk_binary w n)
    ($smt_apply_3 "ite" ($smt_builtin_and ($smt_apply_1 "<= 0" w) ($smt_apply_1 ">= 4294967296" w))
      ($eo_smt_term ($smd_sm.Binary w ($smt_apply_2 "mod" n ($sm_mk_pow2 w))))
      $smd_eo.Stuck))
  )
)
; Convert Eunoia Boolean to an smt Boolean.
(program $smt_from_eo_bool ()
  :signature ($eo_Term) ($smt_type_0 "Bool")
  ; Definition:
  ; (
  ; (($smt_from_eo_bool ($eo_smt_term $sm_mk_true)) (strue)
  ; (($smt_from_eo_bool ($eo_smt_term $sm_mk_false)) false)
  ; )
)
; Convert Eunoia Numeral to an smt Integer.
(program $smt_from_eo_z ((n $smt_builtin_Int))
  :signature ($eo_Term) $smt_builtin_Int
  ; Definition:
  ; (
  ; (($smt_from_eo_z ($eo_smt_term ($smd_sm.Numeral n))) n)
  ; )
)
; Convert Eunoia Rational to an smt Real.
(program $smt_from_eo_q ((r ($smt_type_0 "Real")))
  :signature ($eo_Term) ($smt_type_0 "Real")
  ; Definition:
  ; (
  ; (($smt_from_eo_q ($eo_smt_term ($smd_sm.Rational r))) r)
  ; )
)
; Convert Eunoia String to an smt String.
(program $smt_from_eo_str ((s ($smt_type_0 "String")))
  :signature ($eo_Term) ($smt_type_0 "String")
  ; Definition:
  ; (
  ; (($smt_from_eo_str ($eo_smt_term ($smd_sm.String s))) s)
  ; )
)


; Assumes that t is a Boolean term
(define $sm_is_bool ((T Type :implicit) (t T))
  ($smt_builtin_or
    ; treat "= sm.True" as a unary function, ditto for "= sm.False"
    ($smt_apply_1 "= sm.True" t)
    ($smt_apply_1 "= sm.False" t)))

; Boolean relies on the $sm_is_Boolean define-fun in the SMT meta signature.
; This is an optimization to avoid Booleans in the final datatype.
;(define $eo_is_bool ((t $eo_Term))
;    ($smt_builtin_or
;      ; treat "= sm.True" as a unary function, ditto for "= sm.False"
;      ($smt_apply_1 "= (eo.SmtTerm sm.True)" t)
;      ($smt_apply_1 "= (eo.SmtTerm sm.False)" t)))
;; Assumes that t is a Boolean term
;(define $eo_get_bool ((t $eo_Term))
;  ($smt_apply_1 "= (eo.SmtTerm sm.True)" t))

;;; Utilities

; We are now ready to define the builtins of Eunoia

;;; Boolean operators

; axiom: $eo_not
(program $eo_not ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_not ($eo_smt_term $sm_mk_true))         ($eo_smt_term $sm_mk_false))
  (($eo_not ($eo_smt_term $sm_mk_false))        ($eo_smt_term $sm_mk_true))
  (($eo_not ($eo_smt_term ($smd_sm.Binary w n))) ($eo_mk_binary w ($sm_mk_binary_not w n)))
  )
)

; axiom: $eo_and
(program $eo_and
  ((b1 $eo_Term) (b2 $eo_Term) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_and ($eo_smt_term ($smd_sm.Binary w n1)) ($eo_smt_term ($smd_sm.Binary w n2)))
     ($eo_mk_binary w ($sm_mk_binary_and w n1 n2)))
  (($eo_and $sm_mk_true $sm_mk_true)   ($eo_mk_bool ($smt_apply_0 "true")))
  (($eo_and $sm_mk_true $sm_mk_false)  ($eo_mk_bool ($smt_apply_0 "false")))
  (($eo_and $sm_mk_false $sm_mk_true)  ($eo_mk_bool ($smt_apply_0 "false")))
  (($eo_and $sm_mk_false $sm_mk_false) ($eo_mk_bool ($smt_apply_0 "false")))
  )
)

; axiom: $eo_or
(program $eo_or
  ((b1 $eo_Term) (b2 $eo_Term) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_or ($eo_smt_term ($smd_sm.Binary w n1)) ($eo_smt_term ($smd_sm.Binary w n2)))
     ($eo_mk_binary w ($sm_mk_binary_or w n1 n2)))
  (($eo_or $sm_mk_true $sm_mk_true)   ($eo_mk_bool ($smt_apply_0 "true")))
  (($eo_or $sm_mk_true $sm_mk_false)  ($eo_mk_bool ($smt_apply_0 "true")))
  (($eo_or $sm_mk_false $sm_mk_true)  ($eo_mk_bool ($smt_apply_0 "true")))
  (($eo_or $sm_mk_false $sm_mk_false) ($eo_mk_bool ($smt_apply_0 "false")))
  )
)

; axiom: $eo_xor
(program $eo_xor ((b1 $eo_Term) (b2 $eo_Term) (w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_xor ($eo_smt_term ($smd_sm.Binary w n1)) ($eo_smt_term ($smd_sm.Binary w n2)))
     ($eo_mk_binary w ($sm_mk_binary_or w n1 n2)))
  (($eo_xor $sm_mk_true $sm_mk_true)   ($eo_mk_bool ($smt_apply_0 "false")))
  (($eo_xor $sm_mk_true $sm_mk_false)  ($eo_mk_bool ($smt_apply_0 "true")))
  (($eo_xor $sm_mk_false $sm_mk_true)  ($eo_mk_bool ($smt_apply_0 "true")))
  (($eo_xor $sm_mk_false $sm_mk_false) ($eo_mk_bool ($smt_apply_0 "false")))
  )
)


;;; Arithmetic operators

(program $eo_add ((w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral) (r1 $eo_Rational) (r2 $eo_Rational))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_add ($eo_smt_term ($smd_sm.Numeral n1)) ($eo_smt_term ($smd_sm.Numeral n2)))
    ($eo_mk_numeral ($smt_apply_2 "+" n1 n2)))
  (($eo_add ($eo_smt_term ($smd_sm.Rational r1)) ($eo_smt_term ($smd_sm.Rational r2)))
    ($eo_mk_rational ($smt_apply_2 "+" r1 r2)))
  (($eo_add ($eo_smt_term ($smd_sm.Binary w n1)) ($eo_smt_term ($smd_sm.Binary w n2)))
    ($eo_mk_binary w ($smt_apply_2 "+" n1 n2)))
  )
)

(program $eo_mul ((w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral) (r1 $eo_Rational) (r2 $eo_Rational))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_mul ($eo_smt_term ($smd_sm.Numeral n1)) ($eo_smt_term ($smd_sm.Numeral n2)))
    ($eo_mk_numeral ($smt_apply_2 "*" n1 n2)))
  (($eo_mul ($eo_smt_term ($smd_sm.Rational r1)) ($eo_smt_term ($smd_sm.Rational r2)))
    ($eo_mk_rational ($smt_apply_2 "*" r1 r2)))
  (($eo_mul ($eo_smt_term ($smd_sm.Binary w n1)) ($eo_smt_term ($smd_sm.Binary w n2)))
    ($eo_mk_binary w ($smt_apply_2 "*" n1 n2)))
  )
)

(program $eo_qdiv ((w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral) (r1 $eo_Rational) (r2 $eo_Rational))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_qdiv ($eo_smt_term ($smd_sm.Numeral n1)) ($eo_smt_term ($smd_sm.Numeral n2)))
    (eo::define ((r1 ($smt_apply_1 "to_real" n1)))
    (eo::define ((r2 ($smt_apply_1 "to_real" n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $smd_eo.Stuck
      ($eo_mk_rational ($smt_apply_2 "/" r1 r2))))))
  (($eo_qdiv ($eo_smt_term ($smd_sm.Rational r1)) ($eo_smt_term ($smd_sm.Rational r2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0/1" r2)
      $smd_eo.Stuck
      ($eo_mk_rational ($smt_apply_2 "/" r1 r2))))
  )
)


(program $eo_zdiv ((w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_zdiv ($eo_smt_term ($smd_sm.Numeral n1)) ($eo_smt_term ($smd_sm.Numeral n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $smd_eo.Stuck
      ($eo_mk_numeral ($smt_apply_2 "div" n1 n2))))
  (($eo_zdiv ($eo_smt_term ($smd_sm.Binary w n1)) ($eo_smt_term ($smd_sm.Binary w n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      ($eo_mk_binary w ($sm_mk_binary_max w))
      ($eo_mk_binary w ($smt_apply_2 "div" n1 n2))))
  )
)

(program $eo_zmod ((w $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_zmod ($eo_smt_term ($smd_sm.Numeral n1)) ($eo_smt_term ($smd_sm.Numeral n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $smd_eo.Stuck
      ($eo_mk_numeral ($smt_apply_2 "mod" n1 n2))))
  (($eo_zmod ($eo_smt_term ($smd_sm.Binary w n1)) ($eo_smt_term ($smd_sm.Binary w n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      ($eo_smt_term ($smd_sm.Binary w n1))
      ($eo_mk_binary w ($smt_apply_2 "mod" n1 n2))))
  )
)

(program $eo_is_neg ((n1 $eo_Numeral) (r1 $eo_Rational))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_is_neg ($eo_smt_term ($smd_sm.Numeral n1)))
    ($eo_mk_bool ($smt_apply_1 "> 0 " n1)))
  (($eo_is_neg ($eo_smt_term ($smd_sm.Rational r1)))
    ($eo_mk_bool ($smt_apply_1 "> 0/1" r1)))
  )
)

; axiom: $eo_neg
(program $eo_neg ((n1 $eo_Numeral) (r1 $eo_Rational))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_neg ($eo_smt_term ($smd_sm.Numeral n1)))
    ($eo_mk_numeral ($smt_apply_1 "- " n1)))
  (($eo_neg ($eo_smt_term ($smd_sm.Rational r1)))
    ($eo_mk_rational ($smt_apply_1 "-" r1)))
  )
)


;;; String operators

(program $eo_len ((s1 $eo_String) (w $eo_Numeral) (n1 $eo_Numeral))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_len ($eo_smt_term ($smd_sm.String s1)))
    ($eo_mk_numeral ($smt_apply_1 "str.len" s1)))
  (($eo_len ($eo_smt_term ($smd_sm.Binary w n1)))
    ($eo_mk_numeral w))
  )
)

(program $eo_concat
  ((w1 $eo_Numeral) (n1 $eo_Numeral) (w2 $eo_Numeral) (n2 $eo_Numeral) (s1 $eo_String) (s2 $eo_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_concat ($eo_smt_term ($smd_sm.String s1)) ($eo_smt_term ($smd_sm.String s2)))
     ($eo_mk_string ($smt_apply_2 "str.++" s1 s2)))
  (($eo_concat ($eo_smt_term ($smd_sm.Binary w1 n1)) ($eo_smt_term ($smd_sm.Binary w2 n2)))
     ($eo_mk_binary ($smt_apply_2 "+" w1 w2) ($sm_mk_binary_concat w1 n1 w2 n2)))
  )
)

(program $eo_extract
  ((s1 $eo_String) (w1 $eo_Numeral) (n1 $eo_Numeral) (n2 $eo_Numeral) (n3 $eo_Numeral))
  :signature ($eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($eo_extract ($eo_smt_term ($smd_sm.String s1)) ($eo_smt_term ($smd_sm.Numeral n2)) ($eo_smt_term ($smd_sm.Numeral n3)))
     ($eo_mk_string ($smt_apply_3 "str.substr" s1 n2 ($smt_apply_1 "+ 1" ($smt_apply_2 "-" n3 n2)))))
  (($eo_extract ($eo_smt_term ($smd_sm.Binary w1 n1)) ($eo_smt_term ($smd_sm.Numeral n2)) ($eo_smt_term ($smd_sm.Numeral n3)))
     ($eo_mk_binary ($smt_apply_1 "+ 1" ($smt_apply_2 "-" n3 n2)) ($sm_mk_binary_extract w1 n1 n2 n3)))
  )
)

(program $eo_find((s1 $eo_String) (s2 $eo_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_find ($eo_smt_term ($smd_sm.String s1)) ($eo_smt_term ($smd_sm.String s2)))
     ($eo_mk_string ($smt_apply_3 "str.indexof" s1 s2 0)))    ; TODO: 0 should technically be ($smt_apply_0 "0").
  )
)

;;; Conversion operators

(program $eo_to_z ((n1 $eo_Numeral) (r1 $eo_Rational) (s1 $eo_String) (w $eo_Numeral))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_z ($eo_smt_term ($smd_sm.Numeral n1)))
    ($eo_mk_numeral n1))
  (($eo_to_z ($eo_smt_term ($smd_sm.Rational r1)))
    ($eo_mk_numeral ($smt_apply_1 "to_int" r1)))
  (($eo_to_z ($eo_smt_term ($smd_sm.String s1)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 1" ($smt_apply_1 "str.len" s1))
      ($eo_mk_numeral ($smt_apply_1 "str.to_code" s1))
      $smd_eo.Stuck))
  (($eo_to_z ($eo_smt_term ($smd_sm.Binary w n1)))
    ($eo_mk_numeral n1))
  )
)

(program $eo_to_q ((n1 $eo_Numeral) (r1 $eo_Rational) (s1 $eo_String) (w $eo_Numeral))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_q ($eo_smt_term ($smd_sm.Numeral n1)))
    ($eo_mk_rational ($smt_apply_1 "to_real" n1)))
  (($eo_to_q ($eo_smt_term ($smd_sm.Rational r1)))
    ($eo_mk_rational r1))
  )
)

(program $eo_to_bin ((w $eo_Numeral) (w1 $eo_Numeral) (n1 $eo_Numeral))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_to_bin ($eo_smt_term ($smd_sm.Numeral w)) ($eo_smt_term ($smd_sm.Numeral n1)))
    ($eo_mk_binary w n1))
  (($eo_to_bin ($eo_smt_term ($smd_sm.Numeral w)) ($eo_smt_term ($smd_sm.Binary w1 n1)))
    ($eo_mk_binary w n1))
  )
)

(program $eo_to_str ((n1 $eo_Numeral) (s1 $eo_String))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_str ($eo_smt_term ($smd_sm.Numeral n1)))
    ($smt_apply_3 "ite" ($smt_builtin_and ($smt_apply_1 "<= 0" n1) ($smt_apply_1 "> 196608" n1))
      ($eo_mk_string ($smt_apply_1 "str.from_code" n1))
      $smd_eo.Stuck))
  (($eo_to_str ($eo_smt_term ($smd_sm.String s1)))
    ($eo_mk_string s1))
  ; TODO: technically others here
  )
)
