; This file defines a deep embedding of SMT-LIB into Eunoia.
; It is used for two purposes:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin Eunoia functions, e.g. eo::add.
; 2. It is used as a tool for defining the model semantics of SMT-LIB.


; All of the functions in this file will be handled by smt_meta.

;;; declarations to define literal types

(define $smt_Numeral () $eo_Numeral)
(define $smt_Rational () $eo_Rational)
(define $smt_String () $eo_String)

;;; TEMPORARY to make this file self contained
;(declare-const $smt_Numeral Type)
;(declare-const $smt_Rational Type)
;(declare-const $smt_String Type)
;(declare-const $eo_fail Type)
;;; TEMPORARY

(declare-const $smt_unknown_type Type)

; Bit-vectors
; NOTE: we currently define $smt_BitVec
(declare-parameterized-const $smt_BitVec ((n $smt_Numeral :opaque)) Type)
; $smt_Binary remains undefined
(define $smt_Binary () $smt_unknown_type)

; note: decimal and hexadecimal omitted for now.

; An SMT-LIB term.
(declare-const $smt_Term Type)

; A placeholder for a failed evaluation
(declare-const $smt_fail $smt_Term)

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_apply_1
  ((W1 Type :implicit))
  (-> $smt_String W1 $smt_Term))
(declare-parameterized-const $smt_apply_2
  ((W1 Type :implicit) (W2 Type :implicit))
  (-> $smt_String W1 W2 $smt_Term))
(declare-parameterized-const $smt_apply_3
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit))
  (-> $smt_String W1 W2 W3 $smt_Term))
(declare-parameterized-const $smt_apply_4
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit))
  (-> $smt_String W1 W2 W3 W4 $smt_Term))
(declare-parameterized-const $smt_apply_5
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit))
  (-> $smt_String W1 W2 W3 W4 W5 $smt_Term))

; Convert from Eunoia to an SMT value
; These assume the Eunoia term is a literal of the correct type.
; All uses of the $smt_from_eo_* methods must ensure this is the case
; Convert Eunoia Boolean to an smt Boolean.
(declare-const $smt_from_eo_bool (-> Bool $smt_Term))
; Convert Eunoia Numeral to an smt Integer.
(declare-const $smt_from_eo_z (-> $smt_Numeral $smt_Term))
; Convert Eunoia Rational to an smt Real.
(declare-const $smt_from_eo_q (-> $smt_Rational $smt_Term))
; Convert Eunoia String to an smt String.
(declare-const $smt_from_eo_str (-> $smt_String $smt_Term))
; Convert Eunoia Binary to an smt-meta representation of Binary.
(declare-const $smt_from_eo_bin (-> $smt_Binary $smt_Term))
; Convert smt2 term to a Eunoia Boolean.
(declare-const $smt_to_eo_bool (-> $smt_Term Bool))
; Convert smt2 term to a Eunoia numeral.
(declare-const $smt_to_eo_z (-> $smt_Term $smt_Numeral))
; Convert smt2 term to a Eunoia rational.
(declare-const $smt_to_eo_q (-> $smt_Term $smt_Rational))
; Convert smt2 term to a Eunoia string.
(declare-const $smt_to_eo_str (-> $smt_Term $smt_String))
; Convert smt2 term to a Eunoia binary.
(declare-const $smt_to_eo_bin (-> $smt_Term $smt_Binary))

; Testers that use lower level sm.Term datatype, both for simplicity and efficiency.
; These rely on "is sm.Numeral" referring to the SMT-LIB operator (_ is sm.Numeral)
; in the final encoding.
; Boolean relies on the $sm_is_Boolean define-fun in the SMT meta signature.
(define $smt_is_bool ((T Type :implicit) (t T)) ($smt_apply_1 "$sm_is_Boolean" t))
(define $smt_is_z ((T Type :implicit) (t T)) ($smt_apply_1 "is sm.Numeral" t))
(define $smt_is_q ((T Type :implicit) (t T)) ($smt_apply_1 "is sm.Rational" t))
(define $smt_is_str ((T Type :implicit) (t T)) ($smt_apply_1 "is sm.String" t))
(define $smt_is_bin ((T Type :implicit) (t T)) ($smt_apply_1 "is sm.Binary" t))
; decomposing binaries
(define $smt_bin_width ((T Type :implicit) (t T)) ($smt_apply_1 "sm.Binary.width" t))
(define $smt_bin_val ((T Type :implicit) (t T)) ($smt_apply_1 "sm.Binary.val" t))
;
(define $smt_eo_is_bool ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_bool t)))
(define $smt_eo_is_z ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_z t)))
(define $smt_eo_is_q ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_q t)))
(define $smt_eo_is_str ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_str t)))
(define $smt_eo_is_bin ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_bin t)))

;;;

; Defining parametric bitvector operators

(program $sm_Binary () :signature ($smt_Numeral $smt_Numeral) $smt_Numeral)

(program $sm_Binary_and ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_Binary_or ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_Binary_xor ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_Binary_not ()
  :signature ($smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_Binary_concat ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)
(program $sm_Binary_extract ()
  :signature ($smt_Numeral $smt_Numeral $smt_Numeral $smt_Numeral) $smt_Numeral)

;;; Utilities

; Apply SMT-LIB operator Boolean connective "op" to Eunoia terms x1 and x2.
; Return the Eunoia term.
(define $sm_eo_apply_bool_op_2 ((op $smt_String) (x1 Bool) (x2 Bool))
  ($smt_to_eo_bool ($smt_apply_2 op
    ($smt_from_eo_bool x1)
    ($smt_from_eo_bool x2))))

; An SMT-LIB formula corresponding to Eunoia terms being an integer division operation.
; Return the SMT-LIB Boolean.
(define $smt_eo_is_z_div_op ((x1 $smt_Numeral) (x2 $smt_Numeral))
  ($smt_apply_3 "and"
    ($smt_is_z x1)
    ($smt_is_z x2)
    ($smt_apply_1 "not" ($smt_apply_2 "=" ($smt_from_eo_z x2) ($smt_from_eo_z 0)))))

; An SMT-LIB formula corresponding to Eunoia terms being a real division operation.
; Return the SMT-LIB Boolean.
(define $smt_eo_is_q_div_op ((x1 $smt_Rational) (x2 $smt_Rational))
  ($smt_apply_3 "and"
    ($smt_is_q x1)
    ($smt_is_q x2)
    ($smt_apply_1 "not" ($smt_apply_2 "=" ($smt_from_eo_q x2) ($smt_from_eo_q 0/1)))))

; An SMT-LIB formula corresponding to Eunoia terms being the binaries of the same width.
; Return the SMT-LIB Boolean.
(define $smt_eo_is_bin_same_width ((x1 $smt_Binary) (x2 $smt_Binary))
  ($smt_apply_3 "and"
    ($smt_is_bin x1)
    ($smt_is_bin x2)
    ($smt_apply_2 "=" ($smt_bin_width x1) ($smt_bin_width x2))))

; Apply SMT-LIB operator (-> Int Int Int) "op" to Eunoia terms x1 and x2.
; Return the Eunoia term.
(define $sm_eo_apply_z_op_2 ((op $smt_String) (x1 Bool) (x2 Bool))
  ($smt_to_eo_z ($smt_apply_2 op
    ($smt_from_eo_z x1)
    ($smt_from_eo_z x2))))

; Apply SMT-LIB operator (-> Real Real Real) "op" to Eunoia terms x1 and x2.
; Return the Eunoia term.
(define $sm_eo_apply_q_op_2 ((op $smt_String) (x1 Bool) (x2 Bool))
  ($smt_to_eo_q ($smt_apply_2 op
    ($smt_from_eo_q x1)
    ($smt_from_eo_q x2))))

(define $smt_try_eval_o_arith_unary
  ((W1 Type :implicit) (U Type :implicit) (op $smt_String) (x1 W1) (u U))
  ($smt_apply_3 "ite" ($smt_is_z x1)
    ($smt_to_eo_z ($smt_apply_1 op ($smt_from_eo_z x1)))
  ($smt_apply_3 "ite" ($smt_is_q x1)
    ($smt_to_eo_q ($smt_apply_1 op ($smt_from_eo_q x1)))
    u)))

(define $smt_try_eval_o_arith
  ((W1 Type :implicit) (W2 Type :implicit) (U Type :implicit) (op $smt_String) (x1 W1) (x2 W2) (u U))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_z x1) ($smt_is_z x2))
    ($sm_eo_apply_z_op_2 op x1 x2)
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_q x1) ($smt_is_q x2))
    ($sm_eo_apply_q_op_2 op x1 x2)
    u)))

(define $smt_try_eval_o_arith_pred
  ((W1 Type :implicit) (W2 Type :implicit) (U Type :implicit) (op $smt_String) (x1 W1) (x2 W2) (u U))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_z x1) ($smt_is_z x2))
    ($smt_to_eo_bool ($smt_apply_2 op ($smt_from_eo_z x1) ($smt_from_eo_z x2)))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_q x1) ($smt_is_q x2))
    ($smt_to_eo_bool ($smt_apply_2 op ($smt_from_eo_q x1) ($smt_from_eo_q x2)))
    u)))

; We are now ready to define the builtins of Eunoia

;;; Boolean operators

; axiom: $eo_not
(define $eo_not ((T Type :implicit) (x1 T))
  ($smt_apply_3 "ite" ($smt_is_bool x1)
    ($smt_to_eo_bool ($smt_apply_1 "not" ($smt_from_eo_bool x1)))
  ($smt_apply_3 "ite" ($smt_is_bin x1)
    (eo::define ((w ($smt_bin_width x1)))
      ($sm_Binary ($sm_Binary_not w ($smt_bin_val x1)) w))
    $smt_fail)))

; axiom: $eo_and
(define $eo_and ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_bool x1) ($smt_is_bool x2))
    ($sm_eo_apply_bool_op_2 "and" x1 x2)
  ($smt_apply_3 "ite" ($smt_eo_is_bin_same_width x1 x2)
    (eo::define ((w ($smt_bin_width x1)))
      ($sm_Binary ($sm_Binary_and w ($smt_bin_val x1) ($smt_bin_val x2)) w))
    $smt_fail)))

; axiom: $eo_or
(define $eo_or ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_bool x1) ($smt_is_bool x2))
    ($sm_eo_apply_bool_op_2 "or" x1 x2)
  ($smt_apply_3 "ite" ($smt_eo_is_bin_same_width x1 x2)
    (eo::define ((w ($smt_bin_width x1)))
      ($sm_Binary ($sm_Binary_or w ($smt_bin_val x1) ($smt_bin_val x2)) w))
    $smt_fail)))

; axiom: $eo_xor
(define $eo_or ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_bool x1) ($smt_is_bool x2))
    ($sm_eo_apply_bool_op_2 "xor" x1 x2)
  ($smt_apply_3 "ite" ($smt_eo_is_bin_same_width x1 x2)
    (eo::define ((w ($smt_bin_width x1)))
      ($sm_Binary ($sm_Binary_xor w ($smt_bin_val x1) ($smt_bin_val x2)) w))
    $smt_fail)))

;;; Arithmetic operators

; axiom: $eo_add
(define $eo_add ((T Type :implicit) (x1 T) (x2 T))
  ; first try (overloaded) arithmetic
  ($smt_try_eval_o_arith "+" x1 x2
  ; if that fails, try binary
  ($smt_apply_3 "ite" ($smt_eo_is_bin_same_width x1 x2)
    ($sm_Binary ($smt_apply_2 "+" ($smt_bin_val x1) ($smt_bin_val x2)) ($smt_bin_width x1))
    $eo_fail)))

; axiom: $eo_mul
(define $eo_mul ((T Type :implicit) (x1 T) (x2 T))
  ; first try (overloaded) arithmetic
  ($smt_try_eval_o_arith "*" x1 x2
  ; if that fails, try binary
  ($smt_apply_3 "ite" ($smt_eo_is_bin_same_width x1 x2)
    ($sm_Binary ($smt_apply_2 "*" ($smt_bin_val x1) ($smt_bin_val x2)) ($smt_bin_width x1))
    $eo_fail)))

; axiom: $eo_qdiv
(define $eo_qdiv ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_eo_is_z_div_op x1 x2)
    ($smt_to_eo_q ($smt_apply_2 "/" ($smt_apply_1 "to_real" ($smt_from_eo_z x1)) ($smt_apply_1 "to_real" ($smt_from_eo_z x2))))
  ($smt_apply_3 "ite" ($smt_eo_is_q_div_op x1 x2)
    ($sm_eo_apply_q_op_2 "/" x1 x2)
    $eo_fail)))

; axiom: $eo_zdiv
(define $eo_zdiv ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_eo_is_z_div_op x1 x2)
    ($sm_eo_apply_z_op_2 "div" x1 x2)
  ($smt_apply_3 "ite" ($smt_eo_is_bin_same_width x1 x2)
    ($sm_Binary ($smt_apply_2 "div" ($smt_bin_val x1) ($smt_bin_val x2)) ($smt_bin_width x1))
    $eo_fail)))

; axiom: $eo_zmod
(define $eo_zmod ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_eo_is_z_div_op x1 x2)
    ($sm_eo_apply_z_op_2 "mod" x1 x2)
  ($smt_apply_3 "ite" ($smt_eo_is_bin_same_width x1 x2)
    ($sm_Binary ($smt_apply_2 "mod" ($smt_bin_val x1) ($smt_bin_val x2)) ($smt_bin_width x1))
    $eo_fail)))

; axiom: $eo_is_neg
(define $eo_is_neg ((T Type :implicit) (x1 T))
  ($smt_apply_3 "ite" ($smt_is_z x1)
    ($smt_to_eo_bool ($smt_apply_2 "<" ($smt_from_eo_z x1) 0))
  ($smt_apply_3 "ite" ($smt_is_q x1)
    ($smt_to_eo_bool ($smt_apply_2 "<" ($smt_from_eo_q x1) 0.0))
    $eo_fail)))

; axiom: $eo_neg
(define $eo_neg ((T Type :implicit) (x1 T))
  ($smt_try_eval_o_arith_unary "-" x1 $eo_fail))

;;; String operators

; axiom: $eo_len
(define $eo_len ((T Type :implicit) (x1 T))
  ($smt_apply_3 "ite" ($smt_is_bin x1)
    ($smt_to_eo_z ($smt_bin_width x1))
  ($smt_apply_3 "ite" ($smt_is_str x1)
    ($smt_to_eo_z ($smt_apply_1 "str.len" ($smt_from_eo_str x1)))
    $eo_fail)))

; axiom: $eo_concat
(define $eo_concat ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_str x1) ($smt_is_str x2))
    ($smt_to_eo_str ($smt_apply_2 "str.++" ($smt_from_eo_str x1) ($smt_from_eo_str x2)))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_bin x1) ($smt_is_bin x2))
    (eo::define ((w1 ($smt_bin_width x1)))
    (eo::define ((w2 ($smt_bin_width x2)))
      ($sm_Binary
        ($sm_Binary_concat w1 ($smt_bin_val x1) w2 ($smt_bin_val x2))
        ($smt_apply_2 "+" w1 w2))))
    $eo_fail)))

; axiom: $eo_extract
(define $eo_extract ((T Type :implicit) (x1 T) (x2 $smt_Numeral) (x3 $smt_Numeral))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_z x2) ($smt_is_z x3))
    ($smt_apply_3 "ite" ($smt_is_str x1)
      (eo::define ((n2 ($smt_from_eo_z x2)))
      (eo::define ((n3 ($smt_from_eo_z x3)))
      ($smt_to_eo_str ($smt_apply_3 "str.substr" ($smt_from_eo_str x1) n2 ($smt_apply_2 "+" ($smt_apply_2 "-" n3 n2) 1)))))
    ($smt_apply_3 "ite" ($smt_is_bin x1)
      ($sm_Binary_extract ($smt_bin_width x1) ($smt_bin_val x1) ($smt_bin_val x2) ($smt_bin_val x3))
      $eo_fail))
    $eo_fail))

; axiom: $eo_find
(define $eo_find ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_str x1) ($smt_is_str x2))
    ($smt_to_eo_z ($smt_apply_3 "str.indexof" ($smt_from_eo_str x1) ($smt_from_eo_str x2) 0))
    $eo_fail))

;;; Conversion operators

; axiom: $eo_to_z
(define $eo_to_z ((T Type :implicit) (x1 T))
  ($smt_apply_3 "ite" ($smt_is_z x1)
    x1
  ($smt_apply_3 "ite" ($smt_is_q x1)
    ($smt_to_eo_z ($smt_apply_2 "to_int" ($smt_from_eo_q x1)))
  ($smt_apply_3 "ite" ($smt_is_bin x1)
    ($smt_to_eo_z ($smt_bin_val x1))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_str x1) ($smt_apply_2 "=" ($smt_apply_1 "str.len" ($smt_from_eo_str x1)) ($smt_from_eo_z 1)))
    ($smt_to_eo_z ($smt_apply_1 "str.to_code" ($smt_from_eo_str x1)))
    $eo_fail)))))

; axiom: $eo_to_q
(define $eo_to_q ((T Type :implicit) (x1 T))
  ($smt_apply_3 "ite" ($smt_is_z x1)
    ($smt_to_eo_q ($smt_apply_1 "to_real" ($smt_from_eo_z x1)))
  ($smt_apply_3 "ite" ($smt_is_q x1)
    x1
    $eo_fail)))

; axiom: $eo_to_bin
(define $eo_to_bin ((T Type :implicit) (x1 T) (x2 T))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_z x1) ($smt_is_z x2))
    ($sm_Binary ($smt_from_eo_z x1) ($smt_from_eo_z x2))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smt_is_z x1) ($smt_is_z x2))
    ($sm_Binary ($smt_from_eo_z x1) ($smt_bin_val x2))
    $eo_fail)))

; axiom: $eo_to_str
(define $eo_to_str ((T Type :implicit) (x1 T))
  ($smt_apply_3 "ite" ($smt_is_z x1)
    ($smt_to_eo_str ($smt_apply_1 "str.from_code" ($smt_from_eo_z x1)))
  ($smt_apply_3 "ite" ($smt_is_str x1)
    x1
  ; TODO?
    $eo_fail)))
