; This file defines a deep embedding of SMT-LIB into Eunoia.
; It is used for two purposes:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin Eunoia functions, e.g. eo::add.
; 2. It is used as a tool for defining the model semantics of SMT-LIB.

; This file should have no dependencies.

; All of the functions in this file will be handled by smt_meta.

; Redefine the literal types.
; Currently the only important thing to define is $smt_String.
(declare-const $smt_Numeral Type)
(declare-consts <numeral> $smt_Numeral)
(declare-const $smt_Rational Type)
(declare-consts <rational> $smt_Rational)
(declare-const $smt_String Type)
(declare-consts <string> $smt_String)
(declare-const $smt_Binary Type)
(declare-consts <binary> $smt_Binary)

; An SMT-LIB term.
(declare-const $smt_Term Type)

; A placeholder for a failed evaluation
(declare-const $smt_fail $smt_Term)

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_apply_1
  ((W1 Type :implicit))
  (-> $smt_String W1 $smt_Term))
(declare-parameterized-const $smt_apply_2
  ((W1 Type :implicit) (W2 Type :implicit))
  (-> $smt_String W1 W2 $smt_Term))
(declare-parameterized-const $smt_apply_3
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit))
  (-> $smt_String W1 W2 W3 $smt_Term))
(declare-parameterized-const $smt_apply_4
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit))
  (-> $smt_String W1 W2 W3 W4 $smt_Term))
(declare-parameterized-const $smt_apply_5
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit))
  (-> $smt_String W1 W2 W3 W4 W5 $smt_Term))

; Convert from Eunoia to an SMT value
; These assume the Eunoia term is a literal of the correct type.
; All uses of the $smt_from_eo_* methods must ensure this is the case
; Convert Eunoia Boolean to an smt Boolean.
(declare-const $smt_from_eo_bool (-> Bool $smt_Term))
; Convert Eunoia Numeral to an smt Integer.
(declare-const $smt_from_eo_z (-> $smt_Numeral $smt_Term))
; Convert Eunoia Rational to an smt Real.
(declare-const $smt_from_eo_q (-> $smt_Rational $smt_Term))
; Convert Eunoia String to an smt String.
(declare-const $smt_from_eo_str (-> $smt_String $smt_Term))
; Convert Eunoia Binary to an smt-meta representation of Binary.
(declare-const $smt_from_eo_bin (-> $smt_Binary $smt_Term))
; Convert smt2 term to a Eunoia Boolean.
(declare-const $smt_to_eo_bool (-> $smt_Term Bool))
; Convert smt2 term to a Eunoia numeral.
(declare-const $smt_to_eo_z (-> $smt_Term $smt_Numeral))
; Convert smt2 term to a Eunoia rational.
(declare-const $smt_to_eo_q (-> $smt_Term $smt_Rational))
; Convert smt2 term to a Eunoia string.
(declare-const $smt_to_eo_str (-> $smt_Term $smt_String))
; Convert smt2 term to a Eunoia binary.
(declare-const $smt_to_eo_bin (-> $smt_Term $smt_Binary))

; Testers that use lower level sm.Term datatype, both for simplicity and efficiency.
; These rely on "is sm.Numeral" referring to the SMT-LIB operator (_ is sm.Numeral)
; in the final encoding.
; Boolean relies on the $sm_is_Boolean define-fun in the SMT meta signature.
(define $smt_is_bool ((T Type :implicit) (t T)) ($smt_apply_1 "$sm_is_Boolean" t))
(define $smt_is_z ((T Type :implicit) (t T)) ($smt_apply_1 "is sm.Numeral" t))
(define $smt_is_q ((T Type :implicit) (t T)) ($smt_apply_1 "is sm.Rational" t))
(define $smt_is_str ((T Type :implicit) (t T)) ($smt_apply_1 "is sm.String" t))
(define $smt_is_bin ((T Type :implicit) (t T)) ($smt_apply_1 "is sm.Binary" t))
;
(define $smt_eo_is_bool ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_bool t)))
(define $smt_eo_is_z ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_z t)))
(define $smt_eo_is_q ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_q t)))
(define $smt_eo_is_str ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_str t)))
(define $smt_eo_is_bin ((T Type :implicit) (t T)) ($smt_to_eo_bool ($smt_is_bin t)))

;;; Boolean operators

; Apply SMT-LIB operator Boolean connective "op" to Eunoia terms x1 and x2.
; Return the Eunoia term.
(define $sm_eo_apply_bool_op_2 ((op $smt_String) (x1 Bool) (x2 Bool))
  ($smt_to_eo_bool ($smt_apply_2 op
    ($smt_from_eo_bool x1)
    ($smt_from_eo_bool x2))))

; An SMT-LIB formula corresponding to Eunoia terms being the binaries of the same width.
; Return the Eunoia term.
(define $smt_eo_is_bin_same_width ((x1 $smt_Binary) (x2 $smt_Binary))
  ($smt_to_eo_bool ($smt_apply_3 "and"
    ($smt_apply_1 "is sm.Binary" x1)
    ($smt_apply_1 "is sm.Binary" x2)
    ($smt_apply_2 "=" ($smt_apply_1 "sm.Binary.width" x1) ($smt_apply_1 "sm.Binary.width" x2)))))

; Apply SMT-meta operator "op" of arity 1, e.g. "$sm_Binary_not".
; Return the Eunoia term.
(define $sm_eo_apply_bin_op_1 ((op $smt_String) (x1 $smt_Binary))
  (eo::define ((w ($smt_apply_1 "sm.Binary.width" x1)))
  ($smt_apply_2 "$sm_Binary"
    ($smt_apply_2 op
      w
      ($smt_apply_1 "sm.Binary.val" x1))
    w)))

; Apply SMT-meta operator "op" of arity 2, e.g. "$sm_Binary_and".
; Return the Eunoia term.
(define $sm_eo_apply_bin_op_2 ((op $smt_String) (x1 $smt_Binary) (x2 $smt_Binary))
  (eo::define ((w ($smt_apply_1 "sm.Binary.width" x1)))
  ($smt_apply_2 "$sm_Binary"
    ($smt_apply_3 op
      w
      ($smt_apply_1 "sm.Binary.val" x1)
      ($smt_apply_1 "sm.Binary.val" x2))
    w)))

; axiom: $eo_not
(define $eo_not ((T Type :implicit) (x1 T))
  (eo::ite ($smt_is_bool x1)
    ($smt_to_eo_bool ($smt_apply_1 "not" ($smt_from_eo_bool x1)))
  (eo::ite ($smt_apply_1 "is sm.Binary" x1)
    ($sm_eo_apply_bin_op_1 "$sm_Binary_not" x1)
    $smt_fail)))

; axiom: $eo_and
(define $eo_and ((T Type :implicit) (x1 T) (x2 T))
  (eo::ite ($smt_apply_2 "and" ($smt_is_bool x1) ($smt_is_bool x2))
    ($sm_eo_apply_bool_op_2 "and" x1 x2)
  (eo::ite ($smt_eo_is_bin_same_width x1 x2)
    ($sm_eo_apply_bin_op_2 "$sm_Binary_and" x1 x2)
    $smt_fail)))

; axiom: $eo_or
(define $eo_or ((T Type :implicit) (x1 T) (x2 T))
  (eo::ite ($smt_apply_2 "and" ($smt_is_bool x1) ($smt_is_bool x2))
    ($sm_eo_apply_bool_op_2 "or" x1 x2)
  (eo::ite ($smt_eo_is_bin_same_width x1 x2)
    ($sm_eo_apply_bin_op_2 "$sm_Binary_or" x1 x2)
    $smt_fail)))

; axiom: $eo_xor
(define $eo_or ((T Type :implicit) (x1 T) (x2 T))
  (eo::ite ($smt_apply_2 "and" ($smt_is_bool x1) ($smt_is_bool x2))
    ($sm_eo_apply_bool_op_2 "xor" x1 x2)
  (eo::ite ($smt_eo_is_bin_same_width x1 x2)
    ($sm_eo_apply_bin_op_2 "$sm_Binary_xor" x1 x2)
    $smt_fail)))
