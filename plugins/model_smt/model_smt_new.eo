; This file defines SMT-LIB model semantics in Eunoia.
; The programs in this file operate on datatypes that correspond to
; a deep embedding of SMT-LIB values.
; In particular, we use the following types:
; 1. $smt_Value, the type of SMT-LIB values.
; 2. Further types defining specific SMT-LIB values, e.g. $smt_Map.

;;;;;; SMT terms

; An SMT term.
(declare-const $smt_Term Type)

; An SMT type.
(declare-const $smt_Type Type)

;;;;;; SMT term constructors

(declare-const $smd_sm.None $smt_Term)
(define $sm_none () $smd_sm.None)

; the literal types
(declare-parameterized-const $smd_sm.Boolean
  ((b $smt_builtin_Bool :opaque)) $smt_Term)
(define $sm_bool ((b $smt_builtin_Bool)) ($smd_sm.Boolean b))

(declare-parameterized-const $smd_sm.Numeral
  ((n $smt_builtin_Int :opaque)) $smt_Term)
(define $sm_numeral ((n $smt_builtin_Int)) ($smd_sm.Numeral n))
; helpers
(define $sm_z_zero () ($sm_numeral $smt_builtin_z_zero))
(define $sm_z_one () ($sm_numeral $smt_builtin_z_one))

(declare-parameterized-const $smd_sm.Rational
  ((r $smt_builtin_Rat :opaque)) $smt_Term)
(define $sm_rational ((r $smt_builtin_Rat)) ($smd_sm.Rational r))
; helpers
(define $sm_q_zero () ($sm_rational $smt_builtin_q_zero))

(declare-parameterized-const $smd_sm.String
  ((s $smt_builtin_String :opaque)) $smt_Term)
(define $sm_string ((s $smt_builtin_String)) ($smd_sm.String s))
; helpers
(define $sm_string_empty () ($smd_sm.String $smt_builtin_str_empty))
(define $sm_string_c0 () ($smd_sm.String ($smt_apply_0 """0""")))
(define $sm_string_c9 () ($smd_sm.String ($smt_apply_0 """9""")))

(declare-parameterized-const $smd_sm.Binary
  ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $smt_Term)
(define $sm_binary ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($smd_sm.Binary w v))
; helpers
(define $sm_binary_bit_false () ($sm_binary $smt_builtin_z_one $smt_builtin_z_zero))
(define $sm_binary_bit_true () ($sm_binary $smt_builtin_z_one $smt_builtin_z_one))

; An application of a Eunoia term
(declare-parameterized-const $smd_sm.Apply
  ((f $smt_Term :opaque) (a $smt_Term :opaque))
  $smt_Term)
(define $sm_apply ((x $smt_Term) (y $smt_Term)) ($smd_sm.Apply x y))

; Represents a SMT-LIB variable in the final deep embedding.
(declare-parameterized-const $smd_sm.Var
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque))
  $smt_Term)
(define $sm_Var ((s $smt_builtin_String) (T $smt_Type))
  ($smd_sm.Var s T))

; exists
(declare-parameterized-const $smd_sm.exists
  ((v $smt_Term :opaque) (F $smt_Term :opaque))
  $smt_Term)
(define $sm_exists ((v $smt_Term) (F $smt_Term))
  ($smd_sm.exists v F))

; forall
(declare-parameterized-const $smd_sm.forall
  ((v $smt_Term :opaque) (F $smt_Term :opaque))
  $smt_Term)
(define $sm_forall ((v $smt_Term) (F $smt_Term))
  ($smd_sm.forall v F))
  
; lambda
(declare-parameterized-const $smd_sm.lambda
  ((v $smt_Term :opaque) (t $smt_Term :opaque))
  $smt_Term)
(define $sm_lambda ((v $smt_Term) (t $smt_Term))
  ($smd_sm.lambda v t))

; all other ordinary term definitions
$SMT_TERM_CONSTRUCTORS$

;;;;;; SMT type constructors

(declare-const $smd_tsm.None $smt_Type)
(define $tsm_none () $smd_tsm.None)

; The Boolean type
(declare-const $smd_tsm.Bool $smt_Type)
(define $tsm_Bool () $smd_tsm.Bool)

; all other ordinary type definitions
$SMT_TYPE_CONSTRUCTORS$

;;;;;; SMT values

; An SMT-LIB value.
(declare-const $smt_Value Type)

; Assumes that veq is defined to be equality over $smt_Value
(define $smt_builtin_veq ((x1 $smt_Value) (x2 $smt_Value)) ($smt_apply_2 "veq" x1 x2))

; The type used to define values for functions, arrays and sets in SMT-LIB.
(declare-const $smt_Map Type)

; The type used to define values for sequences in SMT-LIB.
(declare-const $smt_Seq Type)

;;; SMT value datatype constructors

; the literal types
(declare-parameterized-const $smd_vsm.Boolean
  ((b $smt_builtin_Bool :opaque)) $smt_Value)
(define $vsm_bool ((b $smt_builtin_Bool)) ($smd_vsm.Boolean b))

(declare-parameterized-const $smd_vsm.Numeral
  ((n $smt_builtin_Int :opaque)) $smt_Value)
(define $vsm_numeral ((n $smt_builtin_Int)) ($smd_vsm.Numeral n))

(declare-parameterized-const $smd_vsm.Rational
  ((r $smt_builtin_Rat :opaque)) $smt_Value)
(define $vsm_rational ((r $smt_builtin_Rat)) ($smd_vsm.Rational r))

(declare-parameterized-const $smd_vsm.String
  ((s $smt_builtin_String :opaque)) $smt_Value)
(define $vsm_string ((s $smt_builtin_String)) ($smd_vsm.String s))

(declare-parameterized-const $smd_vsm.Binary
  ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $smt_Value)
(define $vsm_binary ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($smd_vsm.Binary w v))
; helpers
(define $vsm_binary_mod_w ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($smd_vsm.Binary w ($smt_builtin_mod v ($smtx_pow2 w))))
  
; A value denoting a map.
(declare-parameterized-const $smd_vsm.Map ((m $smt_Map :opaque)) $smt_Value)
(define $vsm_map ((m $smt_Map)) ($smd_vsm.Map m))

; A value denoting a sequence.
(declare-parameterized-const $smd_vsm.Seq ((s $smt_Seq :opaque)) $smt_Value)
(define $vsm_seq ((s $smt_Seq)) ($smd_vsm.Seq s))

; A value denoting a regular language.
(declare-parameterized-const $smd_vsm.RegLan ((r $smt_builtin_RegLan :opaque)) $smt_Value)
(define $vsm_re ((r $smt_builtin_RegLan)) ($smd_vsm.RegLan r))

; Apply values (for Herbrand interpretations).
(declare-parameterized-const $smd_vsm.Apply
  ((f $smt_Value :opaque) (a $smt_Value :opaque))
  $smt_Value)
(define $vsm_apply ((f $smt_Value) (a $smt_Value))
  ($smd_vsm.Apply f a))

; Denotes a failure case for values.
(declare-const $smd_vsm.NotValue $smt_Value)
(define $vsm_not_value () $smd_vsm.NotValue)

;;; SMT map value datatype constructors

; Constructs a map value where i is mapped to e.
(declare-parameterized-const $smd_msm.cons
  ((i $smt_Value :opaque) (e $smt_Value :opaque) (m $smt_Map :opaque))
  $smt_Map)
(define $msm_cons ((i $smt_Value) (e $smt_Value) (m $smt_Map))
  ($smd_msm.cons i e m))

; Constructs a map value where all indices are mapped to e.
(declare-parameterized-const $smd_msm.default
  ((e $smt_Value :opaque))
  $smt_Map)
(define $msm_default ((e $smt_Value)) ($smd_msm.default e))

;;; SMT sequence value datatype constructors

(declare-parameterized-const $smd_ssm.cons
  ((i $smt_Value :opaque) (s $smt_Seq :opaque))
  $smt_Seq)
(define $ssm_cons ((i $smt_Value) (s $smt_Seq)) ($smd_ssm.cons i s))

(declare-parameterized-const $smd_ssm.empty () $smt_Seq)
(define $ssm_empty () $smd_ssm.empty)

;;; Generic utilities

(define $vsm_true () ($vsm_bool $smt_builtin_true))
(define $vsm_false () ($vsm_bool $smt_builtin_false))

; define: $smtx_value_hash
; note: this is an arbitrary hash for SMT values, defined axiomatically.
(program $smtx_value_hash () :signature ($smt_Value) $smt_builtin_Int)
(program $smtx_reverse_value_hash () :signature ($smt_builtin_Int) $smt_Value)

; The SMT-LIB comparison of two SMT-LIB values.
(define $smtx_value_cmp ((a $smt_Value) (b $smt_Value))
  ($smt_builtin_z_<= ($smtx_value_hash a) ($smtx_value_hash b)))

; returns one of (v1,v2), preferring values to non-values
(program $smtx_value_either ((v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_value_either v1 $vsm_not_value) v1)
  (($smtx_value_either $vsm_not_value v2) v2)
  (($smtx_value_either v1 v2)             v1)
  )
)

;;; Map utilities

; Get the default for the map
(program $smtx_msm_get_default
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Map) $smt_Value
  (
  (($smtx_msm_get_default ($msm_cons j e m))  ($smtx_msm_get_default m))
  (($smtx_msm_get_default ($msm_default e))   e)
  )
)

; This program looks up the value of a term in a map.
; This is used for function evaluation.
(program $smtx_msm_lookup
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Map $smt_Value) $smt_Value
  (
  (($smtx_msm_lookup ($msm_cons j e m) i)  ($smt_builtin_ite ($smt_builtin_veq j i) e ($smtx_msm_lookup m i)))
  (($smtx_msm_lookup ($msm_default e) i)   e)
  )
)

; updates the map with a new entry, maintaining ordered-ness
(program $smtx_msm_update
  ((i $smt_Value) (j $smt_Value) (e1 $smt_Value) (e2 $smt_Value) (m $smt_Map))
  :signature ($smt_Map $smt_Value $smt_Value) $smt_Map
  (
  ; we overwrite if same index
  (($smtx_msm_update ($msm_cons i e1 m) i e2) ($msm_cons i e2 m))
  ; otherwise, we check the hash to retain sortedness
  (($smtx_msm_update ($msm_cons j e1 m) i e2) ($smt_builtin_ite ($smtx_value_cmp j i)
                                                ($msm_cons i e2 ($msm_cons j e1 m))
                                                ($msm_cons j e1 ($smtx_msm_update m i e2))))
  ; we are redundant wrt the default value
  (($smtx_msm_update ($msm_default e1) i e1)  ($msm_default e1))
  ; ensures totality, we are a non-redundant update of the default map
  (($smtx_msm_update m i e2)                  ($msm_cons i e2 m))
  )
)

; Returns the first index of m1 that is mapped to a different value in m2.
; If no such value exists, return $vsm_not_value.
(program $smtx_msm_find_diff
  ((i $smt_Value) (e $smt_Value) (m1 $smt_Map) (m2 $smt_Map))
  :signature ($smt_Map $smt_Map) $smt_Value
  (
  (($smtx_msm_find_diff ($msm_default e) m2)    $vsm_not_value)
  (($smtx_msm_find_diff ($msm_cons i e m1) m2)
    ; Lookup the current index, if it different, return this index.
    ($smt_builtin_ite
      ($smt_builtin_veq ($smtx_msm_lookup m2 i) e)
      ($smtx_msm_find_diff m1 m2)
      i))
  )
)

;;; Map as sets

; A set is a mapping to Bool.
; The empty set maps all to false.
(define $msm_empty_set () ($msm_default $vsm_false))
; Inserting sets e to true.
(define $smtx_mss_mk_insert ((e $smt_Value) (m $smt_Map)) ($smtx_msm_update m e $vsm_true))
(define $smtx_mss_insert ((e $smt_Value) (m $smt_Map)) ($msm_cons e $vsm_true m))
(define $smtx_mss_member ((e $smt_Value) (m $smt_Map))
  ($smt_builtin_veq ($smtx_msm_lookup m e) $vsm_true))

; Helper for computing binary set operators.
(program $smtx_mss_op_internal
  ((m1 $smt_Map) (m2 $smt_Map) (acc $smt_Map) (e $smt_Value) (isInter $smt_builtin_Bool))
  :signature ($smt_builtin_Bool $smt_Map $smt_Map $smt_Map) $smt_Map
  (
  (($smtx_mss_op_internal isInter $msm_empty_set m2 acc) acc)
  (($smtx_mss_op_internal isInter ($smtx_mss_insert e m1) m2 acc)
    ($smtx_mss_op_internal isInter m1 m2
      ($smt_builtin_ite
        ($smt_builtin_iff ($smtx_mss_member e m2) isInter)
        ($smtx_mss_mk_insert e acc)
        acc)))
  )
)

;;; Utilities for Sequence values

(program $smtx_ssm_seq_nth ((v $smt_Value) (vs $smt_Seq) (n $smt_builtin_Int))
  :signature ($smt_Seq $smt_builtin_Int) $smt_Value
  (
  (($smtx_ssm_seq_nth $ssm_empty n)                           $vsm_not_value)
  (($smtx_ssm_seq_nth ($ssm_cons v vs) $smt_builtin_z_zero)   v)
  (($smtx_ssm_seq_nth ($ssm_cons v vs) n)
    ($smtx_ssm_seq_nth vs ($smt_builtin_z_dec n)))
  )
)

; Converts a $smt_Seq to a (Seq $smt_Value).
(program $smtx_ssm_seq_to_smt_seq ((v $smt_Value) (vs $smt_Seq))
  :signature ($smt_Seq) ($smt_builtin_type_1 "Seq" $smt_Value)
  (
  (($smtx_ssm_seq_to_smt_seq $ssm_empty)
    ($smt_apply_0 "(as seq.empty (Seq vsm.Value))"))
  (($smtx_ssm_seq_to_smt_seq ($ssm_cons v vs))
    ($smt_apply_2 "seq.++" v ($smtx_ssm_seq_to_smt_seq vs)))
  )
)

; Converts a (Seq $smt_Value) to a $smt_Seq
;(program $smtx_smt_seq_to_ssm_seq ((s ($smt_builtin_type_1 "Seq" $smt_Value)))
;  :signature (($smt_builtin_type_1 "Seq" $smt_Value)) $smt_Seq
;  (
;  (($smtx_smt_seq_to_ssm_seq s)
;    (eo::define ((lens ($smt_apply_2 "seq.len" s)))
;    ($smt_builtin_ite
;      ($smt_builtin_= lens $smt_builtin_z_zero)
;      $ssm_empty
;      ($ssm_cons
;        ($smt_apply_3 "seq.substr" s $smt_builtin_z_zero $smt_builtin_z_one)
;        ($smtx_smt_seq_to_ssm_seq
;          ($smt_apply_3 "seq.substr" s $smt_builtin_z_one lens))))))
;  )
;)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Model semantics

; Forward declaration of the main method defined by this signature.
; We use this to define $eo_model_sat.
(program $smtx_model_eval () :signature ($smt_Term) $smt_Value)

;;; Core

; program: $smtx_model_eval_apply
; We call ($smtx_model_eval_apply value_f value_i) when
; evaluating (f i) whose values are value_f and value_i
; respectively. If value_f is a map value, then we extract
; the map and call the map lookup routine.
(program $smtx_model_eval_apply
  ((m $smt_Map) (i $smt_Value) (f $smt_Value) (v $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  ; If a Herbrand interpretation, apply it to the next value.
  (($smtx_model_eval_apply ($vsm_apply f v) i)  ($vsm_apply ($vsm_apply f v) i))
  ; The function evaluated to a map value, call the map lookup.
  (($smtx_model_eval_apply ($vsm_map m) i)      ($smtx_msm_lookup m i))
  ; The function did not evaluate to a map value, we fail.
  (($smtx_model_eval_apply v i)                 $vsm_not_value)
  )
)

; ITE branches to the appropriate child.
; return: The evaluation of an ite application.
(program $smtx_model_eval_ite
  ((t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_ite $vsm_true t2 t3)   t2)
  (($smtx_model_eval_ite $vsm_false t2 t3)  t3)
  (($smtx_model_eval_ite t1 t2 t3)          $vsm_not_value)
  )
)

; Equality insists on valueness and then reduces to an equality over datatypes
; in the deep embedding (vsm.Value), meaning it works for all types, including
; functions and uninterpreted sorts where values are not represented by terms.
; Note that the valueness predicate ensures this is sound. Moreover note that
; we do not invoke the type checker here. This means that if an ill-typed
; equality was given as input to this method, it would always evaluate to false.
; The caller of this method is responsible for ensuring that this behavior is
; either avoided or admissible.
; return: The evaluation of an equality application.
(program $smtx_model_eval_=
  ((t1 $smt_Value) (t2 $smt_Value)
   (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)
   (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int)
   (r1 $smt_builtin_Real) (r2 $smt_builtin_Real)
   (s1 $smt_builtin_String) (s2 $smt_builtin_String)
  )
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_= ($vsm_bool b1) ($vsm_bool b2))
    ($vsm_bool ($smt_builtin_iff b1 b2)))
  (($smtx_model_eval_= ($vsm_bool b1) t2) $vsm_not_value)
  (($smtx_model_eval_= t1 ($vsm_bool b2)) $vsm_not_value)
  (($smtx_model_eval_= ($vsm_numeral n1) ($vsm_numeral n2))
    ($vsm_bool ($smt_builtin_z_= n1 n2)))
  (($smtx_model_eval_= ($vsm_numeral n1) t2) $vsm_not_value)
  (($smtx_model_eval_= t1 ($vsm_numeral n2)) $vsm_not_value)
  (($smtx_model_eval_= ($vsm_rational r1) ($vsm_rational r2))
    ($vsm_bool ($smt_builtin_q_= r1 r2)))
  (($smtx_model_eval_= ($vsm_rational r1) t2) $vsm_not_value)
  (($smtx_model_eval_= t1 ($vsm_rational r2)) $vsm_not_value)
  (($smtx_model_eval_= ($vsm_string s1) ($vsm_string s2))
    ($vsm_bool ($smt_builtin_veq ($vsm_string s1) ($vsm_string s2))))
  (($smtx_model_eval_= ($vsm_string s1) t2) $vsm_not_value)
  (($smtx_model_eval_= t1 ($vsm_string s2)) $vsm_not_value)
  (($smtx_model_eval_= ($vsm_binary w1 n1) ($vsm_binary w2 n2))
    ; note that we know that w1, w2 are legal by invariant on model eval
    ($smt_builtin_ite ($smt_builtin_z_= w1 w2)
      ($vsm_bool ($smt_builtin_veq ($vsm_binary w1 n1) ($vsm_binary w2 n2)))
      $vsm_not_value))
  (($smtx_model_eval_= ($vsm_binary w1 n1) t2) $vsm_not_value)
  (($smtx_model_eval_= t1 ($vsm_binary w2 n2)) $vsm_not_value)
  ; TODO: datatype values, others?
  (($smtx_model_eval_= $vsm_not_value t2) $vsm_not_value)
  (($smtx_model_eval_= t1 $vsm_not_value) $vsm_not_value)
  ; use datatype equality over $smt_Value, which depends on t1 and t2 being proper values.
  (($smtx_model_eval_= t1 t2)             ($vsm_bool ($smt_builtin_veq t1 t2)))
  )
)

;;; Functions, arrays

; Array select
(program $smtx_map_select
  ((v $smt_Value) (i $smt_Value) (m $smt_Map))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_select ($vsm_map m) i) ($smtx_msm_lookup m i))
  (($smtx_map_select v i)              $vsm_not_value)
  )
)

; Array store
(program $smtx_map_store
  ((v $smt_Value) (i $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_store ($vsm_map m) i e) ($vsm_map ($smtx_msm_update m i e)))
  (($smtx_map_store v i e)            $vsm_not_value)
  )
)

; Array diff
; Returns the value where m1 and m2 differ, or $vsm_not_value otherwise.
(program $smtx_map_diff ((m1 $smt_Map) (m2 $smt_Map))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_diff ($vsm_map m1) ($vsm_map m2))
    ; find an index in the first that conflicts with the second, or vice versa
    ($smtx_value_either ($smtx_msm_find_diff m1 m2) ($smtx_msm_find_diff m2 m1)))
  )
)

;;; Sets

; Empty set
(define $smtx_empty_set () ($vsm_map $msm_empty_set))

; Set singleton
; return the singleton set whose type is T and contains e.
(define $smtx_set_singleton ((e $smt_Value))
  ($vsm_map ($smtx_mss_insert e $msm_empty_set)))

; Set intersection
; return the intersection of two set values.
(program $smtx_set_inter
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_inter ($vsm_map m1) ($vsm_map m2))
    ; m1 intersected m2 starting with empty set.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_true m1 m2 $msm_empty_set)))
  (($smtx_set_inter v1 v2)  $vsm_not_value)
  )
)

; Set minus
; return the set minus of two set values.
(program $smtx_set_minus
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_minus ($vsm_map m1) ($vsm_map m2))
    ; m1 minus m2 starting with empty set.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_false m1 m2 $msm_empty_set)))
  (($smtx_set_minus v1 v2)  $vsm_not_value)
  )
)

; Set union
; return the union of two set values.
(program $smtx_set_union
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_union ($vsm_map m1) ($vsm_map m2))
    ; m1 minus the empty set starting with m2.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_false m1 $msm_empty_set m2)))
  (($smtx_set_union v1 v2)  $vsm_not_value)
  )
)

;;; Sequences

; Empty sequence
(define $smtx_empty_seq () ($vsm_seq $ssm_empty))

; Sequence unit
(define $smtx_seq_unit ((e $smt_Value)) ($vsm_seq ($ssm_cons e $ssm_empty)))

; Sequence nth
(program $smtx_seq_nth
  ((s $smt_Seq) (n $smt_builtin_Int) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_seq_nth ($vsm_seq s) ($vsm_numeral n)) ($smtx_ssm_seq_nth s n))
  (($smtx_seq_nth v1 v2) $vsm_not_value)
  )
)

;;; Other model evaluation functions

$SMT_EVAL_PROGS$

; An evaluator for all terms that we can reason about models.
; This is a recursive call.
; invariant: this must be a total function
; invariant: unless this method returns $vsm_not_value, it must be such that
;            it represents a unique SMT-LIB value, i.e. ($vsm_term t) is
;            forbidden unless t denotes a value.
(program $smtx_model_eval
  ((f $smt_Term) (y $smt_Term) (z $smt_Term) (val $smt_Value) (T $smt_Term)
  (b $smt_builtin_Bool) (w $smt_builtin_Int) (n $smt_builtin_Int) (r $smt_builtin_Real) (s $smt_builtin_String)
   ; generic parameters that may appear in terms to pattern match
   (x1 $smt_Term) (x2 $smt_Term) (x3 $smt_Term) (x4 $smt_Term) (x5 $smt_Term))
  :signature ($smt_Term) $smt_Value
  (

  (($smtx_model_eval ($sm_bool b))      ($vsm_bool b))
  (($smtx_model_eval ($sm_numeral n))   ($vsm_numeral n))
  (($smtx_model_eval ($sm_rational r))  ($vsm_rational r))
  (($smtx_model_eval ($sm_string s))    ($vsm_string s))
  (($smtx_model_eval ($sm_binary w n))
    ; must be legal width and value
    ($smt_builtin_ite 
      ($smt_builtin_and
        ($smt_builtin_z_<= $smt_builtin_z_zero w)
        ($smt_builtin_z_= n ($smt_builtin_mod n ($smtx_pow2 w))))
      ($vsm_binary w n)
      $vsm_not_value))
  ; evaluation of standard SMT symbols
  ; These calls will reference helper methods above, e.g. of the form
  ; $smtx_model_eval_*, or call builtin methods e.g. $smtx_eval_exists_rec.
$SMT_EVAL_CASES$

  ; Apply case. We evaluate f and y separately and then call the
  ; $smtx_model_eval_apply above. We expect f to be an uninterpreted
  ; function whose model evaluation is an SMT-LIB map in this case.
  ; All interpreted f should be handled in the evaluation cases above.
  (($smtx_model_eval ($sm_apply f y))
    ($smtx_model_eval_apply ($smtx_model_eval f) ($smtx_model_eval y)))
  (($smtx_model_eval y)   $vsm_not_value)
  )
)


;;;;;;;;;;;;;;;;;;;;;;

(program $eo_to_smt_type 
  ((T Type) (n1 $smt_builtin_Int) 
  (T1 Type) (T2 Type) (T3 Type) (T4 Type) (T5 Type)
  (x1 T1) (x2 T2) (x3 T3) (x4 T4) (x5 T5))
  :signature (Type) $smt_Type
  (
  (($eo_to_smt_type Bool) $tsm_Bool)
$EO_TO_SMT_TYPE_CASES$
  (($eo_to_smt_type T)    $tsm_none)
  )
)

(program $eo_to_smt 
  ((b $smt_builtin_Bool) (n $smt_builtin_Int) (r $smt_builtin_Rat)
   (s $smt_builtin_String) (w $smt_builtin_Int)
   (T Type) (U Type) (T1 Type) (T2 Type) (T3 Type) (T4 Type) (T5 Type)
   (f (-> U T)) (y U) (x1 T1) (x2 T2) (x3 T3) (x4 T4) (x5 T5))
  :signature (T) $smt_Term
  (
  (($eo_to_smt ($eo_bool b))      ($sm_bool b))
  (($eo_to_smt ($eo_numeral n))   ($sm_numeral n))
  (($eo_to_smt ($eo_rational r))  ($sm_rational r))
  (($eo_to_smt ($eo_string s))    ($sm_string s))
  (($eo_to_smt ($eo_binary w n))  ($sm_binary w n))
  (($eo_to_smt ($eo_Var s T))     ($sm_Var s ($eo_to_smt_type T)))
$EO_TO_SMT_CASES$
  (($eo_to_smt (f y))             ($sm_apply ($eo_to_smt f) ($eo_to_smt y)))
  (($eo_to_smt y)                 $sm_none)
  )
)

; program: $eo_model_sat
; note: F is satisfied by the model if F evaluates to the SMT-LIB value denoting true.
; We expect the input to this method to be a Eunoia term denoting an SMT-LIB formula
; (term of Boolean type).
(program $eo_model_sat ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_sat F) ($smt_builtin_ite ($smt_builtin_veq ($smtx_model_eval ($eo_to_smt F)) $vsm_true) true false))
  )
)
(program $eo_model_unsat ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_unsat F) ($smt_builtin_ite ($smt_builtin_veq ($smtx_model_eval ($eo_to_smt F)) $vsm_false) true false))
  )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_end
