; This file defines SMT-LIB model semantics in Eunoia.
; The programs in this file operate on datatypes that correspond to
; a deep embedding of SMT-LIB values.
; In particular, we use the following types:
; 1. $smt_Value, the type of SMT-LIB values.
; 2. Further types defining specific SMT-LIB values, e.g. $smt_Map.

;;;;;; SMT terms

; An SMT-LIB value.
(declare-const $smt_Value Type)

; utilities
; Assumes that veq is defined to be equality over $smt_Value
(define $smt_builtin_veq ((x1 $smt_Value) (x2 $smt_Value)) ($smt_apply_2 "veq" x1 x2))

;;;;;; SMT term constructors

(declare-const $emb_sm.None $smt_Term)
(define $sm_none () $emb_sm.None)

; the literal types
(declare-parameterized-const $emb_sm.Boolean
  ((b $smt_builtin_Bool :opaque)) $smt_Term)
(define $sm_bool ((b $smt_builtin_Bool)) ($emb_sm.Boolean b))

(declare-parameterized-const $emb_sm.Numeral
  ((n $smt_builtin_Int :opaque)) $smt_Term)
(define $sm_numeral ((n $smt_builtin_Int)) ($emb_sm.Numeral n))
; helpers
(define $sm_z_zero () ($sm_numeral $smt_builtin_z_zero))
(define $sm_z_one () ($sm_numeral $smt_builtin_z_one))

(declare-parameterized-const $emb_sm.Rational
  ((r $smt_builtin_Rat :opaque)) $smt_Term)
(define $sm_rational ((r $smt_builtin_Rat)) ($emb_sm.Rational r))
; helpers
(define $sm_q_zero () ($sm_rational $smt_builtin_q_zero))

(declare-parameterized-const $emb_sm.String
  ((s $smt_builtin_String :opaque)) $smt_Term)
(define $sm_string ((s $smt_builtin_String)) ($emb_sm.String s))
; helpers
(define $sm_string_empty () ($emb_sm.String $smt_builtin_str_empty))
(define $sm_string_c0 () ($emb_sm.String ($smt_apply_0 """0""")))
(define $sm_string_c9 () ($emb_sm.String ($smt_apply_0 """9""")))

(declare-parameterized-const $emb_sm.Binary
  ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $smt_Term)
(define $sm_binary ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($emb_sm.Binary w v))
; helpers
(define $sm_binary_bit_false () ($sm_binary $smt_builtin_z_one $smt_builtin_z_zero))
(define $sm_binary_bit_true () ($sm_binary $smt_builtin_z_one $smt_builtin_z_one))

; An application of a Eunoia term
(declare-parameterized-const $emb_sm.Apply
  ((f $smt_Term :opaque) (a $smt_Term :opaque))
  $smt_Term)
(define $sm_apply ((x $smt_Term) (y $smt_Term)) ($emb_sm.Apply x y))

; Represents a SMT-LIB variable in the final deep embedding.
(declare-parameterized-const $emb_sm.Var
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque))
  $smt_Term)
(define $sm_Var ((s $smt_builtin_String) (T $smt_Type)) ($emb_sm.Var s T))

; exists
; this takes the variable to quantify over, which should then be applied
; to a formula, similarly for the other quantifiers
(declare-parameterized-const $emb_sm.exists
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque)) $smt_Term)
(define $sm_exists ((s $smt_builtin_String) (T $smt_Type)) ($emb_sm.exists s T))

; forall
(declare-parameterized-const $emb_sm.forall
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque)) $smt_Term)
(define $sm_forall ((s $smt_builtin_String) (T $smt_Type)) ($emb_sm.forall s T))
  
; lambda
(declare-parameterized-const $emb_sm.lambda
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque)) $smt_Term)
(define $sm_lambda ((s $smt_builtin_String) (T $smt_Type)) ($emb_sm.lambda s T))

; the ci^th constructor of datatype ($tsm_Datatype s d).
(declare-parameterized-const $emb_sm.DtCons
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque)
   (ci $smt_builtin_Int :opaque)) 
  $smt_Term)
(define $sm_DtCons 
  ((s $smt_builtin_String) (d $smt_Datatype) (ci $smt_builtin_Int))
  ($emb_sm.DtCons s d ci))

; The selector of the ai^th argument of the ci^th constructor of datatype
; ($tsm_Datatype s d).
(declare-parameterized-const $emb_sm.DtSel
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque) 
   (ci $smt_builtin_Int :opaque) (ai $smt_builtin_Int :opaque))
  $smt_Term)
(define $sm_DtSel 
  ((s $smt_builtin_String) (d $smt_Datatype)
   (ci $smt_builtin_Int) (ai $smt_builtin_Int))
  ($emb_sm.DtSel s d ci ai))

; the tester of the ci^th constructor of datatype ($tsm_Datatype s d).
(declare-parameterized-const $emb_sm.DtTester
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque) (ci $smt_builtin_Int :opaque))
  $smt_Term)
(define $sm_DtTester ((s $smt_builtin_String) (d $smt_Datatype) (ci $smt_builtin_Int))
  ($emb_sm.DtTester s d ci))
  
; the updater of the ai^th argument of the ci^th constructor of datatype ($tsm_Datatype s d).
(declare-parameterized-const $emb_sm.DtUpdater
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque)
   (ci $smt_builtin_Int :opaque) (ai $smt_builtin_Int :opaque))
  $smt_Term)
(define $sm_DtUpdater
  ((s $smt_builtin_String) (d $smt_Datatype) (ci $smt_builtin_Int) (ai $smt_builtin_Int))
  ($emb_sm.DtUpdater s d ci ai))

; constants, which carry their value in the model
(declare-parameterized-const $emb_sm.Const ((v $smt_Value :opaque)) $smt_Term)
(define $sm_Const ((v $smt_Value)) ($emb_sm.Const v))

; all other ordinary term definitions
$SMT_TERM_CONSTRUCTORS$

;;;;;; SMT type constructors

(declare-const $emb_tsm.None $smt_Type)
(define $tsm_none () $emb_tsm.None)

; The Boolean type
(declare-const $emb_tsm.Bool $smt_Type)
(define $tsm_Bool () $emb_tsm.Bool)

; The Integer type
(declare-const $emb_tsm.Int $smt_Type)
(define $tsm_Int () $emb_tsm.Int)

; The Real type
(declare-const $emb_tsm.Real $smt_Type)
(define $tsm_Real () $emb_tsm.Real)

; The String type
(declare-const $emb_tsm.String $smt_Type)
(define $tsm_String () $emb_tsm.String)

; The RegLan type
(declare-const $emb_tsm.RegLan $smt_Type)
(define $tsm_RegLan () $emb_tsm.RegLan)

; The Bitvector type
(declare-parameterized-const $emb_tsm.BitVec ((w $smt_builtin_Int :opaque)) $smt_Type)
(define $tsm_BitVec ((w $smt_builtin_Int)) ($emb_tsm.BitVec w))

; The Map type
(declare-parameterized-const $emb_tsm.Map ((Ti $smt_Type :opaque) (Te $smt_Type :opaque)) $smt_Type)
(define $tsm_Map ((Ti $smt_Type) (Te $smt_Type)) ($emb_tsm.Map Ti Te))

; The type of partially applied datatype constructors
(declare-parameterized-const $emb_tsm.DtCons
  ((Ti $smt_Type :opaque) (Te $smt_Type :opaque))
  $smt_Type)
(define $tsm_DtCons ((Ti $smt_Type) (Te $smt_Type)) ($emb_tsm.DtCons Ti Te))

; The Sequence type
(declare-parameterized-const $emb_tsm.Seq ((T $smt_Type :opaque)) $smt_Type)
(define $tsm_Seq ((T $smt_Type)) ($emb_tsm.Seq T))

; A datatype is a type containing (1) its name, and (2) its structure.
; Its name can be understood as a binder under which ($tsm_TypeRef <name>) is
; a recursive reference to the (most recently bound) instance of a datatype
; with the given name.
; For example, the recursive datatype for a list of integers:
; (declare-datatype List ((cons (head Int) (tail List)) (nil)))
; Would have the following syntax:
; ($tsm_Datatype "List" d)
; Where d is the datatype spec:
; ($dt_sum
;   ($dtc_cons $tsm_Int ($dtc_cons ($tsm_TypeRef "List") $dtc_unit)) ; cons
;   ($dt_sum
;      $dtc_unit ; nil
;      $dt_null))
; Note that names of constructors and selectors are not represented in the AST.
; To express constructor terms, we give an index, such that cons/nil are terms:
;   ($sm_DtCons "List" d 0), ($sm_DtCons "List" d 1).
; The selectors head/tail for this datatype give indices to the constructor
; and argument position they refer to:
;   ($sm_DtSel "List" d 0 0) ($sm_DtSel "List" d 0 1).
; Note this also permits mutual recursion, e.g. for SMT datatype:
; (declare-datatypes ((List 0) (Tree 0))
;   (((cons (head Tree) (tail List)) (nil))
;    ((node (children List)) (leaf))))
; this is represented as:
; (eo::define ((Tree
;    ($tsm_Datatype "Tree"
;      ($dt_sum 
;        ($dtc_cons ($tsm_TypeRef "List") $dtc_unit) ; node
;        ($dt_sum
;          $dtc_unit ; leaf
;          $dt_null)))))
;   ($tsm_Datatype "List"
;      ($dt_sum
;        ($dtc_cons Tree ($dtc_cons ($tsm_TypeRef "List") $dtc_unit)) ; cons
;        ($dt_sum 
;           $dtc_unit ; nil
;           $dt_null))))
(declare-parameterized-const $emb_tsm.Datatype 
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque)) $smt_Type)
(define $tsm_Datatype ((s $smt_builtin_String) (d $smt_Datatype))
  ($emb_tsm.Datatype s d))
  
(declare-parameterized-const $emb_tsm.TypeRef
  ((s $smt_builtin_String :opaque)) $smt_Type)
(define $tsm_TypeRef ((s $smt_builtin_String)) ($emb_tsm.TypeRef s))
; utilites

; all other ordinary type definitions
$SMT_TYPE_CONSTRUCTORS$

;;;;;; SMT values

; The type used to define values for functions, arrays and sets in SMT-LIB.
(declare-const $smt_Map Type)

; The type used to define values for sequences in SMT-LIB.
(declare-const $smt_Seq Type)

;;; SMT value datatype constructors

; Denotes a failure case for values.
(declare-const $emb_vsm.NotValue $smt_Value)
(define $vsm_not_value () $emb_vsm.NotValue)

; the literal types
(declare-parameterized-const $emb_vsm.Boolean
  ((b $smt_builtin_Bool :opaque)) $smt_Value)
(define $vsm_bool ((b $smt_builtin_Bool)) ($emb_vsm.Boolean b))
; temporary
(program $mk_vsm_bool ((b $smt_builtin_Bool)) 
  :signature ($smt_builtin_Bool) $smt_Value
  (
  (($mk_vsm_bool b) ($vsm_bool b))
  )
)

(declare-parameterized-const $emb_vsm.Numeral
  ((n $smt_builtin_Int :opaque)) $smt_Value)
(define $vsm_numeral ((n $smt_builtin_Int)) ($emb_vsm.Numeral n))

(declare-parameterized-const $emb_vsm.Rational
  ((r $smt_builtin_Rat :opaque)) $smt_Value)
(define $vsm_rational ((r $smt_builtin_Rat)) ($emb_vsm.Rational r))

(declare-parameterized-const $emb_vsm.String
  ((s $smt_builtin_String :opaque)) $smt_Value)
(define $vsm_string ((s $smt_builtin_String)) ($emb_vsm.String s))

(declare-parameterized-const $emb_vsm.Binary
  ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $smt_Value)
(define $vsm_binary ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($emb_vsm.Binary w v))
; utilities
(define $vsm_binary_mod_w ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($emb_vsm.Binary w ($smt_builtin_mod v ($smtx_pow2 w))))
(define $vsm_mk_binary ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($smt_builtin_ite ($smt_builtin_z_<= $smt_builtin_z_zero w)
    ($vsm_binary_mod_w w v)
    $vsm_not_value))
  
; A value denoting a map.
(declare-parameterized-const $emb_vsm.Map ((m $smt_Map :opaque)) $smt_Value)
(define $vsm_map ((m $smt_Map)) ($emb_vsm.Map m))

; A value denoting a sequence.
(declare-parameterized-const $emb_vsm.Seq ((s $smt_Seq :opaque)) $smt_Value)
(define $vsm_seq ((s $smt_Seq)) ($emb_vsm.Seq s))

; A value denoting a regular language.
(declare-parameterized-const $emb_vsm.RegLan ((r $smt_builtin_RegLan :opaque)) $smt_Value)
(define $vsm_re ((r $smt_builtin_RegLan)) ($emb_vsm.RegLan r))

; A value denoting a lambda.
(declare-parameterized-const $emb_vsm.Lambda 
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque) (t $smt_Term :opaque)) $smt_Value)
(define $vsm_lambda 
  ((s $smt_builtin_String) (T $smt_Type) (t $smt_Term)) 
  ($emb_vsm.Lambda s T t))

; A constructor value
(declare-parameterized-const $emb_vsm.DtCons
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque) (ci $smt_builtin_Int :opaque))
  $smt_Value)
(define $vsm_DtCons ((s $smt_builtin_String) (d $smt_Datatype) (ci $smt_builtin_Int))
  ($emb_vsm.DtCons s d ci))
  
; Apply values (for Herbrand interpretations).
(declare-parameterized-const $emb_vsm.Apply
  ((f $smt_Value :opaque) (a $smt_Value :opaque))
  $smt_Value)
(define $vsm_apply ((f $smt_Value) (a $smt_Value))
  ($emb_vsm.Apply f a))
; utilities
(program $vsm_apply_head ((f $smt_Value) (a $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($vsm_apply_head ($vsm_apply f a)) ($vsm_apply_head f))
  (($vsm_apply_head a)                a)
  )
)
(program $vsm_apply_arg_nth ((f $smt_Value) (a $smt_Value) (n $smt_builtin_Int))
  :signature ($smt_Value $smt_builtin_Int) $smt_Value
  (
  (($vsm_apply_arg_nth ($vsm_apply f a) n)
    ($smt_builtin_ite ($smt_builtin_z_= n $smt_builtin_z_zero)
      a
      ($vsm_apply_arg_nth f ($smt_builtin_z_dec n))))
  (($vsm_apply_arg_nth a n) $vsm_not_value)
  )
)

;;; SMT map value datatype constructors

; Constructs a map value where i is mapped to e.
(declare-parameterized-const $emb_msm.cons
  ((i $smt_Value :opaque) (e $smt_Value :opaque) (m $smt_Map :opaque))
  $smt_Map)
(define $msm_cons ((i $smt_Value) (e $smt_Value) (m $smt_Map))
  ($emb_msm.cons i e m))

; Constructs a map value where all indices are mapped to e.
(declare-parameterized-const $emb_msm.default
  ((T $smt_Type :opaque) (e $smt_Value :opaque))
  $smt_Map)
(define $msm_default ((T $smt_Type) (e $smt_Value)) ($emb_msm.default T e))

;;; SMT sequence value datatype constructors

(declare-parameterized-const $emb_ssm.cons
  ((i $smt_Value :opaque) (s $smt_Seq :opaque))
  $smt_Seq)
(define $ssm_cons ((i $smt_Value) (s $smt_Seq)) ($emb_ssm.cons i s))

(declare-parameterized-const $emb_ssm.empty ((T $smt_Type :opaque)) $smt_Seq)
(define $ssm_empty ((T $smt_Type)) ($emb_ssm.empty T))

;;; Generic utilities

(define $vsm_true () ($vsm_bool $smt_builtin_true))
(define $vsm_false () ($vsm_bool $smt_builtin_false))

; define: $smtx_value_hash
; note: this is an arbitrary hash for SMT values, defined axiomatically.
(program $smtx_value_hash () :signature ($smt_Value) $smt_builtin_Int)
(program $smtx_reverse_value_hash () :signature ($smt_builtin_Int) $smt_Value)

; The SMT-LIB comparison of two SMT-LIB values.
(define $smtx_value_cmp ((a $smt_Value) (b $smt_Value))
  ($smt_builtin_z_<= ($smtx_value_hash a) ($smtx_value_hash b)))

; returns one of (v1,v2), preferring values to non-values
(program $smtx_value_either ((v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_value_either v1 $vsm_not_value) v1)
  (($smtx_value_either $vsm_not_value v2) v2)
  (($smtx_value_either v1 v2)             v1)
  )
)

; forward declaration
(program $smtx_typeof_value () :signature ($smt_Value) $smt_Type)

;;; Map utilities

; Get the default for the map
(program $smtx_msm_get_default
  ((T $smt_Type) (i $smt_Value) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Map) $smt_Value
  (
  (($smtx_msm_get_default ($msm_cons j e m))  ($smtx_msm_get_default m))
  (($smtx_msm_get_default ($msm_default T e)) e)
  )
)

; This program looks up the value of a term in a map.
; This is used for function evaluation.
(program $smtx_msm_lookup
  ((T $smt_Type) (i $smt_Value) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Map $smt_Value) $smt_Value
  (
  (($smtx_msm_lookup ($msm_cons j e m) i)  ($smt_builtin_ite ($smt_builtin_veq j i) e ($smtx_msm_lookup m i)))
  (($smtx_msm_lookup ($msm_default T e) i) e)
  )
)

; updates the map with a new entry, maintaining ordered-ness
(program $smtx_msm_update
  ((T $smt_Type) (i $smt_Value) (j $smt_Value) (e1 $smt_Value) (e2 $smt_Value) (m $smt_Map))
  :signature ($smt_Map $smt_Value $smt_Value) $smt_Map
  (
  ; we overwrite if same index
  (($smtx_msm_update ($msm_cons i e1 m) i e2) ($msm_cons i e2 m))
  ; otherwise, we check the hash to retain sortedness
  (($smtx_msm_update ($msm_cons j e1 m) i e2) ($smt_builtin_ite ($smtx_value_cmp j i)
                                                ($msm_cons i e2 ($msm_cons j e1 m))
                                                ($msm_cons j e1 ($smtx_msm_update m i e2))))
  ; we are redundant wrt the default value
  (($smtx_msm_update ($msm_default T e1) i e1)  ($msm_default T e1))
  ; ensures totality, we are a non-redundant update of the default map
  (($smtx_msm_update m i e2)                    ($msm_cons i e2 m))
  )
)

; Returns the first index of m1 that is mapped to a different value in m2.
; If no such value exists, return $vsm_not_value.
(program $smtx_msm_find_diff
  ((T $smt_Type) (i $smt_Value) (e $smt_Value) (m1 $smt_Map) (m2 $smt_Map))
  :signature ($smt_Map $smt_Map) $smt_Value
  (
  (($smtx_msm_find_diff ($msm_default T e) m2)  $vsm_not_value)
  (($smtx_msm_find_diff ($msm_cons i e m1) m2)
    ; Lookup the current index, if it different, return this index.
    ($smt_builtin_ite
      ($smt_builtin_veq ($smtx_msm_lookup m2 i) e)
      ($smtx_msm_find_diff m1 m2)
      i))
  )
)

; Returns the type of the map value or tsm_none
(program $smtx_typeof_map_value
  ((i $smt_Value) (e $smt_Value) (m $smt_Map) (T $smt_Type))
  :signature ($smt_Map) $smt_Type
  (
  (($smtx_typeof_map_value ($msm_cons i e m))
    (eo::define ((mT ($smtx_typeof_map_value m)))
    ($smt_builtin_ite ($smt_builtin_Teq ($tsm_Map ($smtx_typeof_value i) ($smtx_typeof_value e)) mT)
      mT
      $tsm_none)))
  (($smtx_typeof_map_value ($msm_default T e))  ($tsm_Map T ($smtx_typeof_value e)))
  )
)

(program $smtx_index_typeof_map ((T $smt_Type) (U $smt_Type))
  :signature ($smt_Type) $smt_Type
  (
  (($smtx_index_typeof_map ($tsm_Map T U)) T)
  (($smtx_index_typeof_map T) $tsm_none)
  )
)
(program $smtx_elem_typeof_map ((T $smt_Type) (U $smt_Type))
  :signature ($smt_Type) $smt_Type
  (
  (($smtx_elem_typeof_map ($tsm_Map T U)) U)
  (($smtx_elem_typeof_map T) $tsm_none)
  )
)


;;; Map as sets

; A set is a mapping to Bool.
; The empty set maps all to false.
;(define $tsm_Set ((T $smt_Type)) ($tsm_Map T $tsm_Bool))
(define $smtx_elem_typeof_set ((T $smt_Type)) ($smtx_index_typeof_map T))

(define $msm_empty_set ((T $smt_Type)) ($msm_default T $vsm_false))
; Inserting sets e to true.
(define $smtx_mss_mk_insert ((e $smt_Value) (m $smt_Map)) ($smtx_msm_update m e $vsm_true))
(define $smtx_mss_insert ((e $smt_Value) (m $smt_Map)) ($msm_cons e $vsm_true m))
(define $smtx_mss_member ((e $smt_Value) (m $smt_Map))
  ($smt_builtin_veq ($smtx_msm_lookup m e) $vsm_true))

; Helper for computing binary set operators.
(program $smtx_mss_op_internal
  ((T $smt_Type) (m1 $smt_Map) (m2 $smt_Map) (acc $smt_Map) (e $smt_Value) (isInter $smt_builtin_Bool))
  :signature ($smt_builtin_Bool $smt_Map $smt_Map $smt_Map) $smt_Map
  (
  (($smtx_mss_op_internal isInter ($msm_empty_set T) m2 acc) acc)
  (($smtx_mss_op_internal isInter ($smtx_mss_insert e m1) m2 acc)
    ($smtx_mss_op_internal isInter m1 m2
      ($smt_builtin_ite
        ($smt_builtin_iff ($smtx_mss_member e m2) isInter)
        ($smtx_mss_mk_insert e acc)
        acc)))
  )
)

;;; Utilities for Sequence values

(program $smtx_ssm_seq_nth
  ((v $smt_Value) (vs $smt_Seq) (n $smt_builtin_Int) (T $smt_Type))
  :signature ($smt_Seq $smt_builtin_Int) $smt_Value
  (
  (($smtx_ssm_seq_nth ($ssm_empty T) n)                       $vsm_not_value)
  (($smtx_ssm_seq_nth ($ssm_cons v vs) $smt_builtin_z_zero)   v)
  (($smtx_ssm_seq_nth ($ssm_cons v vs) n)
    ($smtx_ssm_seq_nth vs ($smt_builtin_z_dec n)))
  )
)

; Returns the type of the map value or tsm_none
(program $smtx_typeof_seq_value
  ((v $smt_Value) (vs $smt_Seq) (T $smt_Type))
  :signature ($smt_Seq) $smt_Type
  (
  (($smtx_typeof_seq_value ($ssm_cons v vs))
    (eo::define ((sT ($smtx_typeof_seq_value vs)))
    ($smt_builtin_ite ($smt_builtin_Teq ($tsm_Seq ($smtx_typeof_value v)) sT)
      sT
      $tsm_none)))
  (($smtx_typeof_seq_value ($ssm_empty T)) ($tsm_Seq T))
  )
)

;; datatypes

(program $smtx_dtc_substitute
  ((s $smt_builtin_Int) (d $smt_Datatype) (T $smt_Type) (c $smt_DatatypeCons))
  :signature ($smt_builtin_String $smt_Datatype $smt_DatatypeCons) $smt_DatatypeCons
  (
  (($smtx_dtc_substitute s d ($dtc_cons T c))
    ($dtc_cons
      ; if it is a recursive reference to the type we are substituting, replace
      ($smt_builtin_ite ($smt_builtin_Teq T ($tsm_TypeRef s))
        ($tsm_Datatype s d)
        T)
      ($smtx_dtc_substitute s d c)))
  (($smtx_dtc_substitute s d $dtc_unit) $dtc_unit)
  )
)
(program $smtx_dt_substitute
  ((s $smt_builtin_Int) (d $smt_Datatype) (c $smt_DatatypeCons) (d2 $smt_Datatype))
  :signature ($smt_builtin_String $smt_Datatype $smt_Datatype) $smt_Datatype
  (
  (($smtx_dt_substitute s d ($dt_sum c d2))
    ($dt_sum ($smtx_dtc_substitute s d c) ($smtx_dt_substitute s d d2)))
  (($smtx_dt_substitute s d $dt_null) $dt_null)
  )
)

(program $smtx_typeof_dt_cons_value_rec2
  ((T $smt_Type) (U $smt_Type) (c $smt_DatatypeCons) (d $smt_Datatype))
  :signature ($smt_Type $smt_DatatypeCons) $smt_Type
  (
  (($smtx_typeof_dt_cons_value_rec2 T ($dtc_cons U c))
    ($tsm_DtCons U ($smtx_typeof_dt_cons_value_rec2 T c)))
  (($smtx_typeof_dt_cons_value_rec2 T $dtc_unit) T)
  )
)

(program $smtx_typeof_dt_cons_value_rec
  ((T $smt_Type) (n $smt_builtin_Int) (c $smt_DatatypeCons) (d $smt_Datatype))
  :signature ($smt_Type $smt_Datatype $smt_builtin_Int) $smt_Type
  (
  (($smtx_typeof_dt_cons_value_rec T ($dt_sum c d) $smt_builtin_z_zero)
    ($smtx_typeof_dt_cons_value_rec2 T c))
  (($smtx_typeof_dt_cons_value_rec T ($dt_sum c d) n)
    ($smtx_typeof_dt_cons_value_rec T d ($smt_builtin_z_dec n)))
  (($smtx_typeof_dt_cons_value_rec T d n) $tsm_none)
  )
)

(define $smtx_typeof_dt_cons_value
  ((s $smt_builtin_String) (d $smt_Datatype) (n $smt_builtin_Int))
  ; substitute ($tsm_TypeRef s) to ($tsm_Datatype s d), which ensures the
  ; datatype is closed.
  ($smtx_typeof_dt_cons_value_rec ($tsm_Datatype s d) ($smtx_dt_substitute s d d) n))

; program: $smtx_typeof_apply_value
(program $smtx_typeof_apply_value ((T $smt_Type) (U $smt_Type) (V $smt_Type))
  :signature ($smt_Type $smt_Type) $smt_Type
  (
  ; can partially apply datatype constructors
  (($smtx_typeof_apply_value ($tsm_DtCons T U) V)
    ($smt_builtin_ite ($smt_builtin_Teq T V) U $tsm_none))
  (($smtx_typeof_apply_value T U) $tsm_none)
  )
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Type rules for values

; NOTE: $vsm_lambda is unhandled
(program $smtx_typeof_value
  ((v $smt_Value) (f $smt_Value) (d $smt_Datatype)
   (b $smt_builtin_Bool) (w $smt_builtin_Int) (n $smt_builtin_Int)
   (q $smt_builtin_Real) (s $smt_builtin_String) (r $smt_builtin_RegLan)
   (m $smt_Map) (ss $smt_Seq))
  :signature ($smt_Value) $smt_Type
  (
  (($smtx_typeof_value ($vsm_bool b))     $tsm_Bool)
  (($smtx_typeof_value ($vsm_numeral n))  $tsm_Int)
  (($smtx_typeof_value ($vsm_rational q)) $tsm_Real)
  (($smtx_typeof_value ($vsm_string s))   $tsm_String)
  (($smtx_typeof_value ($vsm_binary w n))
    ($smt_builtin_ite ($smt_builtin_z_<= $smt_builtin_z_zero w) ($tsm_BitVec w) $tsm_none))
  (($smtx_typeof_value ($vsm_re r))       $tsm_RegLan)
  (($smtx_typeof_value ($vsm_map m))      ($smtx_typeof_map_value m))
  (($smtx_typeof_value ($vsm_seq ss))     ($smtx_typeof_seq_value ss))
  (($smtx_typeof_value ($vsm_DtCons s d n)) ($smtx_typeof_dt_cons_value s d n))
  (($smtx_typeof_value ($vsm_apply f v))  ($smtx_typeof_apply_value ($smtx_typeof_value f) ($smtx_typeof_value v)))
  (($smtx_typeof_value v)                 $tsm_none)
  )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Model semantics

; Forward declaration of the main method defined by this signature.
; We use this to define $eo_model_sat.
(program $smtx_model_eval () :signature ($smt_Term) $smt_Value)

;;; Core

; ITE branches to the appropriate child.
; return: The evaluation of an ite application.
(program $smtx_model_eval_ite
  ((t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_ite $vsm_true t2 t3)   t2)
  (($smtx_model_eval_ite $vsm_false t2 t3)  t3)
  (($smtx_model_eval_ite t1 t2 t3)          $vsm_not_value)
  )
)

; Equality insists on valueness and then reduces to an equality over datatypes
; in the deep embedding (vsm.Value), meaning it works for all types, including
; functions and uninterpreted sorts where values are not represented by terms.
; Note that the valueness predicate ensures this is sound. Moreover note that
; we do not invoke the type checker here. This means that if an ill-typed
; equality was given as input to this method, it would always evaluate to false.
; The caller of this method is responsible for ensuring that this behavior is
; either avoided or admissible.
; return: The evaluation of an equality application.
(program $smtx_model_eval_= ((t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_= t1 t2)
    (eo::define ((T1 ($smtx_typeof_value t1)))
    (eo::define ((T2 ($smtx_typeof_value t2)))
      ($smt_builtin_ite ($smt_builtin_Teq T1 T2)
        ($smt_builtin_ite ($smt_builtin_Teq T1 $tsm_none)
          $vsm_not_value
          ($vsm_bool ($smt_builtin_veq t1 t2)))
        $vsm_not_value))))
  )
)

;;; Functions, arrays

; Array select
(program $smtx_map_select
  ((v $smt_Value) (i $smt_Value) (m $smt_Map))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_select ($vsm_map m) i) ($smtx_msm_lookup m i))
  (($smtx_map_select v i)              $vsm_not_value)
  )
)

; Array store
(program $smtx_map_store
  ((v $smt_Value) (i $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_store ($vsm_map m) i e) ($vsm_map ($smtx_msm_update m i e)))
  (($smtx_map_store v i e)            $vsm_not_value)
  )
)

; Array diff
; Returns the value where m1 and m2 differ, or $vsm_not_value otherwise.
(program $smtx_map_diff ((m1 $smt_Map) (m2 $smt_Map))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_diff ($vsm_map m1) ($vsm_map m2))
    ; find an index in the first that conflicts with the second, or vice versa
    ($smtx_value_either ($smtx_msm_find_diff m1 m2) ($smtx_msm_find_diff m2 m1)))
  )
)

;;; Sets

; Empty set
(define $smtx_empty_set ((T $smt_Type)) ($vsm_map ($msm_empty_set T)))

; Set singleton
; return the singleton set whose type is T and contains e.
(define $smtx_set_singleton ((e $smt_Value))
  ($vsm_map ($smtx_mss_insert e ($msm_empty_set ($smtx_typeof_value e)))))

; Set intersection
; return the intersection of two set values.
(program $smtx_set_inter
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_inter ($vsm_map m1) ($vsm_map m2))
    ; m1 intersected m2 starting with empty set.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_true m1 m2 ($msm_empty_set ($smtx_index_typeof_map ($smtx_typeof_map_value m1))))))
  (($smtx_set_inter v1 v2)  $vsm_not_value)
  )
)

; Set minus
; return the set minus of two set values.
(program $smtx_set_minus
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_minus ($vsm_map m1) ($vsm_map m2))
    ; m1 minus m2 starting with empty set.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_false m1 m2 ($msm_empty_set ($smtx_index_typeof_map ($smtx_typeof_map_value m1))))))
  (($smtx_set_minus v1 v2)  $vsm_not_value)
  )
)

; Set union
; return the union of two set values.
(program $smtx_set_union
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_union ($vsm_map m1) ($vsm_map m2))
    ; m1 minus the empty set starting with m2.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_false m1 ($msm_empty_set ($smtx_index_typeof_map ($smtx_typeof_map_value m1))) m2)))
  (($smtx_set_union v1 v2)  $vsm_not_value)
  )
)

;;; Sequences

; Empty sequence
(define $smtx_empty_seq ((T $smt_Type)) ($vsm_seq ($ssm_empty T)))

; Sequence unit
(define $smtx_seq_unit ((e $smt_Value)) ($vsm_seq ($ssm_cons e ($ssm_empty ($smtx_typeof_value e)))))

; Sequence nth
(program $smtx_seq_nth
  ((s $smt_Seq) (n $smt_builtin_Int) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_seq_nth ($vsm_seq s) ($vsm_numeral n)) ($smtx_ssm_seq_nth s n))
  (($smtx_seq_nth v1 v2) $vsm_not_value)
  )
)
;;; Quantifiers

(program $smtx_is_var
  ((x $smt_Term) (s1 $smt_builtin_String) (T1 $smt_Type)
   (s2 $smt_builtin_String) (T2 $smt_Type))
  :signature ($smt_builtin_String $smt_Type $smt_Term) $smt_builtin_Bool
  (
  (($smtx_is_var s1 T1 ($sm_Var s2 T2)) 
    ($smt_builtin_and ($smt_builtin_str_= s1 s2) ($smt_builtin_Teq T1 T2)))
  (($smtx_is_var s1 T1 x) $smt_builtin_false)
  )
)

; (x, y) returns true iff y is a binder for x.
(program $smtx_is_binder_x 
  ((x $smt_Term) (s1 $smt_builtin_String) (T1 $smt_Type)
   (s2 $smt_builtin_String) (T2 $smt_Type))
  :signature ($smt_builtin_String $smt_Type $smt_Term) $smt_builtin_Bool
  (
  (($smtx_is_binder_x s1 T1 ($sm_exists s2 T2)) 
    ($smtx_is_var s1 T1 ($sm_Var s2 T2)))
  (($smtx_is_binder_x s1 T1 ($sm_forall s2 T2))
    ($smtx_is_var s1 T1 ($sm_Var s2 T2)))
  (($smtx_is_binder_x s1 T1 ($sm_lambda s2 T2))
    ($smtx_is_var s1 T1 ($sm_Var s2 T2)))
  (($smtx_is_binder_x s1 T1 x) $smt_builtin_false)
  )
)
  
; Substitution
; program: $smtx_substitute
; Used to define $smtx_eval_exists_rec.
; ($smtx_substitute x v t) returns the term where x is replaced by v.
(program $smtx_substitute
  ((s $smt_builtin_String) (T $smt_Type) (v $smt_Term) 
   (f $smt_Term) (a $smt_Term) (z $smt_Term))
  :signature ($smt_builtin_String $smt_Type $smt_Value $smt_Term) $smt_Term
  (
  (($smtx_substitute s T v ($sm_apply f a))
    ($smt_builtin_ite ($smtx_is_binder_x s T f)
      ($sm_apply f a) ; avoid issues with shadowing
      ($sm_apply ($smtx_substitute s T v f) ($smtx_substitute s T v a))))
  (($smtx_substitute s T v z)
    ; if x is z, we are now the constant with the given interpretation
    ($smt_builtin_ite ($smtx_is_var s T z) ($sm_Const v) z))
  )
)

;;; Datatypes

(program $smtx_model_eval_dt_cons
  ((s $smt_builtin_String) (d $smt_Datatype) (n $smt_builtin_Int))
  :signature ($smt_builtin_String $smt_Datatype $smt_builtin_Int) $smt_Value
  (
  (($smtx_model_eval_dt_cons s d n)
    ; must ensure its type is not none, which implies it is a valid index
    ($smt_builtin_ite
      ($smt_builtin_Teq ($smtx_typeof_dt_cons_value s d n) $tsm_none)
      $vsm_not_value
      ($vsm_DtCons s d n)))
  )
)

(program $smtx_model_eval_dt_sel
  ((n $smt_builtin_Int) (m $smt_builtin_Int) (v1 $smt_Value)
   (s $smt_builtin_String) (d $smt_Datatype))
  :signature ($smt_builtin_String $smt_Datatype $smt_builtin_Int $smt_builtin_Int $smt_Value) $smt_Value
  (
  (($smtx_model_eval_dt_sel s d n m v1)
    ; must ensure its type is T
    ($smt_builtin_ite ($smt_builtin_Teq ($smtx_typeof_value v1) ($tsm_Datatype s d))
      ; check if the head of the apply term is ($vsm_DtCons s d n)
      ($smt_builtin_ite ($smt_builtin_veq ($vsm_apply_head v1) ($vsm_DtCons s d n))
        ($vsm_apply_arg_nth v1 m)
        ; wrongly applied selector
        $vsm_not_value)
      ; ill typed term
      $vsm_not_value))
  )
)

(program $smtx_model_eval_dt_tester
  ((s $smt_builtin_String) (d $smt_Datatype) (n $smt_builtin_Int) (v1 $smt_Value))
  :signature ($smt_builtin_String $smt_Datatype $smt_builtin_Int $smt_Value) $smt_Value
  (
  (($smtx_model_eval_dt_tester s d n v1)
    ; must ensure its type is correct
    ($smt_builtin_ite ($smt_builtin_Teq ($smtx_typeof_value v1) ($tsm_Datatype s d))
      ; check if the head of the apply term is ($vsm_DtCons s d n)
      ($vsm_bool ($smt_builtin_veq ($vsm_apply_head v1) ($vsm_DtCons s d n)))
      ; ill typed term
      $vsm_not_value))
  )
)

(program $smtx_model_eval_dt_updater
  ((s $smt_builtin_String) (d $smt_Datatype)
   (n $smt_builtin_Int) (m $smt_builtin_Int) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_builtin_String $smt_Datatype $smt_builtin_Int $smt_builtin_Int $smt_Value $smt_Value) $smt_Value
  (
  ; TODO
  (($smtx_model_eval_dt_updater s d n m v1 v2) $vsm_not_value)
  )
)

; apply 

; program: $smtx_model_eval_apply
; We call ($smtx_model_eval_apply value_f value_i) when
; evaluating (f i) whose values are value_f and value_i
; respectively. If value_f is a map value, then we extract
; the map and call the map lookup routine.
(program $smtx_model_eval_apply
  ((m $smt_Map) (i $smt_Value) (f $smt_Value) (v $smt_Value)
   (s $smt_builtin_String) (T $smt_Type) (t $smt_Term))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  ; If a Herbrand interpretation, apply it to the next value.
  (($smtx_model_eval_apply ($vsm_apply f v) i)  ($vsm_apply ($vsm_apply f v) i))
  ; The function evaluated to a map value, call the map lookup.
  (($smtx_model_eval_apply ($vsm_map m) i)      ($smtx_msm_lookup m i))
  ; Lambda case
  (($smtx_model_eval_apply ($vsm_lambda s T t) i)
    ; substitutes into body
    ($smtx_model_eval ($smtx_substitute s T i t)))
  ; The function did not evaluate to a map value, we fail.
  (($smtx_model_eval_apply v i)                 $vsm_not_value)
  )
)
;;; Other model evaluation functions

$SMT_EVAL_PROGS$

; An evaluator for all terms that we can reason about models.
; This is a recursive call.
; invariant: this must be a total function
; invariant: unless this method returns $vsm_not_value, it must be such that
;            it represents a unique SMT-LIB value, i.e. ($vsm_term t) is
;            forbidden unless t denotes a value.
(program $smtx_model_eval
  ((f $smt_Term) (v $smt_Value) (T $smt_Type) (d $smt_Datatype)
   (b $smt_builtin_Bool) (w $smt_builtin_Int) (n $smt_builtin_Int)
   (m $smt_builtin_Int) (r $smt_builtin_Real) (s $smt_builtin_String)
   ; generic parameters that may appear in terms to pattern match
   (x1 $smt_Term) (x2 $smt_Term) (x3 $smt_Term) (x4 $smt_Term) (x5 $smt_Term))
  :signature ($smt_Term) $smt_Value
  (

  (($smtx_model_eval ($sm_bool b))      ($vsm_bool b))
  (($smtx_model_eval ($sm_numeral n))   ($vsm_numeral n))
  (($smtx_model_eval ($sm_rational r))  ($vsm_rational r))
  (($smtx_model_eval ($sm_string s))    ($vsm_string s))
  (($smtx_model_eval ($sm_binary w n))
    ; must be legal width and value
    ($smt_builtin_ite 
      ($smt_builtin_and
        ($smt_builtin_z_<= $smt_builtin_z_zero w)
        ($smt_builtin_z_= n ($smt_builtin_mod n ($smtx_pow2 w))))
      ($vsm_binary w n)
      $vsm_not_value))
  ; evaluation of standard SMT symbols
  ; These calls will reference helper methods above, e.g. of the form
  ; $smtx_model_eval_*, or call builtin methods e.g. $smtx_eval_exists_rec.
$SMT_EVAL_CASES$
  ; quantifiers
  (($smtx_model_eval ($sm_apply ($sm_exists s T) x1))
    ($smt_apply_3 "$smtx_model_eval_exists" s T x1))
  (($smtx_model_eval ($sm_apply ($sm_forall s T) x1))
    ($smt_apply_3 "$smtx_model_eval_forall" s T x1))
  (($smtx_model_eval ($sm_apply ($sm_lambda s T) x1)) ($vsm_lambda s T x1))
  ; datatypes
  (($smtx_model_eval ($sm_DtCons s d n)) ($smtx_model_eval_dt_cons s d n))
  (($smtx_model_eval ($sm_apply ($sm_DtSel s d n m) x1))
    ($smtx_model_eval_dt_sel s d n m ($smtx_model_eval x1)))
  (($smtx_model_eval ($sm_apply ($sm_DtTester s d n) x1))
    ($smtx_model_eval_dt_tester s d n ($smtx_model_eval x1)))
  (($smtx_model_eval ($sm_apply ($sm_apply ($sm_DtUpdater s d n m) x1) x2))
    ($smtx_model_eval_dt_updater s d n m ($smtx_model_eval x1) ($smtx_model_eval x2)))
  ; Apply case. We evaluate f and x1 separately and then call the
  ; $smtx_model_eval_apply above. We expect f to be an uninterpreted
  ; function whose model evaluation is an SMT-LIB map in this case.
  ; All interpreted f should be handled in the evaluation cases above.
  (($smtx_model_eval ($sm_apply f x1))
    ($smtx_model_eval_apply ($smtx_model_eval f) ($smtx_model_eval x1)))
  ; Constants, which carry their value.
  (($smtx_model_eval ($sm_Const v)) v)
  (($smtx_model_eval x1)   $vsm_not_value)
  )
)


;;;;;;;;;;;;;;;;;;;;;;

(program $eo_to_smt_type 
  ((T Type) (n1 $smt_builtin_Int) 
  (T1 Type) (T2 Type) (T3 Type) (T4 Type) (T5 Type)
  (x1 T1) (x2 T2) (x3 T3) (x4 T4) (x5 T5))
  :signature (Type) $smt_Type
  (
  (($eo_to_smt_type Bool) $tsm_Bool)
$EO_TO_SMT_TYPE_CASES$
  (($eo_to_smt_type T)    $tsm_none)
  )
)

(program $eo_to_smt 
  ((b $smt_builtin_Bool) (n $smt_builtin_Int) (r $smt_builtin_Rat)
   (s $smt_builtin_String) (w $smt_builtin_Int)
   (T Type) (U Type) (T1 Type) (T2 Type) (T3 Type) (T4 Type) (T5 Type)
   (f (-> U T)) (y U) (x1 T1) (x2 T2) (x3 T3) (x4 T4) (x5 T5))
  :signature (T) $smt_Term
  (
  (($eo_to_smt ($eo_bool b))      ($sm_bool b))
  (($eo_to_smt ($eo_numeral n))   ($sm_numeral n))
  (($eo_to_smt ($eo_rational r))  ($sm_rational r))
  (($eo_to_smt ($eo_string s))    ($sm_string s))
  (($eo_to_smt ($eo_binary w n))  ($sm_binary w n))
  (($eo_to_smt ($eo_Var s T))     ($sm_Var s ($eo_to_smt_type T)))
$EO_TO_SMT_CASES$
  ; TODO: maybe a datatype constructor or selector???
  (($eo_to_smt (f y))             ($sm_apply ($eo_to_smt f) ($eo_to_smt y)))
  (($eo_to_smt y)                 $sm_none)
  )
)

; program: $eo_model_sat
; note: F is satisfied by the model if F evaluates to the SMT-LIB value denoting true.
; We expect the input to this method to be a Eunoia term denoting an SMT-LIB formula
; (term of Boolean type).
(program $eo_model_sat ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_sat F) ($smt_builtin_ite ($smt_builtin_veq ($smtx_model_eval ($eo_to_smt F)) $vsm_true) true false))
  )
)
(program $eo_model_unsat ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_unsat F) ($smt_builtin_ite ($smt_builtin_veq ($smtx_model_eval ($eo_to_smt F)) $vsm_false) true false))
  )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_end
