; This file defines SMT-LIB model semantics in Eunoia.
; It has exception handling utilities to call Eunoia programs in
; a safe way that ensures that all programs in this signature are total.

; The programs in this file operate on datatypes that correspond to
; a deep embedding of Eunoia and SMT-LIB terms, types and values.
; In particular, we use the following types:
; 1. $eo_Term, the type of Eunoia terms.
; 2. $smt_Term, the type of SMT-LIB terms.
; 3. $smt_Type, the type of SMT-LIB types.
; 4. $smt_Value, the type of SMT-LIB values.
; 5. Further types defining specific SMT-LIB values, e.g. $smt_Map.
; 6. $smt_builtin_X, the builtin SMT-LIB type X.
; Note that the last type allows us to define symbols whose type
; will be a native SMT-LIB type in the final embedding generated
; by the smt-meta plugin.

;;; Eunoia datatype constructors

; The Eunoia representation of an SMT-LIB term.
; declare $eo_smt_term
; - already declared in eo_builtin_smt.eo

; The Eunoia representation of an SMT-LIB type.
; declare $eo_smt_type
; - already declared in eo_builtin_smt.eo

; The Eunoia representation of an SMT-LIB value.
; declare $eo_smt_value
; - already declared in eo_builtin_smt.eo

;;; SMT term datatype constructors

; An application of SMT-LIB terms.
(define $sm_apply_term ((t1 $smt_Term) (t2 $smt_Term))
  ($smd_sm.Apply t1 t2))
  
; A skolem, identified by kind, identifier and Type.
; The kind 0 is reserved for standard SMT-LIB symbols introduced
; by the user by declare-const. The other kinds of free symbols
; can be custom defined based on the Eunoia signature (see method
; $eo_const_predicate in model_eo.eo).
; A skolem is identified by a type, a term and a kind.
;(define $sm_skolem
;  ((T $smt_Type) (k $smt_Term) (id $smt_builtin_Int))
;  ($smd_sm.Skolem T k id))
  
;;; SMT type datatype constructors

; The Boolean type
(declare-const $smd_tsm.Bool $smt_Type)
(define $tsm_Bool () $smd_tsm.Bool)

; Function types
(declare-parameterized-const $smd_tsm.FunType
  ((T1 $smt_Type :opaque) (T2 $smt_Type :opaque)) $smt_Type)
(define $tsm_fun_type ((T1 $smt_Type) (T2 $smt_Type))
  ($smd_tsm.FunType T1 T2))
  
; Uninterpreted sorts
(declare-parameterized-const $smd_tsm.USort
  ((id $smt_builtin_Int :opaque)) $smt_Type)
(define $tsm_USort ((id $smt_builtin_Int)) ($smd_tsm.USort id))
  
; The sort of a term that doesn't have an SMT-LIB type.
; This is used as an error condition
(declare-parameterized-const $smd_tsm.NullSort
  ((id $smt_builtin_Int :opaque)) $smt_Type)
(define $tsm_NullSort ((id $smt_builtin_Int)) ($smd_tsm.NullSort id))

;;; SMT value datatype constructors

; A value denoting a map.
(define $vsm_map ((T $smt_Type) (m $smt_Map))
  ($smd_vsm.Map T m))

; A value denoting an uninterpreted constant.
(define $vsm_uconst ((T $smt_Type) (id $smt_builtin_Int))
  ($smd_vsm.UConst T id))

; A value represented by an SMT-LIB term. This is used for types
; where terms are used to denote the values of that type, e.g.
; SMT-LIB numerals for Int.
(define $vsm_term ((t $smt_Term)) ($smd_vsm.Term t))

; Denotes a failure case for values.
(define $vsm_not_value () $smd_vsm.NotValue)

;;; SMT map value datatype constructors

; Constructs a map value where i is mapped to e.
(declare-parameterized-const $smd_msm.Map.cons
  ((i $smt_Value :opaque) (e $smt_Value :opaque) (m $smt_Map :opaque))
  $smt_Map)
(define $map_cons ((i $smt_Value) (e $smt_Value) (m $smt_Map))
  ($smd_msm.Map.cons i e m))

; Constructs a map value where all indices are mapped to e.
(declare-parameterized-const $smd_msm.Map.default
  ((e $smt_Value :opaque))
  $smt_Map)
(define $map_default ((e $smt_Value)) ($smd_msm.Map.default e))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Exception handling

; This file is a formalization of the SMT-LIB semantics in Eunoia.
; It uses a deep embedding of SMT-LIB terms .
; This file is expected to define function $eo_model_sat, which can be used 
; to define whether a (Boolean) term is satisfied by a model.
; It generates symbols $smt_Term, $sym_apply_*, $smt_from_eo_*, and $smt_to_eo_*,
; which have further meaning in the compilation pipeline.

; Invariant: all programs in this signature should be well-founded and never
; never get stuck unless otherwise stated.

; Returns SMT-LIB builtin true/false if x is stuck
(define $smt_builtin_is_ok ((x $eo_Term))
  ($smt_apply_3 "ite" ($smt_apply_= x $eo_stuck)
    $smt_builtin_false
    $smt_builtin_true))

; Utilities to ensure that programs are total.
; Takes
; - A $eo_Term t where we are not sure if it gets stuck.
; - A $eo_Term elseTerm where we are sure it does not get stuck.
; Returns the SMT term corresponding to the evaluation of t, if possible,
; or elseTerm otherwise. This always successfully evaluates.
; Note that these definitions are slightly more complex than they need
; to be, as they could rely on is_ok above. However:
; - Using the raw tester/selector is more efficient in the end
;   encoding.
; - It is easier to recognize the pattern (eo.SmtTerm.arg1 *)
;   than (ite (eo.is_ok *) * elseTerm).
(define $smt_try_eo ((t $eo_Term) (elseTerm $eo_Term))
  ($smt_apply_3 "ite" ($smt_apply_1 "(_ is eo.SmtTerm)" t)
    t
    elseTerm))
; Same as above, for SMT types.
(define $smt_try_eo_type ((t $eo_Term) (elseTerm $eo_Term))
  ($smt_apply_3 "ite" ($smt_apply_1 "(_ is eo.SmtType)" t)
    t
    elseTerm))
; Same as above, for SMT values.
(define $smt_try_eo_value ((t $eo_Term) (elseTerm $eo_Term))
  ($smt_apply_3 "ite" ($smt_apply_1 "(_ is eo.SmtValue)" t)
    t
    elseTerm))

; Only call when we are sure that t is a value
; TODO: guard this properly
(define $smt_term_from_value ((t $smt_Term))
  ($smt_apply_1 "vsm.Term.arg1" t))

;;;;;; SMT values

; forward declaration
; This method classifies SMT terms as being values.
; The invariant of this method is that if
;   ($smt_Type t1) and ($smt_Type t2)
; return true where t1 and t2 have the same type ($smtx_typeof), then
;   (not (= t1 t2))
; is valid.
(program $smtx_term_is_value ()
  :signature ($smt_Term) $smt_builtin_Bool)

;;; Functions and array values.

; $smt_Map is recursive and thus defined above.

; Get the default for the map
(program $smtx_map_default
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (M $smt_Map))
  :signature ($smt_Map) $smt_Value
  (
  (($smtx_map_default ($map_cons j e M))  ($smtx_map_default M))
  (($smtx_map_default ($map_default e))   e)
  )
)

; This program looks up the value of a term in a map.
; This is used for function evaluation.
(program $smtx_map_lookup
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (M $smt_Map))
  :signature ($smt_Map $smt_Value) $smt_Value
  (
  ; NOTE: the cases here are exhaustive
  (($smtx_map_lookup ($map_cons i e M) i)  e)
  (($smtx_map_lookup ($map_cons j e M) i)  ($smtx_map_lookup M i))
  (($smtx_map_lookup ($map_default e) i)   e)
  )
)

; This program determines whether the map value is canonical
; This program is only necessary if we are doing equality between arrays
; (or functions).
(program $smtx_map_is_redundant
  ((T $smt_Type) (U $smt_Type) (t $smt_Value) (u $smt_Value) (M $smt_Map))
  :signature ($smt_Map $smt_Type) $smt_builtin_Bool
  (
  (($smtx_map_is_redundant ($map_default u) U)     false)
  (($smtx_map_is_redundant ($map_cons t u M) U)
    ; lookup value on tail
    (eo::define ((ru ($smtx_map_lookup t M)))
    ; if it is the same, this index is redundant and thus we are not a value
    ($smt_apply_3 "ite"
      ($smt_apply_= ru u)
      $smt_builtin_false
      ($smtx_map_is_redundant M))))
  )
)

; TODO: use $smtx_map_is_redundant.
; Also requires a sortedness and non-exhaustiveness conditions.
(program $smtx_map_is_value ()
  :signature ($smt_Type $smt_Map) $smt_builtin_Bool)

;;; Datatype values

; Datatypes are not embedded.

; TODO: since e.g. uinterpreted sorts can be nested in
; datatypes we need a lifted datatype value.

; define: $smt_is_dt
; returns: true if t is a datatpe (i.e. it has constructors).
(define $smt_is_dt ((t $smt_Type))
  ($smt_builtin_is_ok ($eo_dt_constructors t)))

; define: $smt_is_dt_cons
; returns: true if t is a constructor (i.e. it has selectors).
(define $smt_is_dt_cons ((t $smt_Term))
  ($smt_builtin_is_ok ($eo_dt_selectors t)))

; program: $smtx_dt_is_value
; Returns true if its argument is a datatype value.
; This checks that the term is constructed solely based on values and values of
; (possibly other) types.
(program $smtx_dt_is_value ((f $smt_Term) (a $smt_Term) (c $smt_Term))
  :signature ($smt_Term) $smt_builtin_Bool
  (
  (($smtx_dt_is_value ($sm_apply_term f a)) ($smt_apply_3 "ite"
                                              ($smtx_term_is_value a)
                                              ($smtx_dt_is_value f)
                                              $smt_builtin_false))
  (($smtx_dt_is_value c)                    ($smt_is_dt_cons c))
  )
)

;;; Term values.

; program: $smtx_term_is_value
; Returns true if its argument is an SMT value.
; This function is expected to never get stuck.
; Note that this does not take a type. This function must ensure
; that if it returns true for two terms t1 and t2 of the same type,
; then t1 != t2 in all models.
(program $smtx_term_is_value
  ((T $smt_Type) (t $smt_Term) (n $smt_builtin_Int) (r $smt_builtin_Real) (s $smt_builtin_String))
  :signature ($smt_Term) $smt_builtin_Bool
  (
  ; standard atomic types are values
  (($smtx_term_is_value $sm_mk_true)            $smt_builtin_true)
  (($smtx_term_is_value $sm_mk_false)           $smt_builtin_true)
  (($smtx_term_is_value ($smd_sm.Numeral n))    $smt_builtin_true)
  (($smtx_term_is_value ($smd_sm.Rational r))   $smt_builtin_true)
  (($smtx_term_is_value ($smd_sm.String s))     $smt_builtin_true)
  ; by default, not a value
  (($smtx_term_is_value t)                      $smt_builtin_false)
  )
)

;;; Guarded utilities for making values

; Returns a term of type $smt_Value, embeds the term
; if indeed it is a value, or returns not a value otherwise.
(define $smt_mk_value_term ((t $smt_Term))
  ($smt_apply_3 "ite"
    ($smtx_term_is_value t)
    ($vsm_term t)
    $vsm_not_value))

(define $smt_mk_value_map ((T $smt_Type) (m $smt_Map))
  ($smt_apply_3 "ite"
    ($smtx_map_is_value T m)
    ($vsm_map T m)
    $vsm_not_value))

; program: $smtx_ensure_value
; args:
; - v $smt_Value: A value term.
; return: >
;   v itself if it denotes a proper SMT-LIB value, or $vsm_not_value otherwise.
(program $smtx_ensure_value
  ((t $smt_Value) (val $smt_Value) (T $smt_Type) (m $smt_Map) (id $smt_builtin_Int))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_ensure_value ($vsm_term t))        ($smt_mk_value_term t))
  (($smtx_ensure_value ($vsm_map T m))       ($smt_mk_value_map T m))
  (($smtx_ensure_value ($vsm_uconst T id))   ($vsm_uconst T id))
  (($smtx_ensure_value t)                    $vsm_not_value)
  )
)

;;; utilities

; Returns true if t is a (non-error) SMT-LIB value.
(define $vsm_is_value ((t $smt_Value))
  ($smt_apply_1 "not" ($smt_apply_1 "(_ is vsm.NotValue)" t)))

; Returns true if t is the SMT-LIB value denoting true.
(define $vsm_is_true ((t $smt_Value))
  ($smt_builtin_and
    ($smt_apply_1 "(_ is vsm.Term)" t)
    ($sm_is_true ($smt_apply_1 "vsm.Term.arg1" t))))
    
; Returns true if t is the SMT-LIB value denoting false.
(define $vsm_is_false ((t $smt_Value))
  ($smt_builtin_and
    ($smt_apply_1 "(_ is vsm.Term)" t)
    ($sm_is_false ($smt_apply_1 "vsm.Term.arg1" t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Model semantics

; Forward declaration of the main method defined by this signature.
; We use this to define $eo_model_sat.
(program $smtx_model_eval () :signature ($smt_Term) $smt_Value)

; free constants

; fwd-decl: $smtx_model_lookup
; Conceptually, returns the model value for constant with kind k, identifier id and type T.
; This is intentionally undefined in this signature.
(program $smtx_model_lookup ()
  :signature ($smt_Type $smt_builtin_Int $smt_builtin_Int) $smt_Value)

; Returns the builtin integer corresponding to the kind of the
; skolem term ($sm_skolem T k id).
;(program $smtx_get_skolem_kind ((k $smt_Term))
;  :signature ($smt_Type $smt_Term $smt_builtin_Int) $smt_builtin_Int
;  ; TODO
;)

;(program $smtx_model_skolem_lookup ((T $smt_Type) (k $smt_Term) (id $smt_builtin_Int))
;  :signature ($smt_Type $smt_Term $smt_builtin_Int) $smt_Value
;  (
;  (($smtx_model_skolem_lookup T k id) ($smtx_model_lookup T ($smtx_get_skolem_kind T k id) id))
;  )
;)

; Lookup the predicate the constant can be assumed to have.
; Otherwise, we lookup the predicate for the skolem, which may be
; user-defined. This must correspond a valid formula, i.e. one where
;   (exists val. ($smtx_const_predicate k id T val))
; is a valid formula.
; If the  is undefined, we return true.
;(program $smtx_const_predicate_internal
;  ((T $smt_Type) (k $smt_Term) (id $smt_builtin_Int) (val $smt_Value))
;  :signature ($smt_Type $smt_Term $smt_builtin_Int $smt_Value) $smt_builtin_Bool
;  (
;  ; User defined constant predicates.
$EO_CONST_PREDICATE_CASES$
;  (($smtx_const_predicate_internal T k id val) $smt_builtin_true)
;  )
;)

;(program $smtx_const_predicate ((T $smt_Type) (k $smt_Term) (id $smt_builtin_Int))
;  :signature ($smt_Type $smt_Term $smt_builtin_Int) $smt_builtin_Bool
;  (
;  (($smtx_const_predicate T k id)
;      ($smtx_const_predicate_internal T k id ($smtx_model_skolem_lookup T k id)))
;  )
;)

; program: $smtx_substitute
; Used to define $smtx_eval_quant.
; TODO: debruijn
(program $smtx_substitute
  ((x $smt_Term) (y $smt_Term) (f $smt_Term) (a $smt_Term) (z $smt_Term))
  :signature ($smt_Term $smt_Term $smt_Term) $smt_Term
  (
  (($smtx_substitute x y (f a))         (_ ($smtx_substitute x y f) ($smtx_substitute x y a)))
  (($smtx_substitute x y x)             y)
  (($smtx_substitute x y z)             z)
  )
)

;;; Core definition of $smtx_model_eval

; program: $smtx_model_eval_apply
; We call ($smtx_model_eval_apply value_f value_i) when
; evaluating (f i) whose values are value_f and value_i
; respectively. If value_f is a map value, then we extract
; the map and call the map lookup routine.
(program $smtx_model_eval_apply
  ((T $smt_Type) (m $smt_Map) (i $smt_Value) (v $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  ; The function evaluated to a map value, call the map lookup.
  (($smtx_model_eval_apply ($vsm_map T m) i)  ($smtx_map_lookup m i))
  ; The function did not evaluate to a map value, we fail.
  (($smtx_model_eval_apply v i)               $vsm_not_value)
  )
)

; An evaluator for all terms that we can reason about models.
; This is a recursive call.
; invariant: this must be a total function
; invariant: unless this method returns $vsm_not_value, it must be such that
;            it represents a unique SMT-LIB value, i.e. ($vsm_term t) is
;            forbidden unless t denotes a value.
(program $smtx_model_eval
  ((T $smt_Type) (f $smt_Term) (y $smt_Term) (z $smt_Term) (k $smt_Term) (id $smt_builtin_Int) (F Bool)
   (val $smt_Value)
   ; generic parameters that may appear in terms to pattern match
   (x1 $smt_Term) (x2 $smt_Term) (x3 $smt_Term) (x4 $smt_Term) (x5 $smt_Term))
  :signature ($smt_Term) $smt_Value
  (
  ; ITE branches to the appropriate child.
  (($smtx_model_eval (ite x1 x2 x3))
    (eo::define ((e1 ($smtx_model_eval x1)))
    ($smt_apply_3 "ite" ($vsm_is_true e1)
      ($smtx_model_eval x2)
      ($smt_apply_3 "ite" ($vsm_is_false e1)
        ($smtx_model_eval x3)
        $vsm_not_value))))
  ; Equality insists on valueness and then reduces to an equality over datatypes
  ; in the deep embedding (vsm.Value), meaning it works for all types, including
  ; functions and uninterpreted sorts where values are not represented by terms.
  ; Note that the valueness predicate ensures this is sound. Moreover note that
  ; we do not invoke the type checker here. This means that if an ill-typed
  ; equality was given as input to this method, it would always evaluate to false.
  ; The caller of this method is responsible for ensuring that this behavior is
  ; either avoided or admissible.
  (($smtx_model_eval (= x1 x2))
    (eo::define ((e1 ($smtx_model_eval x1)))
    (eo::define ((e2 ($smtx_model_eval x2)))
    ($smt_apply_3 "ite" ($smt_builtin_and ($vsm_is_value e1) ($vsm_is_value e2))
      ; use datatype equality over $smt_Value
      ($vsm_term ($sm_mk_bool ($smt_apply_= e1 e2)))
      $vsm_not_value))))
  ; evaluation of standard SMT symbols
  ; These calls may only call one of the above macros:
  ; - $smtx_eval_quant
  ; - $smt_eval_o_arith_*,
  ; - $smt_eval_apply_*
$SMT_EVAL_CASES$
  ; Apply case. We evaluate f and y separately and then call the
  ; $smtx_model_eval_apply above. We expect f to be an uninterpreted
  ; function whose model evaluation is an SMT-LIB map in this case.
  ; All interpreted f should be handled in the evaluation cases above.
  (($smtx_model_eval ($sm_apply_term f y))    (eo::define ((fme ($smtx_model_eval f)))
                                              (eo::define ((yme ($smtx_model_eval y)))
                                                ($smtx_model_eval_apply fme yme))))
  ;; free constants
  ; Constants carry their value in the model, which is an arbitrary value term.
  ; We run this value through $smtx_ensure_value to ensure it is a proper value.
  (($smtx_model_eval ($sm_Const val))          ($smtx_ensure_value val))
  
  ; Otherwise, it may be a term value (e.g. if z is a Boolean or numeral constant).
  ; We call the utility method which will either generate an SMT-LIB term value or
  ; a SMT-LIB non-value error term.
  (($smtx_model_eval z)                       ($smtx_ensure_value ($vsm_term z)))
  )
)

; program: $eo_model_sat_internal
(program $eo_model_sat_internal ((val $smt_Value))
  :signature ($smt_Value) Bool
  (
  (($eo_model_sat_internal ($vsm_term $sm_mk_true)) true)
  (($eo_model_sat_internal ($vsm_term $sm_mk_false)) false)
  )
)

; program: $eo_model_sat
; note: F is satisfied by the model if F evaluates to the SMT-LIB value denoting true.
; We expect the input to this method to be a Eunoia term denoting an SMT-LIB formula
; (term of Boolean type).
(program $eo_model_sat ((F $smt_Term))
  :signature ($eo_Term) Bool
  (
  (($eo_model_sat ($eo_smt_term F)) ($eo_model_sat_internal ($smtx_model_eval F)))
  )
)

; The SMT typeof function, which incorporates builtin SMT terms

; invariant: all terms introduced by this layer must be given a type rule here.
(program $eo_model_typeof
  ((t $eo_Term) (val $smt_Value) (T $smt_Type) (m $smt_Map) (id $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  ; the type of a constant is the type of its value.
  (($eo_model_typeof ($eo_smt_term ($sm_Const val)))      ($eo_model_typeof ($eo_smt_value val)))
  (($eo_model_typeof ($eo_smt_value ($vsm_term t)))       ($eo_model_typeof ($eo_smt_term t)))
  (($eo_model_typeof ($eo_smt_value ($vsm_map T m)))      T) ; FIXME
  (($eo_model_typeof ($eo_smt_value ($vsm_uconst T id)))  T)
  (($eo_model_typeof ($eo_smt_value $vsm_not_value))      ($tsm_NullSort $smt_builtin_z_zero))
  (($eo_model_typeof t) ($smt_try_eo_type
                          ($eo_typeof t)
                          ($eo_smt_type ($tsm_NullSort $smt_builtin_z_zero))))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_end
