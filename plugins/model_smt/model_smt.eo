
; This file is expected to define function $smt_model_eval, which can be used to define
; whether a (Boolean) term is satisfied by a model.


; fwd-decl: $eo_model_lookup
; Conceptually, returns the model value for constant with identifier id and type T.
; This is intentionally undefined in this signature, which will be a UF in the final VC.
(program $eo_model_lookup ((T Type))
  :signature (T) T)

; An SMT-LIB term.
(declare-const $smt_Term Type)

; Apply the SMT operator named "op" to x1 and x2.
(declare-parameterized-const $smt_apply_1
  ((T Type :implicit) (op $eo_String) (x1 T)) $smt_Term)
(declare-parameterized-const $smt_apply_2
  ((T Type :implicit) (U Type :implicit) (op $eo_String) (x1 T) (x2 U)) $smt_Term)
(declare-parameterized-const $smt_apply_3
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (op $eo_String) (x1 T) (x2 U) (x3 V)) $smt_Term)

; Convert smt2 term to a Eunoia numeral.
(declare-const $smt_to_numeral (-> $smt_Term $eo_Numeral))
; Convert smt2 term to a Eunoia rational.
(declare-const $smt_to_rational (-> $smt_Term $eo_Rational))
; Convert smt2 term to a Eunoia string.
(declare-const $smt_to_string (-> $smt_Term $eo_String))
; Convert smt2 term to a Eunoia binary.
(declare-const $smt_to_string (-> $smt_Term $eo_Binary))

; definitions of Types

; represents an unknown value
; NOTE: could be a program??
(declare-parameterized-const @unknown_value ((T Type) (i $eo_Numeral)) T)

$SMT_TYPE_ENUM_NGROUND_DEFS$

(program $smt_type_enum ((T Type) (i $eo_Numeral)
  $SMT_TYPE_ENUM_PARAM$)
  :signature ((eo::quote T) $eo_Numeral) T
  (
  ; enumeration of standard SMT types
$SMT_TYPE_ENUM_CASES$
  (($smt_type_enum T i)           (@unknown_value T i))   ; note since this always succeeds, this assumes that unhandled types have infinite type
  )
)

; definitions of operators

; fwd-decl: $eo_model_lookup
; Conceptually, returns the model value for constant with identifier id and type T.
; This is intentionally undefined in this signature.
(program $eo_model_lookup ((T Type))
  :signature (T) T)

$SMT_EVAL_NGROUND_DEFS$

; An evaluator for all terms that we can reason about models.
; This is a recursive call.
(program $smt_model_eval
  ((T Type) (U Type) (V Type) (x T) (f (-> U T)) (y U)
  $SMT_EVAL_PARAM$)
  :signature (T) T
  (
  ; evaluation of standard SMT symbols
$SMT_EVAL_CASES$
  ; generic apply
  (($smt_model_eval (f y))  (eo::define ((fme ($smt_model_eval f)))
                            (eo::define ((yme ($smt_model_eval y)))
                              (_ fme yme))))
  (($smt_model_eval x)      x)
  )
)
