; includes model_smt_preamble.eo

; This file is a formalization of the SMT-LIB semantics in Eunoia.
; It uses a deep embedding of SMT-LIB terms .
; This file is expected to define function $eo_model_sat, which can be used 
; to define whether a (Boolean) term is satisfied by a model.
; It generates symbols $smt_Term, $sym_apply_*, $smt_from_eo_*, and $smt_to_eo_*,
; which have further meaning in the compilation pipeline.

; Invariant: all programs in this signature should be well-founded and never
; never get stuck unless otherwise stated.

; These functions will be handled by smt_meta.

;;; utilities

; A utility to ensure that programs are total.
; Takes
; - A $eo_Term t where we are not sure if it gets stuck.
; - A $eo_Term elseTerm where we are sure it does not get stuck.
; Returns the SMT term corresponding to the evaluation of t, if possible,
; or elseTerm otherwise. This always successfully evaluates.
(define $smt_try_eo ((t $eo_Term) (elseTerm $eo_Term))
  ($smt_apply_1 "eo.SmtTerm.arg1" 
    ($smt_apply_3 "ite" ($smt_apply_1 "(_ is eo.SmtTerm)" t)
      t
      elseTerm)))

; Used to totalize $eo_typeof.
(program $smtx_typeof ()
  :signature ($smt_Term) $smt_Type)

(declare-const @sterm_list Type)
(declare-const @sterm_list_nil @sterm_list)
(declare-const @sterm_list_cons (-> $smt_Term @sterm_list @sterm_list))

(program $smtx_list_concat ((x $smt_Term) (y @sterm_list) (z @sterm_list))
  :signature (@sterm_list @sterm_list) @sterm_list
  (
  (($smtx_list_concat (@sterm_list_cons x y) z)  (@sterm_list_cons x ($smtx_list_concat y z)))
  (($smtx_list_concat @sterm_list_nil z)         z)
  )
)

; Maps, which model values for functions.
; TODO: namespace
(declare-parameterized-const @map ((T Type) (U Type)) Type)
(declare-parameterized-const @map_nil
  ((T Type) (U Type) (default U)) (@map T U))
(declare-parameterized-const @map_cons
  ((T Type) (U Type) (index T) (element U) (tail (@map T U)))
  (@map T U))

; NOTE: this is equivalent to a datatype tester ((_ is sm.usort_value) t).
(program $smtx_is_usort_value  ((n $smt_builtin_Int) (T $smt_Type) (t $smt_Term))
  :signature ($smt_Term) $smt_builtin_Bool
  (
  (($smtx_is_usort_value ($smd_sm.usort_value n T)) ($smt_apply_0 "true"))
  (($smtx_is_usort_value t)                         ($smt_apply_0 "false"))
  )
)

;;; Definition of legal types

; Is T a type that can be assigned to free constants?
; Alternatively, is T a type that can be put in an equality?
; Note if $eo_is_type gets stuck, we assume the type is not legal.
; TODO: this may be unecessary
(define $smt_is_type ((T Type))
  ($smt_try_eo ($eo_is_type T) false))

;;; Definitions of Type enumeration

; Since $smtx_methods never get stuck, all finite types must be defined in
; $eo_enum_type.
(program $smtx_enum_type ((T $smt_Type) (i $smt_builtin_Int))
  :signature ($smt_Type $smt_builtin_Int) $smt_Term
  (
  ; enumeration of standard SMT types
  ;(($smtx_enum_type $smt_Numeral i)     (eo::define ((v (eo::zdiv i 2)))
  ;                                      ($smt_apply_3 "ite" ($smt_apply_2 "=" (eo::zmod i 2) 0) v (eo::neg v))))
  ;(($smtx_enum_type $smt_String i)      ($smt_apply_3 "ite" ($smt_apply_2 "=" i 0)
  ;                                      ""
  ;                                      (eo::concat (eo::to_str (eo::zmod i 196608)) ($smtx_enum_type $smt_String (eo::zdiv i 196608)))))
  ; rationals are treated as Real, meaning we interleave rational/irrational.
  ;(($smtx_enum_type $smt_Rational i)    (eo::define ((ir (eo::zdiv i 2)))
  ;                                    (eo::define ((isRat ($smt_apply_2 "=" (eo::zmod ir 2) 0)))
  ;                                    (eo::define ((i (eo::zdiv ir 2)))
  ;                                    (eo::define ((v ($smt_apply_3 "ite" isRat ($smtx_rat_to_num ($smt_rat_enum i)) ($smt_irrat_enum i))))
  ;                                      ($smt_apply_3 "ite" ($smt_apply_2 "=" (eo::zmod i 2) 0) v (eo::neg v)))))))
  
  ; TODO: functions, datatypes
  ; Try to enumerate the type, if we fail, we return $smd_sm.usort_value.
  ; Note that this essentially assumes that unhandled types are uninterpreted
  ; and have infinite cardinality (since this does not get stuck).
  (($smtx_enum_type T i)               ($smd_sm.usort_value T i))
  )
)

;;; definitions of Values

; forward declaration
(program $smtx_is_value ()
  :signature ($smt_Type $smt_Term) $smt_builtin_Bool)

; functions and array values.

(program $smtx_map_is_value
  ((T $smt_Type) (U $smt_Type) (t $smt_Term) (u $smt_Term) (tail (@map T U)))
  :signature ($smt_Term) $smt_builtin_Bool
  (
  ; TODO: ordering constraint, recursive
  (($smtx_map_is_value (@map_nil T U u))          ($smtx_is_value U u))
  (($smtx_map_is_value (@map_cons T U t u tail))  ($smtx_is_value u))
  )
)

; datatypes.

; define: $smt_is_dt
; returns: true if t is a datatpe (i.e. it has constructors).
(define $smt_is_dt ((t $smt_Type))
  ; eo::is_ok is total, doesn't need to wrap in smt_try_eo
  ($smt_from_eo_bool (eo::is_ok ($eo_dt_constructors ($smt_apply_1 "eo.SmtType" t)))))

; define: $smt_is_dt_cons
; returns: true if t is a constructor (i.e. it has selectors).
(define $smt_is_dt_cons ((t $smt_Term))
  ; eo::is_ok is total, doesn't need to wrap in smt_try_eo
  ($smt_from_eo_bool (eo::is_ok ($eo_dt_selectors t))))

; program: $smtx_dt_is_value
; Returns true if its argument is a datatype value.
(program $smtx_dt_is_value
  ((U Type) (T Type) (f (-> T U)) (a T) (c U))
  :signature ($smt_Term) $smt_builtin_Bool
  (
  (($smtx_dt_is_value (f a))  ($smt_apply_3 "ite" ($smtx_is_value ($smtx_typeof a) a)
                               ($smtx_dt_is_value f)
                               ($smt_type_0 "false")))
  (($smtx_dt_is_value c)      ($smt_is_dt_cons c))
  )
)

; program: $smtx_dt_is_value
; Returns true if its argument is an SMT value.
; This function is expected to never get stuck.
(program $smtx_is_value
  ((T $smt_Type) (U $smt_Type) (t $smt_Term) (n1 $smt_builtin_Int) (r1 ($smt_type_0 "Real")) (s1 ($smt_type_0 "String")))
  :signature ($smt_Type $smt_Term) $smt_builtin_Bool
  (
  ; if the literal type is not defined, this is false
  (($smtx_is_value ($smd_tsm.UnknownSort n1) t)                            false)
  (($smtx_is_value ($smd_tsm.USort n1) t)                                  ($smtx_is_usort_value t))
  ; standard atomic types
  (($smtx_is_value $smd_tsm.BoolType $smd_sm.True)                         true)
  (($smtx_is_value $smd_tsm.BoolType $smd_sm.False)                        true)
  ;(($smtx_is_value $smt_Numeral ($smd_eo.SmtTerm ($smd_sm.Numeral n1)))    true)
  ;(($smtx_is_value $smt_Rational ($smd_eo.SmtTerm ($smd_sm.Rational r1)))  true)
  ;(($smtx_is_value $smt_String ($smd_eo.SmtTerm ($smd_sm.String s1)))      true)
  ;(($smtx_is_value $eo_Binary t)
  ;(($smtx_is_value (@map T U) t)   ($smtx_map_is_value t))
  ; by default, a value is a term that appears in the type enumeration
  (($smtx_is_value T t)             ($smt_apply_3 "ite" ($smt_is_dt T)
                                      ($smtx_dt_is_value t)
                                      ($smt_apply_1 "= sm.True"
                                        ($smt_try_eo 
                                         ($eo_is_value ($smt_apply_1 "eo.SmtType" T) t) 
                                         ($smd_eo.SmtTerm $smd_sm.False)))))
  )
)

;;; Model semantics

; Forward declaration of the main method defined by this signature.
; We use this to define $eo_model_sat.
(program $smtx_model_eval () :signature ($smt_Term) $smt_Term)

; free constants

; fwd-decl: $smtx_model_lookup
; Conceptually, returns the model value for constant with kind k, identifier id and type T.
; This is intentionally undefined in this signature.
(program $smtx_model_lookup ()
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_Type) $smt_Term)

; Lookup the predicate the constant can be assumed to have.
; If the kind is 0, it is an SMT-LIB input constant, we return true.
; Otherwise, we lookup the predicate for the skolem, which may be
; user-defined. Note this need not be a valid formula due to the
; definition of $smtx_model_eval, which checks whether the predicate
; is satisfied in the model.
; If this is undefined, we return true.
(define $smt_const_predicate ((k $smt_builtin_Int) (id $smt_builtin_Int) (T $smt_Type))
  ($smt_apply_3 "ite" ($smt_apply_2 "=" k 0) ; Kind 0 is reserved for uninterpreted constants.
    true
    ($smt_try_eo ($eo_const_predicate k id ($smd_eo.SmtTerm T)) true)))

; program: $smtx_substitute
; Used to define $smtx_eval_quant.
(program $smtx_substitute
  ((x $smt_Term) (y $smt_Term) (f $smt_Term) (a $smt_Term) (z $smt_Term))
  :signature ($smt_Term $smt_Term $smt_Term) $smt_Term
  (
  (($smtx_substitute x y (f a))         (_ ($smtx_substitute x y f) ($smtx_substitute x y a)))
  (($smtx_substitute x y x)             y)
  (($smtx_substitute x y z)             z)
  )
)

; program: $smtx_eval_quant
; specification for exists is a (non-computable) function
; The last argument is whether we are check exists (resp. forall).
(program $smtx_eval_quant ((T Type) (x T) (xs @sterm_list) (F $smt_Term) (i $smt_builtin_Int) (isExists Bool))
  :signature (@sterm_list $smt_Term $smt_builtin_Int Bool) Bool
  (
  (($smtx_eval_quant @sterm_list_nil F i isExists)
    ; base case: we have processed all variables, recurse, negate if isExists is false.
    ($smt_apply_2 "=" ($smtx_model_eval F) isExists))  ; we are now fully instantiated, look at the body
  (($smtx_eval_quant (@sterm_list_cons x xs) F i isExists)
    ; get the next value in the type enumeration
    (eo::define ((next ($smtx_enum_type ($smtx_typeof x) i)))
    ; if it exists
    ($smt_apply_3 "ite" (eo::is_ok next)
      ; evaluate the body for this value. if this is a forcing value, return it
      ($smt_apply_3 "ite" ($smt_apply_2 "=" ($smtx_model_eval ($smtx_substitute x next F)) isExists)
        isExists
        ; otherwise recurse for the next value in the type enumeration for the current variable
        ($smtx_eval_quant (@sterm_list_cons x xs) F (eo::add i 1) isExists))
      (eo::not isExists)))) ; out of values.
  )
)

;(program $smtx_eval_apply
;  ((T Type) (U Type) (i T) (j T) (e U) (tail (@map T U)))
;  :signature ($smt_Term $smt_Term) $smt_Term
;  (
;  ; NOTE: the cases here are exhaustive, meaning we can soundly ignore the "is nil" else condition
;  (($smtx_eval_apply (@map_cons T U i e tail) i)  e)
;  (($smtx_eval_apply (@map_cons T U j e tail) i)  ($smtx_eval_apply tail i))
;  (($smtx_eval_apply (@map_nil T U e) i)          e)
;  )
;)

;;; Core definition of $smtx_model_eval

; For example:
; ($smt_eval_= Int ($smt_from_eo_z x1) ($smt_from_eo_z x2) (= x1 x2)).
(define $smt_eval_=
  ((B Type :implicit) (W Type) (x1 W) (x2 W) (u B))
  ($smt_apply_3 "ite" ($smt_apply_2 "and" ($smtx_is_value W x1) ($smtx_is_value W x2))
    ($sm_mk_bool ($smt_apply_2 "=" x1 x2))
    u))

; For example:
; ($smt_eval_apply_2
;   "and"
;   ($smt_from_eo_bool x1) $smt_is_bool
;   ($smt_from_eo_bool x2) $smt_is_bool
;   ($eo_mk_bool (and x1 x2))
; Is the call to evaluate the SMT-LIB and from Eunoia.
; The last term is what is returned if the call is unevaluated.
(define $smt_eval_apply_1
  ((W1 Type :implicit) (R Type :implicit) (op $smt_String)
  (x1 W1) (d1 (-> W1 Bool))
  (r (-> $smt_Term R)) (u R))
  ($smt_apply_3 "ite" (d1 x1)
    (r ($smt_apply_1 op x1))
    u))
(define $smt_eval_apply_2
  ((W1 Type :implicit) (W2 Type :implicit) (R Type :implicit) (op $smt_String)
  (x1 W1) (d1 (-> W1 Bool))
  (x2 W2) (d2 (-> W2 Bool))
  (r (-> $smt_Term R)) (u R))
  ($smt_apply_3 "ite" (eo::and (d1 x1) (d2 x2))
    (r ($smt_apply_2 op x1 x2))
    u))
(define $smt_eval_apply_3
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (R Type :implicit) (op $smt_String)
  (x1 W1) (d1 (-> W1 Bool))
  (x2 W2) (d2 (-> W2 Bool))
  (x3 W3) (d2 (-> W3 Bool))
  (r (-> $smt_Term R)) (u R))
  ($smt_apply_3 "ite" (eo::and (d1 x1) (d2 x2))
    (r ($smt_apply_3 op x1 x2 x3))
    u))

; An evaluator for all terms that we can reason about models.
; This is a recursive call.
(program $smtx_model_eval
  ((T Type) (U Type) (V Type) (a1 T) (a2 T) (c Bool) (f $smt_Term) (y U) (z T) (k $smt_Numeral) (i $smt_Numeral) (F Bool)
   ; generic parameters that may appear in terms to pattern match
   (W1 Type) (x1 W1) (W2 Type) (x2 W2) (W3 Type) (x3 W3))
  :signature ($smt_Term) $smt_Term
  (
  ; builtins
  (($smtx_model_eval $smd_sm.True)   $smd_sm.True)
  (($smtx_model_eval $smd_sm.False)  $smd_sm.False)
  ; TODO: equality, ite
  ; evaluation of standard SMT symbols
  ; These calls may only call one of the above macros:
  ; - $smtx_eval_quant
  ; - $smt_eval_o_arith_*,
  ; - $smt_eval_apply_*
;$SMT_EVAL_CASES_TEMP_REMOVE$
  ; Apply case
  ;(($smtx_model_eval ($smd_sm.Apply f y))   (eo::define ((fme ($smtx_model_eval f)))
  ;                                          (eo::define ((yme ($smtx_model_eval y)))
  ;                                            ($smtx_eval_apply fme yme))))
  ;; free constants
  ; These are given an arbitrary value by the model ($smtx_model_lookup).
  ; We then check if their property F is satisfied. If so, then they are
  ; interpreted to be this value. Otherwise, they are unevaluated.
  ; TODO: val can be assumed such that $smtx_is_value is true.
  ;(($smtx_model_eval ($smd_sm.Const k i T))  (eo::define ((val ($smtx_model_lookup k i T)))
  ;                                          (eo::define ((mpred ($smtx_model_eval ($smt_const_predicate k i T))))
  ;                                            ; note that mpred can never be stuck and should be a Bool at this point.
  ;                                            ($smt_apply_3 "ite" mpred val ($smd_sm.Const k i T)))))
  ; generic apply and base case.
  ; these do not insist that the term is a value.
  ; They call the user callback $eo_model_eval.
  ;(($smtx_model_eval (f y))                 (eo::define ((fme ($smtx_model_eval f)))
  ;                                          (eo::define ((yme ($smtx_model_eval y)))
  ;                                            ($smt_try_eo ($eo_model_eval (_ fme yme))
  ;
  ;                                            ))))
  (($smtx_model_eval z)                      ($smt_try_eo ($eo_model_eval z) ($smd_eo.SmtTerm z)))
  )
)

(program $eo_model_sat_internal ((b $smt_Term))
  :signature ($smt_Term) Bool
  (
  (($eo_model_sat_internal $smd_sm.True) true)
  (($eo_model_sat_internal b)            false)
  )
)
; program: $eo_model_sat
; note: Satisfied by the model if F evaluates to true.
(program $eo_model_sat ((F $smt_Term))
  :signature ($eo_Term) Bool
  (
  (($eo_model_sat ($smd_eo.SmtTerm F)) ($eo_model_sat_internal ($smtx_model_eval F)))
  )
)

; The SMT typeof function, which incorporates builtin SMT terms

(program $smtx_typeof
  ((T $smt_Type) (t $smt_Term) (k $smt_Numeral) (id $smt_Numeral))
  :signature ($smt_Term) $smt_Type
  (
  (($smtx_typeof ($smd_sm.Const k id T))  T)
  ; for all other user defined terms, we totalize using unknown sorts
  ; we use the hash so that all terms that do not type check have a new unknown sort.
  (($smtx_typeof t)                      ($smt_try_eo ($eo_typeof t) ($smd_tsm.UnknownSort (eo::hash t))))
  )
)
