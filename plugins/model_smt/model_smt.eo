
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_eo_embed

;;; Eunoia datatype constructors

; The Eunoia representation of an SMT-LIB term.
; declare $eo_smt_term
; - already declared in eo_builtin_smt.eo

; The Eunoia representation of an SMT-LIB type.
; declare $eo_smt_type
; - already declared in eo_builtin_smt.eo

; The Eunoia representation of an SMT-LIB value.
(declare-parameterized-const $smd_eo.SmtValue ((t $smt_Type :opaque)) $eo_Term)
(define $eo_smt_value ((T $smt_Type)) ($smd_eo.SmtValue T))

;;; SMT term datatype constructors

; An application of SMT-LIB terms.
(declare-parameterized-const $smd_sm.Apply
  ((t1 $smt_Term :opaque) (t2 $smt_Term :opaque)) $smt_Term)
(define $sm_apply_term ((t1 $smt_Term) (t2 $smt_Term))
  ($smd_sm.Apply t1 t2))
  
; A skolem, identified by kind, identifier and Type.
; The kind 0 is reserved for standard SMT-LIB symbols introduced
; by the user by declare-const. The other kinds of free symbols
; can be custom defined based on the Eunoia signature (see method
; $eo_const_predicate in model_eo.eo).
; A skolem is identified by a type, a term and a kind.
(declare-parameterized-const $smd_sm.Skolem
  ((T $smt_Type :opaque) (k $smt_Term :opaque) (id $smt_builtin_Int :opaque))
  $smt_Term)
(define $sm_skolem
  ((k $smt_builtin_Int) (id $smt_builtin_Int) (T $smt_Type))
  ($smd_sm.Skolem k id T))

; A free constant
(declare-parameterized-const $smd_sm.Const
  ((T $smt_Type :opaque) (id $smt_builtin_Int :opaque))
  $smt_Term)
(define $sm_const ((T $smt_Type) (id $smt_builtin_Int))
  ($smd_sm.Const T id))
  
;;; SMT type datatype constructors

; The Boolean type
(declare-const $smd_tsm.Bool $smt_Type)
(define $tsm_Bool () $smd_tsm.Bool)

; Function types
(declare-parameterized-const $smd_tsm.FunType
  ((T1 $smt_Type :opaque) (T2 $smt_Type :opaque)) $smt_Type)
(define $tsm_fun_type ((T1 $smt_Type) (T2 $smt_Type))
  ($smd_tsm.FunType T1 T2))
  
; Uninterpreted sorts
(declare-parameterized-const $smd_tsm.USort
  ((id $smt_builtin_Int :opaque)) $smt_Type)
(define $tsm_USort ((id $smt_builtin_Int)) ($smd_tsm.USort id))
  
; The sort of a term that doesn't have an SMT-LIB type.
; This is used as an error condition
(declare-const $smd_tsm.NullSort $smt_Type)
(define $tsm_NullSort () $smd_tsm.NullSort)

;;; SMT value datatype constructors

; Datatype for values.
; - The datatype @Value will be replaced by vsm.new.Value.
(declare-datatypes ((@Value 0) (@Map 0))
  ((
  ; map with an index type
  ; valueness: $smtx_map_is_value
  (@Value.Map (@Value.Map.arg1 @Map) (@Value.Map.arg2 $smt_Type))
  ; uninterpreted constants 
  ; valueness: $smtx_usort_is_value
  (@Value.UConst (@Value.UConst.arg1 $smt_Type) (i $smt_builtin_Int))
  ; an SMT value represented by an SMT-LIB term, e.g. Int/Real/String.
  ; valueness: $smtx_is_value
  (@Value.Term (@Value.Term.arg1 $smt_Term))
  ; A non-value
  (@Value.NotValue)
  )
  (
  ; (@Map.cons i e M) maps i -> e, as well as mappings in M
  (@Map.cons (@Map.cons.arg1 @Value) (@Map.cons.arg2 @Value) (@Map.cons.arg3 @Map))
  ; (@Map.default e) maps all remaining elements in the sort to e
  (@Map.default (@Map.default.arg1 @Value))
  ))
)
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare-const $smt_builtin_sm.new.Term Type)

;;; Deep embedding of SMT-LIB terms




; represents an uninterpreted value
(declare-parameterized-const $smt_builtin_@Value.UConst
  ((T $smt_Type :opaque) (i $smt_builtin_Int :opaque)) $smt_Value)


; For each relevant user term, return the datatype above that it belongs to.
; This program will be used in the smt_meta_reduce compilation step, and
; will dissappear in the final signature.
; TODO: fill in this function????
(program $eo_get_meta_type ((T Type) (U Type) (t T) (f (-> U T)) (a U))
  :signature (T) Type
  (
$SMT_EMBED_META_TYPE_DECL$
  ;(($eo_get_meta_type (f a)) ($eo_get_meta_type f))
  ; otherwise, assume eo.new.Term
  (($eo_get_meta_type t) $eo_Term)
  )
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_eo

; This portion gives a template for defining the model semantics of
; a Eunoia signature. The signature model_smt.eo uses this signature
; to define (a user extension of) the standard SMT-LIB semantics.
;
; In the end we define:
; <user signature>
; <this file, instantiated based on the above signature>
; <model_smt.eo>
;
; Note that we instantiate model_smt.eo directly (SMT_EVAL_CASES)
; based on a controlled template, namely which standard SMT-LIB operators
; are present in the user signature, where *names* are taken literally.
; That is, if the user declares "+", then it may appear in the model
; evaluation function in the instantiated version of model_smt.eo.

; INVARIANT:
; All methods in this signature that take at least one $eo_Term as argument
; must return $eo_Term as the result.

; Returns true if its argument is an SMT value.
; This function is expected to never get stuck.
; NOTE: this has to return an $eo_Term since the arugments are $eo_Term.
(program $eo_is_value ((T $eo_Term) (t $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
$EO_IS_VALUE_CASES$
  (($eo_is_value T t) $eo_stuck)
  )
)

; Requires:
; - $eo_is_type to return true for all CPC types that are either polymorphic or not SMT-LIB standard.
; - $eo_type_enum for CPC types that are either polymorphic or not SMT-LIB standard.

; Returns true if T is a type that a term may take.
(program $eo_is_type ((T $eo_Term))
  :signature ($eo_Term) $eo_Term
  (
$EO_IS_TYPE_CASES$
  ; We do not handle this type.
  ; This statement rejects any type that is not in our signature.
  ; In other words, this limits the scope of which syntactic terms
  ; we are testing in our verification conditions. It is thus important
  ; that this method is complete (which in turn ensures the verification
  ; pipeline is sound).
  (($eo_is_type T) $eo_stuck)
  )
)

; type enumeration

; note: The methods in this section are only included (based on trim-defs) if
; the verification condition is reasoning about quantified formulas

; we have no incorporate of irrational values, which can be soundly approximated using
; $vsm_UValue.
;(define $smt_irrat_enum ((i $smt_Numeral))
;  ($vsm_UValue $smt_Rational i))

; NOTE: the "stuckness" of this method defines cardinality for types!!!!!!!
; Thus it is different from the other methods in this signature, which use
; stuckness as a no-op in a callback.
(program $eo_enum_type ((T $eo_Term) (i $smt_builtin_Int))
  :signature ($eo_Term $smt_builtin_Int) $eo_Term
  (
  ; enumeration of standard SMT types
  ;(($eo_enum_type $smt_Numeral i)     (eo::define ((v (eo::zdiv i 2)))
  ;                                      ($smt_apply_3 "ite" ($smt_apply_2 "=" (eo::zmod i 2) 0) v (eo::neg v))))
  ;(($eo_enum_type $smt_String i)      ($smt_apply_3 "ite" ($smt_apply_2 "=" i 0)
  ;                                      ""
  ;                                      (eo::concat (eo::to_str (eo::zmod i 196608)) ($eo_enum_type $smt_String (eo::zdiv i 196608)))))
  ; rationals are treated as Real, meaning we interleave rational/irrational.
  ;(($eo_enum_type $smt_Rational i)    (eo::define ((ir (eo::zdiv i 2)))
  ;                                    (eo::define ((isRat ($smt_apply_2 "=" (eo::zmod ir 2) 0)))
  ;                                    (eo::define ((i (eo::zdiv ir 2)))
  ;                                    (eo::define ((v ($smt_apply_3 "ite" isRat ($eo_rat_to_num ($smt_rat_enum i)) ($smt_irrat_enum i))))
  ;                                      ($smt_apply_3 "ite" ($smt_apply_2 "=" (eo::zmod i 2) 0) v (eo::neg v)))))))
  ; Note that $smt_BitVec must be mapped to the user's definition of binaries.
  ; Note this method gets stuck if i > 2^w, indicating we have run out of values.
  ;(($eo_enum_type ($smt_BitVec w) i) (eo::define ((v (eo::to_bin w i)))
  ;                                      (eo::requires (eo::to_z v) i v)))
  ; TODO: functions, datatypes
  ; Try to enumerate the type, if we fail, we return $vsm_UValue.
  ; Note that this essentially assumes that unhandled types are uninterpreted
  ; and have infinite cardinality (since this does not get stuck).
  ;(($eo_enum_type T i)                ($smt_builtin_eo.SmtValue ($smt_builtin_@Value.new.UConst T i)))
  ; FIXME
  (($eo_enum_type T i) T)
  )
)

; program: ($smtx_enum_type_contains_rec T t i)
; Returns true if t is contained in the type enumeration of T, starting from i.
;(program $eo_enum_type_contains_rec ((T $smt_Type) (t $smt_Term) (i $smt_builtin_Int))
;  :signature ($smt_Type $smt_Term $smt_builtin_Int) Bool
;  (
;  (($smtx_enum_type_contains_rec T t i)   (eo::define ((v ($smtx_enum_type T i)))
;                                          ($smt_apply_3 "ite" ($smt_apply_1 "$eo_is_ok" v)
;                                          ($smt_apply_3 "ite" ($smt_apply_2 "=" v t)
;                                            true
;                                            ($smtx_enum_type_contains_rec T i ($smt_apply_2 "+" i 1)))
;                                          false)))
;  )
;)

; Returns a predicate describing the properties of symbols
; that cannot be assigned a total semantics. For example,
; this is what defines skolem symbols.
(program $eo_const_predicate ((k $smt_builtin_Int) (i $smt_builtin_Int) (T $eo_Term) (x $eo_Term))
  :signature ($smt_builtin_Int $smt_builtin_Int $eo_Term $eo_Term) $eo_Term
  (
$EO_CONST_PREDICATE_CASES$
  ; return stuckness, this will be handled upstream
  (($eo_const_predicate k i T x) $eo_stuck)
  )
)

; This method can be used to define evaluation functions
; that cannot be described in terms of SMT-LIB conventions.
; TODO: not necessary for CPC?
(program $eo_model_eval ((t $eo_Term))
  :signature ($eo_Term) $eo_Term
  (
$EO_EVAL_CASES$
  ; return stuckness, this will be handled upstream
  (($eo_model_eval t) $eo_stuck)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_smt

; This file is a formalization of the SMT-LIB semantics in Eunoia.
; It uses a deep embedding of SMT-LIB terms .
; This file is expected to define function $eo_model_sat, which can be used 
; to define whether a (Boolean) term is satisfied by a model.
; It generates symbols $smt_Term, $sym_apply_*, $smt_from_eo_*, and $smt_to_eo_*,
; which have further meaning in the compilation pipeline.

; Invariant: all programs in this signature should be well-founded and never
; never get stuck unless otherwise stated.

; eo::is_ok is total, doesn't need to wrap in smt_try_eo
(define $smt_try_eo_ok ((T Type :implicit) (t T))
  ($smt_apply_2 "=" (eo::is_ok t) $eo_true))

; Utilities to ensure that programs are total.
; Takes
; - A $eo_Term t where we are not sure if it gets stuck.
; - A $eo_Term elseTerm where we are sure it does not get stuck.
; Returns the SMT term corresponding to the evaluation of t, if possible,
; or elseTerm otherwise. This always successfully evaluates.
(define $smt_try_eo ((t $eo_Term) (elseTerm $eo_Term))
  ($smt_apply_1 "eo.SmtTerm.arg1"
    ($smt_apply_3 "ite" ($smt_apply_1 "(_ is eo.SmtTerm)" t)
      t
      elseTerm)))
; Same as above, for SMT types.
(define $smt_try_eo_type ((t $eo_Term) (elseTerm $eo_Term))
  ($smt_apply_1 "eo.SmtType.arg1"
    ($smt_apply_3 "ite" ($smt_apply_1 "(_ is eo.SmtType)" t)
      t
      elseTerm)))

;;; SMT term list

; A list of SMT terms, defined as a datatype for convienience in this signature.
(declare-datatype @STermList
  (
  (@STermList_cons (@STermList_cons.arg1 $smt_Term) (@STermList_cons.arg2 @STermList))
  (@STermList_nil)
  )
)

; Concatenate lists of SMT terms.
(program $smtx_list_concat ((x $smt_Term) (y @STermList) (z @STermList))
  :signature (@STermList @STermList) @STermList
  (
  (($smtx_list_concat (@STermList_cons x y) z)  (@STermList_cons x ($smtx_list_concat y z)))
  (($smtx_list_concat @STermList_nil z)         z)
  )
)

;;; Rational pair

; A rational pair, used for enumerating reals
(declare-datatype @RatPair
  (
  (@RatPair_mk (@RatPair_mk.arg1 $smt_builtin_Int) (@RatPair_mk.arg2 $smt_builtin_Int))
  )
)

; TODO: lift
; Based on Calkinâ€“Wilf tree.
; NOTE: this method is only necessary if reasoning about the enumeration of Reals,
; this is only necessary if we are proving soundness of a proof rule that involves
; quantified reals.
;(program $eo_rat_enum_rec
;  ((i $smt_Numeral) (n $smt_Numeral) (d $smt_Numeral) (r @smt_RatPair) (rs @sterm_list))
;  :signature ($smt_Numeral @sterm_list) @smt_RatPair
;  (
;  (($eo_rat_enum_rec 0 (@sterm_list_cons r rs)) r)
;  (($eo_rat_enum_rec i (@sterm_list_cons (@smt_ratPair n d) rs))
;     (eo::define ((r1 (@smt_ratPair (eo::add n d) d)))
;     (eo::define ((r2 (@smt_ratPair n (eo::add n d))))
;      ($eo_rat_enum_rec (eo::add i -1)
;        ($eo_list_concat rs (@sterm_list_cons r1 (@sterm_list_cons r2 @sterm_list_nil)))))))
;  )
;)

;(define $smt_rat_enum ((i $smt_Numeral))
;  ($eo_rat_enum_rec i (@sterm_list_cons (@smt_ratPair 1 1) @sterm_list_nil)))

;(program $eo_rat_to_num ((n $smt_Numeral) (d $smt_Numeral))
;  :signature ($smt_Numeral) $smt_Rational
;  (
;  (($eo_rat_to_num (@smt_ratPair n d)) ($eo_qdiv n d))
;  )
;)

;;;;;; SMT values
  
; forward declaration
; This method classifies SMT terms as being values.
; The invariant of this method is that if
;   ($smt_Type t1) and ($smt_Type t2)
; return true where t1 and t2 have the same type ($smtx_typeof), then
;   (not (= t1 t2))
; is valid.
(program $smtx_is_value ()
  :signature ($smt_Type $smt_Term) $smt_builtin_Bool)

;;; Uninterpreted sort values.

; NOTE: this is equivalent to a datatype tester ((_ is sm.usort_value) t).
(define $smtx_is_usort_value ((x $smt_Term)) $smt_builtin_true)

; (@Value.UConst T i) is a value for all T, i.
(define $smtx_usort_is_value ((T $smt_Type) (i $smt_builtin_Int))
  $smt_builtin_true)

;;; Functions and array values.

; @Map is recursive and thus defined above.

; Get the default for the map
(program $smtx_map_default
  ((i @Value) (j @Value) (e @Value) (M @Map))
  :signature (@Map) $smt_Term
  (
  (($smtx_map_default (@Map.cons j e M))  ($smtx_map_default M))
  (($smtx_map_default (@Map.default e))   e)
  )
)

; This program looks up the value of a term in a map.
; This is used for function evaluation.
(program $smtx_map_lookup
  ((i @Value) (j @Value) (e @Value) (M @Map))
  :signature (@Map $smt_Term) $smt_Term
  (
  ; NOTE: the cases here are exhaustive, meaning we can soundly ignore the "is nil" else condition
  (($smtx_map_lookup (@Map.cons i e M) i)  e)
  (($smtx_map_lookup (@Map.cons j e M) i)  ($smtx_map_lookup M i))
  (($smtx_map_lookup (@Map.default e) i)   e)
  )
)

; This program determines whether the map value is canonical
; This program is only necessary if we are doing equality between arrays
; (or functions).
(program $smtx_map_is_redundant
  ((T $smt_Type) (U $smt_Type) (t $smt_Term) (u $smt_Term) (M @Map))
  :signature (@Map $smt_Type) $smt_builtin_Bool
  (
  (($smtx_map_is_redundant (@Map.default u) U)     false)
  (($smtx_map_is_redundant (@Map.cons t u M) U)
    ; lookup value on tail
    (eo::define ((ru ($smtx_map_lookup t M)))
    ; if it is the same, this index is redundant and thus we are not a value
    ($smt_apply_3 "ite"
      ($smt_apply_2 "=" ru u)
      $smt_builtin_false
      ($smtx_map_is_redundant M))))
  )
)

;;; Try to make a value

; Returns a term of type @Value, embeds the term
; if indeed it is a value, or returns not a value otherwise.
(define $smt_mk_value_term ((t $smt_Term))
  ($smt_apply_3 "ite"
    ($smtx_is_value t)
    (@Value.Term t)
    (@Value.NotValue)))
    
;;; utilities

; Used to totalize $eo_typeof.
(program $smtx_typeof () :signature ($smt_Term) $smt_Type)

;;; Definition of legal types

; Is T a type that can be assigned to free constants?
; Alternatively, is T a type that can be put in an equality?
; Note if $eo_is_type gets stuck, we assume the type is not legal.
; TODO: this may be unecessary
(define $smt_is_type ((T Type)) ($smt_try_eo ($eo_is_type T) false))

;;; Definitions of Type enumeration

; Since $smtx_methods never get stuck, all finite types must be defined in
; $eo_enum_type.
(program $smtx_enum_type ((T $smt_Type) (i $smt_builtin_Int))
  :signature ($smt_Type $smt_builtin_Int) $smt_Term
  (
  ; enumeration of standard SMT types
  ;(($smtx_enum_type $smt_builtin_Int i) (eo::define ((v ($smt_builtin_div i 2)))
  ;                                        ($smt_apply_3 "ite" ($smt_apply_2 "=" ($smt_builtin_mod i 2) 0)
  ;                                          v
  ;                                          ($smt_builtin_- v))))
  ;(($smtx_enum_type $smt_String i)      ($smt_apply_3 "ite" ($smt_apply_2 "=" i 0)
  ;                                      ""
  ;                                      (eo::concat (eo::to_str (eo::zmod i 196608)) ($smtx_enum_type $smt_String (eo::zdiv i 196608)))))
  ; rationals are treated as Real, meaning we interleave rational/irrational.
  ;(($smtx_enum_type $smt_Rational i)    (eo::define ((ir (eo::zdiv i 2)))
  ;                                    (eo::define ((isRat ($smt_apply_2 "=" (eo::zmod ir 2) 0)))
  ;                                    (eo::define ((i (eo::zdiv ir 2)))
  ;                                    (eo::define ((v ($smt_apply_3 "ite" isRat ($smtx_rat_to_num ($smt_rat_enum i)) ($smt_irrat_enum i))))
  ;                                      ($smt_apply_3 "ite" ($smt_apply_2 "=" (eo::zmod i 2) 0) v (eo::neg v)))))))
  
  ; TODO: functions, datatypes
  ; Try to enumerate the type, if we fail, we return an Uninterpreted sort value.
  ; Note that this essentially assumes that unhandled types are uninterpreted
  ; and have infinite cardinality (since this does not get stuck).
  ; (($smtx_enum_type T i)               ($vsm_UValue T i))
  ; FIXME!!!
  (($smtx_enum_type T i) T)
  )
)
(program $smtx_enum_type_final ((T $smt_Type) (i $smt_builtin_Int))
  :signature ($smt_Type $smt_builtin_Int) $smt_Value
  (
  ; TODO
  (($smtx_enum_type_final T i)               (@Value.UConst T i))
  )
)

;;; definitions of Values

; Datatypes are not embedded.

; define: $smt_is_dt
; returns: true if t is a datatpe (i.e. it has constructors).
(define $smt_is_dt ((t $smt_Type))
  ($smt_try_eo_ok ($eo_dt_constructors ($smt_apply_1 "eo.SmtType" t))))

; define: $smt_is_dt_cons
; returns: true if t is a constructor (i.e. it has selectors).
(define $smt_is_dt_cons ((t $smt_Term)) ($smt_try_eo_ok ($eo_dt_selectors t)))

; program: $smtx_dt_is_value
; Returns true if its argument is a datatype value.
; This checks that the term is constructed solely based on values and values of
; (possibly other) types.
(program $smtx_dt_is_value
  ((U Type) (T Type) (f (-> T U)) (a T) (c U))
  :signature ($smt_Term) $smt_builtin_Bool
  (
  (($smtx_dt_is_value ($sm_apply_term f a)) ($smt_apply_3 "ite" 
                                              ($smtx_is_value ($smtx_typeof a) a)
                                              ($smtx_dt_is_value f)
                                              $smt_builtin_false))
  (($smtx_dt_is_value c)                    ($smt_is_dt_cons c))
  )
)

; program: $smtx_is_value
; Returns true if its argument is an SMT value.
; This function is expected to never get stuck.
(program $smtx_is_value
  ((T $smt_Type) (U $smt_Type) (t $smt_Term) (n1 $smt_builtin_Int) (r1 $smt_builtin_Real) (s1 $smt_builtin_String))
  :signature ($smt_Type $smt_Term) $smt_builtin_Bool
  (
  ; if the literal type is not defined, this is false
  (($smtx_is_value $tsm_NullSort t)                                   $smt_builtin_false)
  (($smtx_is_value ($tsm_USort n1) t)                                 ($smtx_is_usort_value t))
  ; standard atomic types
  (($smtx_is_value $tsm_Bool $sm_mk_true)                         $smt_builtin_true)
  (($smtx_is_value $tsm_Bool $sm_mk_false)                        $smt_builtin_true)
  ; TODO: numeral, rational, string, (binary?)
  ;(($smtx_is_value @Map t)   ($smtx_map_is_value t))
  ; by default, a value is a term that appears in the type enumeration
  (($smtx_is_value T t)             ($smt_apply_3 "ite" ($smt_is_dt T)
                                      ($smtx_dt_is_value t)
                                      ($smt_apply_1 "= sm.True"
                                        ($smt_try_eo 
                                         ($eo_is_value ($smt_apply_1 "eo.SmtType" T) t) 
                                         ($eo_smt_term $sm_mk_false)))))
  )
)

;;; Model semantics

; Forward declaration of the main method defined by this signature.
; We use this to define $eo_model_sat.
(program $smtx_model_eval () :signature ($smt_Term) $smt_Term)

; free constants

; fwd-decl: $smtx_model_lookup
; Conceptually, returns the model value for constant with kind k, identifier id and type T.
; This is intentionally undefined in this signature.
(program $smtx_model_lookup ()
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_Type) $smt_Term)
  

; Lookup the predicate the constant can be assumed to have.
; If the kind is 0, it is an SMT-LIB input constant, we return true.
; Otherwise, we lookup the predicate for the skolem, which may be
; user-defined. Note this need not be a valid formula due to the
; definition of $smtx_model_eval, which checks whether the predicate
; is satisfied in the model.
; If this is undefined, we return true.
(program $smtx_const_predicate
  ((k $smt_builtin_Int) (id $smt_builtin_Int) (T $smt_Type) (val $smt_Term))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_Type $smt_Term) $smt_builtin_Bool
  (
  (($smtx_const_predicate k id T val)
    ($sm_is_true ; wrong
      ($smt_try_eo
        ($eo_const_predicate k id ($eo_smt_type T) ($eo_smt_term val))
        ($eo_smt_term $sm_mk_true))))
  )
)

; program: $smtx_substitute
; Used to define $smtx_eval_quant.
; TODO: debruijn
(program $smtx_substitute
  ((x $smt_Term) (y $smt_Term) (f $smt_Term) (a $smt_Term) (z $smt_Term))
  :signature ($smt_Term $smt_Term $smt_Term) $smt_Term
  (
  (($smtx_substitute x y (f a))         (_ ($smtx_substitute x y f) ($smtx_substitute x y a)))
  (($smtx_substitute x y x)             y)
  (($smtx_substitute x y z)             z)
  )
)

(program $smtx_model_lookup_predicate 
  ((T $smt_Type) (k $smt_builtin_Int) (id $smt_builtin_Int) (F $smt_Term) (t $smt_Term))
  :signature ($smt_Term) $smt_Value
  (
  (($smtx_model_lookup_predicate ($sm_const T id))   $smt_builtin_true)
  (($smtx_model_lookup_predicate ($sm_skolem T F k)) $smt_builtin_true) ; FIXME
  (($smtx_model_lookup_predicate t)                  $smt_builtin_false)
  )
)

; program: $smtx_eval_quant
; specification for exists is a (non-computable) function
; The last argument is whether we are check exists (resp. forall).
(program $smtx_eval_quant 
  ((T Type) (x T) (xs @STermList) (F $smt_Term) (i $smt_builtin_Int) (isExists $smt_builtin_Bool))
  :signature (@STermList $smt_Term $smt_builtin_Int $smt_builtin_Bool) $smt_builtin_Bool
  (
  (($smtx_eval_quant @STermList_nil F i isExists)
    ; base case: we have processed all variables, recurse, negate if isExists is false.
    ($smt_apply_2 "=" ($smtx_model_eval F) isExists))  ; we are now fully instantiated, look at the body
  (($smtx_eval_quant (@STermList_cons x xs) F i isExists)
    ; get the next value in the type enumeration
    (eo::define ((next ($smtx_enum_type ($smtx_typeof x) i)))
    ; if it exists
    ($smt_apply_3 "ite" (eo::is_ok next)
      ; evaluate the body for this value. if this is a forcing value, return it
      ($smt_apply_3 "ite" ($smt_apply_2 "=" ($smtx_model_eval ($smtx_substitute x next F)) isExists)
        isExists
        ; otherwise recurse for the next value in the type enumeration for the current variable
        ($smtx_eval_quant (@STermList_cons x xs) F ($smt_apply_1 "+ 1" i) isExists))
      ($smt_apply_1 "not" isExists)))) ; out of values.
  )
)

;;; Core definition of $smtx_model_eval

; An evaluator for all terms that we can reason about models.
; This is a recursive call.
; NOTE: for the sake of soundness, this must be a total function!!!!!!!
(program $smtx_model_eval
  ((T Type) (U Type) (V Type) (a1 T) (a2 T) (c Bool) (f $smt_Term) (y U) (z T) (k $smt_builtin_Int) (id $smt_builtin_Int) (F Bool)
   ; generic parameters that may appear in terms to pattern match
   (W1 Type) (x1 W1) (W2 Type) (x2 W2) (W3 Type) (x3 W3))
  :signature ($smt_Term) $smt_Term
  (
  ; builtins
  (($smtx_model_eval $sm_mk_true)             $sm_mk_true)
  (($smtx_model_eval $sm_mk_false)            $sm_mk_false)
  (($smtx_model_eval (ite x1 x2 x3))
    ($smt_apply_3 "ite" ($sm_is_true ($smtx_model_eval x1))
      ($smtx_model_eval x2)
      ($smtx_model_eval x3)))
  (($smtx_model_eval (= x1 x2))
    (eo::define ((e1 ($smtx_model_eval x1)))
    (eo::define ((e2 ($smtx_model_eval x2)))
    (eo::define ((T ($smtx_typeof x1)))
    ($smt_apply_3 "ite" ($smt_builtin_and ($smtx_is_value T x1) ($smtx_is_value T x2))
      ; use datatype equality
      ($sm_mk_bool ($smt_apply_2 "=" x1 x2))
      (= x1 x2))))))
  ; evaluation of standard SMT symbols
  ; These calls may only call one of the above macros:
  ; - $smtx_eval_quant
  ; - $smt_eval_o_arith_*,
  ; - $smt_eval_apply_*
$SMT_EVAL_CASES$
  ; Apply case
  ;(($smtx_model_eval ($sm_apply_term f y))   (eo::define ((fme ($smtx_model_eval f)))
  ;                                          (eo::define ((yme ($smtx_model_eval y)))
  ;                                            ($smtx_eval_apply fme yme))))
  ;; free constants and partial functions
  ; These are given an arbitrary value by the model ($smtx_model_lookup),
  ; which is an uninterpreted function. The properties of this value are
  ; axiomatized in the final SMT2.
  (($smtx_model_eval ($sm_const T id))    ($smtx_model_lookup $smt_builtin_z_zero id T))
  ;(($smtx_model_eval ($sm_kkolem T F))    ($smtx_model_lookup i i T))   ; FIXME
  ; generic apply and base case.
  ; these do not insist that the term is a value.
  
  ; Otherwise, try to evaluate based on the user callback
  (($smtx_model_eval z)                      ($smt_try_eo ($eo_model_eval z) ($eo_smt_term z)))
  )
)

(program $eo_model_sat_internal ((b $smt_Term))
  :signature ($smt_Term) Bool
  (
  (($eo_model_sat_internal $sm_mk_true) true)
  (($eo_model_sat_internal b)            false)
  )
)
; program: $eo_model_sat
; note: Satisfied by the model if F evaluates to true.
(program $eo_model_sat ((F $smt_Term))
  :signature ($eo_Term) Bool
  (
  (($eo_model_sat ($eo_smt_term F)) ($eo_model_sat_internal ($smtx_model_eval F)))
  )
)

; The SMT typeof function, which incorporates builtin SMT terms

(program $smtx_typeof
  ((T $smt_Type) (t $smt_Term) (F $smt_Term) (k $smt_builtin_Int) (id $smt_builtin_Int))
  :signature ($smt_Term) $smt_Type
  (
  (($smtx_typeof ($sm_const T id))     T)
  (($smtx_typeof ($sm_skolem T F id))  T)
  ; for all other user defined terms, we totalize using unknown sorts
  ; we use the hash so that all terms that do not type check have a new unknown sort.
  (($smtx_typeof t)                      ($smt_try_eo_type ($eo_typeof t) ($eo_smt_type $tsm_NullSort)))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_end
