; This file defines SMT-LIB model semantics in Eunoia.
; It has exception handling utilities to call Eunoia programs in
; a safe way that ensures that all programs in this signature are total.

; The programs in this file operate on datatypes that correspond to
; a deep embedding of Eunoia and SMT-LIB terms, types and values.
; In particular, we use the following types:
; 1. $eo_Term, the type of Eunoia terms.
; 2. $smt_Term, the type of SMT-LIB terms.
; 3. $smt_Type, the type of SMT-LIB types.
; 4. $smt_Value, the type of SMT-LIB values.
; 5. Further types defining specific SMT-LIB values, e.g. $smt_Map.
; 6. $smt_builtin_X, the builtin SMT-LIB type X.
; Note that the last type allows us to define symbols whose type
; will be a native SMT-LIB type in the final embedding generated
; by the smt-meta plugin.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Exception handling

; Invariant: all programs in this signature should be well-founded and never
; never get stuck unless otherwise stated.

; Utilities to ensure that programs are total.
; Takes
; - A $eo_Term t where we are not sure if it gets stuck.
; - A $eo_Term elseTerm where we are sure it does not get stuck.
; Returns the SMT term corresponding to the evaluation of t, if possible,
; or elseTerm otherwise. This always successfully evaluates.
(define $smt_try ((t $eo_Term) (elseTerm $eo_Term))
  ($smt_apply_3 "ite" ($smt_builtin_is_ok t)
    t
    elseTerm))

; Guarded execution of $eo_typeof.
(define $smt_try_typeof ((T Type :implicit) (t T))
  ($smt_try ($eo_typeof t) ($eo_smt_type ($tsm_NullSort $smt_builtin_z_zero))))

;;;;;; SMT values

; forward declaration
; This method classifies SMT terms as being values.
; The invariant of this method is that if v1 and v2
; return true where v1 and v2 have the same type ($smtx_typeof),
; and are distinct, then they denote semantically distinct
; values.
(program $smtx_is_value ()
  :signature ($smt_Value) $smt_builtin_Bool)

;;; Functions and array values.

; $smt_Map is recursive and thus defined above.

; Get the default for the map
(program $smtx_map_default
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (M $smt_Map))
  :signature ($smt_Map) $smt_Value
  (
  (($smtx_map_default ($msm_cons j e M))  ($smtx_map_default M))
  (($smtx_map_default ($msm_default e))   e)
  )
)

; This program looks up the value of a term in a map.
; This is used for function evaluation.
(program $smtx_map_lookup
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (M $smt_Map))
  :signature ($smt_Map $smt_Value) $smt_Value
  (
  ; NOTE: the cases here are exhaustive
  (($smtx_map_lookup ($msm_cons i e M) i)  e)
  (($smtx_map_lookup ($msm_cons j e M) i)  ($smtx_map_lookup M i))
  (($smtx_map_lookup ($msm_default e) i)   e)
  )
)

; This program determines whether the map value is canonical
; This program is only necessary if we are doing equality between arrays
; (or functions).
(program $smtx_map_is_redundant
  ((T $smt_Type) (U $smt_Type) (t $smt_Value) (u $smt_Value) (M $smt_Map))
  :signature ($smt_Map $smt_Type) $smt_builtin_Bool
  (
  (($smtx_map_is_redundant ($msm_default u) U)     $smt_builtin_false)
  (($smtx_map_is_redundant ($msm_cons t u M) U)
    ; lookup value on tail
    ; if it is the same, this index is redundant and thus we are not a value
    ($smt_apply_3 "ite"
      ($smt_apply_= ($smtx_map_lookup t M) u)
      $smt_builtin_true
      ($smtx_map_is_redundant M)))
  )
)

; TODO: use $smtx_map_is_redundant.
; Also requires a sortedness and non-exhaustiveness conditions.
(program $smtx_map_is_value ()
  :signature ($smt_builtin_Int $smt_Map) $smt_builtin_Bool)

;;; Utilities for Datatype values

; define: $smt_is_dt
; returns: true if t is a datatpe (i.e. it has constructors).
(define $smt_is_dt ((t $smt_Type))
  ($smt_builtin_is_ok ($eo_dt_constructors t)))

; define: $smt_is_dt_cons
; returns: true if t is a constructor (i.e. it has selectors).
(define $smt_is_dt_cons ((t $smt_Term))
  ($smt_builtin_is_ok ($eo_dt_selectors t)))

;;; Term values.

; program: $smtx_term_is_value
; Returns true if its argument is an SMT value.
; This function is expected to never get stuck.
; Note that this does not take a type. This function must ensure
; that if it returns true for two terms t1 and t2 of the same type,
; then t1 != t2 in all models.
(program $smtx_term_is_value
  ((t $smt_Term) (b $smt_builtin_Bool) (n $smt_builtin_Int) (r $smt_builtin_Real) (s $smt_builtin_String))
  :signature ($smt_Term) $smt_builtin_Bool
  (
  ; standard atomic types are values
  (($smtx_term_is_value ($sm_mk_bool b))  $smt_builtin_true)
  (($smtx_term_is_value ($sm_mk_z n))     $smt_builtin_true)
  (($smtx_term_is_value ($sm_mk_q r))     $smt_builtin_true)
  (($smtx_term_is_value ($sm_mk_str s))   $smt_builtin_true)
  ; by default, not a value
  (($smtx_term_is_value t)                $smt_builtin_false)
  )
)

;;; Guarded utilities for making values

; Returns a term of type $smt_Value, embeds the term
; if indeed it is a value, or returns not a value otherwise.
(define $smt_mk_value_term ((t $smt_Term))
  ($smt_apply_3 "ite" ($smtx_term_is_value t)
    ; an atomic term, e.g. 0, true, "abc"
    ($vsm_term t)
    ($smt_apply_3 "ite" ($smt_is_dt_cons t)
      ; a datatype constructor, which becomes a (nil-terminated) vsm_apply
      ($vsm_apply ($vsm_term t) $vsm_not_value)
      $vsm_not_value)))

(define $smt_mk_value_map ((T $smt_builtin_Int) (m $smt_Map))
  ($smt_apply_3 "ite"
    ($smtx_map_is_value T m)
    ($vsm_map T m)
    $vsm_not_value))

; program: $smtx_is_value
(program $smtx_is_value
  ((t $smt_Term) (f $smt_Value) (v $smt_Value) (T $eo_Term) (m $smt_Map)
   (T $smt_builtin_Int) (id $smt_builtin_Int))
  :signature ($smt_Value) $smt_builtin_Bool
  (
  (($smtx_is_value ($vsm_term t))         ($smtx_term_is_value t))
  (($smtx_is_value ($vsm_map T m))        ($smtx_map_is_value T m))
  (($smtx_is_value ($vsm_uconst T id))    $smt_builtin_true)
  ; Herbrand interpretations: nil terminated apply of value terms
  (($smtx_is_value ($vsm_apply ($vsm_term t) $vsm_not_value))
                                          ($smt_is_dt_cons t))
  (($smtx_is_value ($vsm_apply f v))      ($smt_apply_2 "and" ($smtx_is_value f) ($smtx_is_value v)))
  ; Otherwise false
  (($smtx_is_value v)                     $smt_builtin_false)
  )
)

; program: $smtx_ensure_value
; args:
; - v $smt_Value: A value term.
; return: >
;   v itself if it denotes a proper SMT-LIB value, or $vsm_not_value otherwise.
(program $smtx_ensure_value
  ((v $smt_Value) (t $smt_Term) (T $smt_builtin_Int) (m $smt_Map) (id $smt_builtin_Int))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_ensure_value ($vsm_term t))         ($smt_mk_value_term t))
  (($smtx_ensure_value ($vsm_map T m))        ($smt_mk_value_map T m))
  (($smtx_ensure_value ($vsm_uconst T id))    ($vsm_uconst T id))
  (($smtx_ensure_value v)                     $vsm_not_value)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program $smtx_enum_type ((T $eo_Term) (i $smt_builtin_Int))
  :signature ($eo_Term $smt_builtin_Int) $smt_Value
  (
  ; otherwise, uninterpreted constant.
  (($smtx_enum_type T i)               ($vsm_uconst T i))
  )
)


;;; Model semantics

; Forward declaration of the main method defined by this signature.
; We use this to define $eo_model_sat.
(program $smtx_model_eval () :signature ($eo_Term) $smt_Value)

; program: $smtx_model_lookup
; Conceptually, returns the model value for a term whose value is
; partially constrained or unconstrained in the model. This is
; intentionally undefined. For example, we may pass the following
; terms to this method:
;   (sm.Apply (sm.Apply sm./ x1) x2), when M(x2) = 0,
;   TODO: skolems??
(program $smtx_model_lookup ()
  :signature ($smt_Term) $smt_Value)

; Lookup the predicate the constant can be assumed to have.
; These should be valid formulas.
(program $smtx_model_lookup_predicate_internal ((t $smt_Term) (v $smt_Value))
  :signature ($smt_Term $smt_Value) $smt_builtin_Bool
  (
$SMT_MODEL_LOOKUP_PREDICATE_CASES$
  ; otherwise, no predicate
  (($smtx_model_lookup_predicate_internal t v) $smt_builtin_true)
  )
)

; Calls the method above
(program $smtx_model_lookup_predicate ((t $smt_Term))
  :signature ($smt_Term) $smt_builtin_Bool
  (
  (($smtx_model_lookup_predicate t)
    ($smtx_model_lookup_predicate_internal t ($smtx_model_lookup t)))
  )
)

; program: $smtx_substitute
; Used to define $smtx_eval_quant.
; TODO: debruijn
(program $smtx_substitute
  ((x $eo_Term) (y $eo_Term) (f $eo_Term) (a $eo_Term) (z $eo_Term))
  :signature ($eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($smtx_substitute x y (f a))   (_ ($smtx_substitute x y f) ($smtx_substitute x y a)))
  (($smtx_substitute x y x)       y)
  (($smtx_substitute x y z)       z)
  )
)

;;; Core definition of $smtx_model_eval

; program: $smtx_model_eval_apply
; We call ($smtx_model_eval_apply value_f value_i) when
; evaluating (f i) whose values are value_f and value_i
; respectively. If value_f is a map value, then we extract
; the map and call the map lookup routine.
(program $smtx_model_eval_apply
  ((T $smt_builtin_Int) (m $smt_Map) (i $smt_Value) (f $smt_Value) (v $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  ; If a Herbrand interpretation, apply it to the next value.
  (($smtx_model_eval_apply ($vsm_apply f v) i)  ($vsm_apply ($vsm_apply f v) i))
  ; The function evaluated to a map value, call the map lookup.
  (($smtx_model_eval_apply ($vsm_map T m) i)    ($smtx_map_lookup m i))
  ; The function did not evaluate to a map value, we fail.
  (($smtx_model_eval_apply v i)                 $vsm_not_value)
  )
)

; return: The evaluation of an ite application.
(program $smtx_model_eval_ite
  ((t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value

  (
  (($smtx_model_eval_ite $vsm_true t2 t3)   t2)
  (($smtx_model_eval_ite $vsm_false t2 t3)  t3)
  (($smtx_model_eval_ite t1 t2 t3)          $vsm_not_value)
  )
)

; return: The evaluation of an equality application.
(program $smtx_model_eval_=
  ((t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value

  (
  (($smtx_model_eval_= $vsm_not_value t2) $vsm_not_value)
  (($smtx_model_eval_= t1 $vsm_not_value) $vsm_not_value)
  ; use datatype equality over $smt_Value, which depends on t1 and t2 being proper values.
  (($smtx_model_eval_= t1 t2)             ($vsm_term ($sm_mk_bool ($smt_apply_= t1 t2))))
  )
)

; program: $smtx_eval_quant
; specification for exists is a (non-computable) function
; The last argument is whether we are check exists (resp. forall).
(program $smtx_eval_quant
  ((x $eo_Term) (xs $eo_List) (F $eo_Term) (i $smt_builtin_Int) (isExists $smt_builtin_Bool))
  :signature ($eo_List $eo_Term $smt_builtin_Int $smt_builtin_Bool) $smt_Value
  (
  (($smtx_eval_quant $eo_List_nil F i isExists)
    ; base case: we have processed all variables, recurse, negate if isExists is false.
    ($vsm_term ($sm_mk_bool ($smt_apply_= ($smtx_model_eval F) ($eo_mk_bool isExists)))))  ; we are now fully instantiated, look at the body
  (($smtx_eval_quant ($eo_List_cons x xs) F i isExists)
    ; get the next value in the type enumeration
    (eo::define ((next ($smtx_enum_type ($eo_model_typeof x) i)))
    ; if it exists
    ($smt_apply_3 "ite" ($smt_builtin_is_ok next)
      ; evaluate the body for this value. if this is a forcing value, return it
      ($smt_apply_3 "ite" ($smt_apply_= ($smtx_model_eval ($smtx_substitute x next F)) ($eo_mk_bool isExists))
        ($vsm_term ($sm_mk_bool isExists))
        ; otherwise recurse for the next value in the type enumeration for the current variable
        ($smtx_eval_quant ($eo_List_cons x xs) F ($smt_apply_1 "+ 1" i) isExists))
      ($vsm_term ($sm_mk_bool ($smt_apply_1 "not" isExists)))))) ; out of values.
  )
)

$SMT_EVAL_PROGS$

; An evaluator for all terms that we can reason about models.
; This is a recursive call.
; invariant: this must be a total function
; invariant: unless this method returns $vsm_not_value, it must be such that
;            it represents a unique SMT-LIB value, i.e. ($vsm_term t) is
;            forbidden unless t denotes a value.
(program $smtx_model_eval
  ((f $eo_Term) (y $eo_Term) (z $eo_Term)
   (val $smt_Value)
   ; generic parameters that may appear in terms to pattern match
   (x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term) (x4 $eo_Term) (x5 $eo_Term))
  :signature ($eo_Term) $smt_Value
  (
  ; ITE branches to the appropriate child.
  (($smtx_model_eval (ite x1 x2 x3))
    ($smtx_model_eval_ite ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  ; Equality insists on valueness and then reduces to an equality over datatypes
  ; in the deep embedding (vsm.Value), meaning it works for all types, including
  ; functions and uninterpreted sorts where values are not represented by terms.
  ; Note that the valueness predicate ensures this is sound. Moreover note that
  ; we do not invoke the type checker here. This means that if an ill-typed
  ; equality was given as input to this method, it would always evaluate to false.
  ; The caller of this method is responsible for ensuring that this behavior is
  ; either avoided or admissible.
  (($smtx_model_eval (= x1 x2))
    ($smtx_model_eval_= ($smtx_model_eval x1) ($smtx_model_eval x2)))
  ; evaluation of standard SMT symbols
  ; These calls will reference helper methods above, e.g. of the form
  ; $smtx_model_eval_*, or call builtin methods e.g. $smtx_eval_quant.
$SMT_EVAL_CASES$

  ;; free constants
  ; Constants carry their value in the model, which is an arbitrary value term.
  ; We run this value through $smtx_ensure_value to ensure it is a proper value.
  (($smtx_model_eval ($sm_Const val))           ($smtx_ensure_value val))
  
  ; Apply case. We evaluate f and y separately and then call the
  ; $smtx_model_eval_apply above. We expect f to be an uninterpreted
  ; function whose model evaluation is an SMT-LIB map in this case.
  ; All interpreted f should be handled in the evaluation cases above.
  (($smtx_model_eval (f y))
    ($smtx_model_eval_apply ($smtx_model_eval f) ($smtx_model_eval y)))

  ; Otherwise, it may be a term value (e.g. if z is a Boolean or numeral constant).
  ; We call the utility method which will either generate an SMT-LIB term value or
  ; a SMT-LIB non-value error term.
  (($smtx_model_eval z)                         ($smt_mk_value_term z))
  )
)

; program: $smtx_model_sat
(program $smtx_model_sat ((val $smt_Value))
  :signature ($smt_Value) $eo_Option
  (
  (($smtx_model_sat $vsm_true)  ($eo_Option_some true))
  (($smtx_model_sat $vsm_false) ($eo_Option_some false))
  (($smtx_model_sat val)        $eo_Option_null)
  )
)

; program: $smtx_model_sat_combined
; args:
; - isInput Bool: Whether it is legal SMT-LIB input syntax.
; - T Type: Its type.
; - val $smt_Value: The result of model value.
(program $smtx_model_sat_combined ((b Bool) (T Type) (val $smt_Value))
  :signature (Bool Type $smt_Value) $eo_Option
  (
  (($smtx_model_sat_combined true Bool $vsm_true)  ($eo_Option_some true))
  (($smtx_model_sat_combined true Bool $vsm_false) ($eo_Option_some false))
  (($smtx_model_sat_combined b T val)        $eo_Option_null)
  )
)

;;; type of

; forward decl
(program $smtx_typeof () :signature ($eo_Term) $eo_Term)
(program $smtx_typeof_value () :signature ($smt_Value) $eo_Term)

; note: Helper for below.
(program $smtx_typeof_map ((T $smt_builtin_Int) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($eo_Term $smt_Map) $eo_Term
  (
  (($smtx_typeof_map T ($msm_cons j e m))   ($eo_mk_fun_type ($eo_reverse_hash ($eo_mk_numeral T)) ($smtx_typeof_value e)))
  (($smtx_typeof_map T ($msm_default e))    ($eo_mk_fun_type ($eo_reverse_hash ($eo_mk_numeral T)) ($smtx_typeof_value e)))
  )
)

; note: Helper for below. This is analogous to the method $eo_typeof_apply
(program $smtx_typeof_apply ((T $eo_Term) (U $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($smtx_typeof_apply ($eo_mk_fun_type T U) T) U)
  )
)

(program $smtx_typeof_value
  ((val $smt_Value) (T $smt_builtin_Int) (m $smt_Map) (id $smt_builtin_Int) (f $smt_Value) (a $smt_Term) (U $smt_Type))
  :signature ($smt_Value) $eo_Term
  (
  (($smtx_typeof_value ($vsm_apply f val))
    ($smtx_typeof_apply ($smtx_typeof_value f) ($smtx_typeof_value val)))
  ; the type of a value term is the type of its term.
  (($smtx_typeof_value ($vsm_term a))         ($smtx_typeof ($eo_smt_term a)))
  (($smtx_typeof_value ($vsm_map T m))        ($smtx_typeof_map T m))
  ; the type of uninterpreted constants carry its type.
  (($smtx_typeof_value ($vsm_uconst T id))    ($eo_reverse_hash ($eo_mk_numeral T)))
  ; the type of not-values is the null sort.
  (($smtx_typeof_value val)                   ($tsm_NullSort $smt_builtin_z_zero))
  )
)

; The EO model typeof function, which incorporates SMT terms introduced in the
; model_smt layer.
; This is intended to cover all Eunoia and SMT terms (those of the form
; (eo.SmtTerm *). Since values are embedded into SMT terms, we cover SMT values,
; i.e. those of the form (eo.SmtValue *) as well.
; Furthermore note:
; - (SMT terms in $eo_typeof_main): sm.True, sm.False
; - (SMT terms in $eo_typeof): sm.Numeral, sm.Rational, sm.String, sm.Binary
; - (SMT terms handled below): sm.Const, sm.Apply
; - (EO terms in $eo_typeof_main): eo.Type, eo.FunType, eo.Apply
; - (EO terms in $eo_typeof): eo.Var
; - (EO terms intentionally unhandled): eo.Stuck, eo.SmtType
; invariant: all terms introduced by this layer must be given a type rule here.
; TODO: use hash for the nullsort below?
(program $smtx_typeof
  ((t $eo_Term) (val $smt_Value) (T $eo_Term) (m $smt_Map) (id $smt_builtin_Int)
   (f $smt_Value) (a $smt_Term) (U $smt_Type))
  :signature ($eo_Term) $eo_Term
  (
  ; the type of an atomic type uses Eunoia's typeof builtin, or null sort if this fails.
  (($smtx_typeof ($eo_smt_type U))                    ($smt_try_typeof U))
  ; the type of a constant is the type of its value.
  (($smtx_typeof ($eo_smt_term ($sm_Const val)))      ($smtx_typeof_value val))
  ; similar to above, we try Eunoia's typeof, or null sort.
  (($smtx_typeof ($eo_smt_term a))                    ($smt_try_typeof a))
  ; For all other terms, we try Eunoia's typeof, or null sort.
  (($smtx_typeof t)                                   ($smt_try_typeof t))
  )
)

;;; SMT input

; program: $smtx_is_input
(program $smtx_is_input
  ((t $eo_Term) (a $eo_Term) (s $smt_Term) (T $smt_Type) (v $smt_Value))
  :signature ($eo_Term) Bool
  (
  (($smtx_is_input ($eo_apply t a))
    ($eo_if_both ($smtx_is_input t) ($smtx_is_input a)))
  (($smtx_is_input ($eo_smt_term ($sm_Const v)))  ($eo_mk_bool ($smtx_is_value v)))
  (($smtx_is_input ($eo_smt_term s))              true)
  (($smtx_is_input ($eo_smt_type T))              true)
  (($smtx_is_input t)                             false)
  )
)

;;;;;;;;;;;;;;;;;;;;;;

; program: $eo_model_sat
; note: F is satisfied by the model if F evaluates to the SMT-LIB value denoting true.
; We expect the input to this method to be a Eunoia term denoting an SMT-LIB formula
; (term of Boolean type).
(program $eo_model_sat ((F Bool))
  :signature (Bool) $eo_Option
  (
  (($eo_model_sat F) ($smtx_model_sat ($smtx_model_eval F)))
  )
)

; program: $eo_model_typeof
; note: F is satisfied by the model if F evaluates to the SMT-LIB value denoting true.
; We expect the input to this method to be a Eunoia term denoting an SMT-LIB formula
; (term of Boolean type).
(program $eo_model_typeof ((F Bool))
  :signature (Bool) Type
  (
  (($eo_model_typeof F) ($smtx_typeof F))
  )
)

; program: $eo_model_is_input
; return: true if this is a legal SMT-LIB input term or type.
(program $eo_model_is_input ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_is_input F) ($smtx_is_input F))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_end
