; This file defines a deep embedding of SMT-LIB into Eunoia.
; It has the following uses:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin
;    Eunoia functions, e.g. $eo_add.
; 2. It is used to define the end signature for defining the model semantics of
;    SMT-LIB.

; The type of $smt_apply_* terms.
; If a term has this type, we know it is an SMT-LIB type,
; but we don't know which one from ordinary type checking.
(declare-const $smt_BuiltinType Type)

;;; Deep embedding of SMT-LIB operator applications into Eunoia

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_type_0
  (($smt_id Type :implicit) (op $smt_id :opaque))
  Type)
(declare-parameterized-const $smt_type_1
  (($smt_id Type :implicit) (W1 Type :implicit) (op $smt_id :opaque) (x1 W1 :opaque))
  Type)
(declare-parameterized-const $smt_type_2
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque))
  Type)
(declare-parameterized-const $smt_apply_0
  (($smt_id Type :implicit) (op $smt_id :opaque))
  $smt_BuiltinType)
(declare-parameterized-const $smt_apply_1
  (($smt_id Type :implicit) (W1 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_2
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_3
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_4
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit)
   (W3 Type :implicit) (W4 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_5
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit)
   (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque) (x5 W5 :opaque)) $smt_BuiltinType)

(define $smt_builtin_Bool () ($smt_type_0 "Bool"))
(define $smt_builtin_Int () ($smt_type_0 "Int"))
(define $smt_builtin_Real () ($smt_type_0 "Real"))
; Assumes Rat is defined as Real.
(define $smt_builtin_Rat () ($smt_type_0 "Rat"))
(define $smt_builtin_String () ($smt_type_0 "String"))
(define $smt_builtin_RegLan () ($smt_type_0 "RegLan"))
(define $smt_builtin_true () ($smt_apply_0 "true"))
(define $smt_builtin_false () ($smt_apply_0 "false"))
(define $smt_builtin_ite ((W Type :implicit) (b $smt_builtin_Bool) (x1 W) (x2 W)) ($smt_apply_3 "ite" b x1 x2))
(define $smt_builtin_z_zero () ($smt_apply_0 "0"))
(define $smt_builtin_z_one () ($smt_apply_0 "1"))
(define $smt_builtin_z_two () ($smt_apply_0 "2"))
(define $smt_builtin_z_max_code () ($smt_apply_0 "196608"))
(define $smt_builtin_z_max_width () ($smt_apply_0 "4294967296"))
;(define $smt_builtin_q_zero () ($smt_apply_0 "0/1"))
(define $smt_builtin_q_zero () ($smt_apply_2 "mk_rational" $smt_builtin_z_zero $smt_builtin_z_one))
(define $smt_builtin_str_empty () ($smt_apply_0 """"""))
(define $smt_builtin_str_tuple_name () ($smt_apply_0 """@Tuple"""))
(define $smt_builtin_str_vname () ($smt_apply_0 """@x"""))
(define $smt_builtin_str_= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "streq" x1 x2))
(define $smt_builtin_not ((b $smt_builtin_Bool)) ($smt_apply_1 "not" b))
(define $smt_builtin_and ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "and" b1 b2))
(define $smt_builtin_or ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "or" b1 b2))
(define $smt_builtin_xor ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "xor" b1 b2))
(define $smt_builtin_iff ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "iff" b1 b2))
; Integer operators
; These assume zeq, zleq, zlt, zplus, zmult, zneg are defined as =, <=, <, +, *, -
(define $smt_builtin_z_= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zeq" x1 x2))
(define $smt_builtin_z_<= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zleq" x1 x2))
(define $smt_builtin_z_< ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zlt" x1 x2))
(define $smt_builtin_z_+ ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zplus" x1 x2))
(define $smt_builtin_z_* ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zmult" x1 x2))
(define $smt_builtin_z_neg ((W Type :implicit) (x1 W)) ($smt_apply_1 "zneg" x1))
(define $smt_builtin_z_- ((W Type :implicit) (x1 W) (x2 W)) ($smt_builtin_z_+ x1 ($smt_builtin_z_neg x2)))
; Real operators
; These assume qleq, qlt, qplus, qmult, qneg are defined as <=, <, +, *, -
(define $smt_builtin_q_= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qeq" x1 x2))
(define $smt_builtin_q_<= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qleq" x1 x2))
(define $smt_builtin_q_< ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qlt" x1 x2))
(define $smt_builtin_q_+ ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qplus" x1 x2))
(define $smt_builtin_q_* ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qmult" x1 x2))
(define $smt_builtin_q_neg ((W Type :implicit) (x1 W)) ($smt_apply_1 "qneg" x1))
(define $smt_builtin_q_- ((W Type :implicit) (x1 W) (x2 W)) ($smt_builtin_q_+ x1 ($smt_builtin_q_neg x2)))
; other arithmetic
(define $smt_builtin_div ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "div" x1 x2))
(define $smt_builtin_mod ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "mod" x1 x2))
(define $smt_builtin_z_neg_one () ($smt_builtin_z_neg $smt_builtin_z_one))
(define $smt_builtin_z_inc ((W Type :implicit) (x1 W)) ($smt_builtin_z_+ x1 $smt_builtin_z_one))
(define $smt_builtin_z_dec ((W Type :implicit) (x1 W)) ($smt_builtin_z_+ x1 $smt_builtin_z_neg_one))

; macro for applying (+ t1 t2 t3), which is (+ t1 (+ t2 t3))
(define $smt_apply_nary_3
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit)
   (op $smt_id) (x1 W1) (x2 W2) (x3 W3))
  ($smt_apply_2 op x1 ($smt_apply_2 op x2 x3)))

;;; Defining parametric bitvector operators

; The operators in this section are needed to reason about the parametric
; operations on the Eunoia binary literal type.

; program: $smtx_pow2
; return: >
;   The integer value of 2 raised to the i^th power.
; note: We expect i to be non-negative.
(program $smtx_pow2 ((i $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_pow2 i)
    ($smt_builtin_ite ($smt_builtin_z_<= i $smt_builtin_z_zero)
      $smt_builtin_z_one
      ($smt_builtin_z_* $smt_builtin_z_two
        ($smtx_pow2 ($smt_builtin_z_dec i)))))
  )
)

; program: $smtx_bit
; return: >
;   true iff the i^th bit of a binary with integer value x is set. Note this
;   method is agnostic to bitwidth.
(program $smtx_bit ((x $smt_builtin_Int) (i $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Bool
  (
  (($smtx_bit x i)
    ($smt_builtin_z_=
      $smt_builtin_z_one
      ($smt_builtin_mod ($smt_builtin_div x ($smtx_pow2 i)) $smt_builtin_z_two)))
  )
)

; program: $smtx_msb
; return: >
;   true iff the most significant bit of the binary of width w and value n is
;   set.
(program $smtx_msb ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Bool
  (
  (($smtx_msb w n) ($smtx_bit n ($smt_builtin_z_dec w)))
  )
)

; program: $smtx_binary_and_rec
; note: Helper for $smtx_binary_and below.
(program $smtx_binary_and_rec ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_and_rec w n1 n2)
      ($smt_builtin_z_+
        ($smt_builtin_ite ($smt_builtin_z_= w $smt_builtin_z_zero)
          $smt_builtin_z_zero
          ($smtx_binary_and_rec ($smt_builtin_z_dec w) n1 n2))
        ($smt_builtin_z_* ($smtx_pow2 w)
            ($smt_builtin_ite ($smt_builtin_and ($smtx_bit n1 w) ($smtx_bit n2 w)) 
              $smt_builtin_z_one 
              $smt_builtin_z_zero))))
  )
)

; program: $smtx_binary_and
; return: >
;   The integer value of the binary value obtained by taking the bitwise and of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This value will be
;   taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w, 0 <= w.
(define $smtx_binary_and
  ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  ($smt_builtin_ite ($smt_builtin_z_= w $smt_builtin_z_zero)
    $smt_builtin_z_zero
    ($smtx_binary_and_rec ($smt_builtin_z_dec w) n1 n2)))

; program: $smtx_binary_or
; return: >
;   The integer value of the binary value obtained by taking the bitwise or of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This is equal to
;   n1+n2-($smtx_binary_and w n1 n2). This value will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w, 0 <= w.
(program $smtx_binary_or ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_or w n1 n2)
    ($smt_builtin_z_+ n1 ($smt_builtin_z_- n2 ($smtx_binary_and w n1 n2))))
  )
)

; program: $smtx_binary_xor
; return: >
;   The integer value of the binary value obtained by taking the bitwise xor of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This is equal to
;   n1+n2-(2*($smtx_binary_and w n1 n2)). This value will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w, 0 <= w.
(program $smtx_binary_xor ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_xor w n1 n2)
    ($smt_builtin_z_+ n1 ($smt_builtin_z_- n2 ($smt_builtin_z_* $smt_builtin_z_two ($smtx_binary_and w n1 n2)))))
  )
)

; program: $smtx_binary_not
; return: >
;   The integer value of the binary value obtained by taking bitwise not of
;   the binary literal ($eo_binary w n). This is equal to 2^w-(1+n). This value
;   will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n < 2^w, 0 <= w.
(program $smtx_binary_not ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_not w n)
    ($smt_builtin_z_- ($smtx_pow2 w) ($smt_builtin_z_inc n)))
  )
)

; program: $smtx_binary_max
; return: >
;   The integer value of the maximum unsigned binary value of width w. This is
;   equal to 2^w-1.
(program $smtx_binary_max ((w $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_max w) ($smt_builtin_z_dec ($smtx_pow2 w)))
  )
)

; program: $smtx_binary_uts
; return: >
;   The conversion of n from unsigned to signed integer, which is
;   2*(n mod 2^w-1) - n.
(program $smtx_binary_uts ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_uts w n) 
    ($smt_builtin_z_-
      ($smt_builtin_z_* $smt_builtin_z_two
        ($smt_builtin_mod n ($smtx_pow2 ($smt_builtin_z_dec w))))
      n))
  )
)

; program: $smtx_binary_concat
; return: >
;   The integer value of the binary value obtained by concatenating binary
;   literals ($eo_binary w1 n1) and ($eo_binary w2 n2). This is equal to
;   n1*2^w2 + n2. Note the return value does not depend on w1. This value will
;   be taken modulo 2^(w1+w2).
; note: >
;   Assumes that 0 <= n1 < 2^w1, 0 <= n2 < 2^w2, 0 <= w1, 0 <= w2.
(program $smtx_binary_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_concat w1 n1 w2 n2)
    ($smt_builtin_z_+ ($smt_builtin_z_* n1 ($smtx_pow2 w2)) n2))
  )
)

; program: $smtx_binary_extract
; return: >
;   The integer value of the binary value obtained by extracting bits x1
;   through x2 (inclusive) of binary literal ($eo_binary w n). This is equal
;   to (div n 2^x1). This value will be taken modulo 2^(1+x2-x1).
; note: >
;   Assumes that 0 <= n < 2^w, 0 <= x1 <= x2 < w.
(program $smtx_binary_extract
  ((w $smt_builtin_Int) (n $smt_builtin_Int) (x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_extract w n x1 x2) ($smt_builtin_div n ($smtx_pow2 x2)))
  )
)

;;; Terms, types, datatypes

; An SMT term.
(declare-const $smt_Term Type)

; An SMT type.
(declare-const $smt_Type Type)

; A datatype constructor
(declare-const $smt_DatatypeCons Type)

; A datatype
(declare-const $smt_Datatype Type)

; utilities

; Assumes that Teq is defined to be equality over $smt_Type
(define $smt_builtin_Teq ((x1 $smt_Type) (x2 $smt_Type)) ($smt_apply_2 "Teq" x1 x2))


;;; Constructors for SMT-LIB datatypes and datatype constructors

; A constructor having no arguments
(declare-const $emb_dtc.unit $smt_DatatypeCons)
(define $dtc_unit () $emb_dtc.unit)

; A constructor having at least one argument
; It takes the type of that argument and a constructor specifying the remaining
; arguments.
(declare-parameterized-const $emb_dtc.cons
  ((T $smt_Type :opaque) (c $smt_DatatypeCons :opaque))
  $smt_DatatypeCons)
(define $dtc_cons ((T $smt_DatatypeCons) (c $smt_DatatypeCons))
  ($emb_dtc.cons T c))

; A datatype having no constructors
(declare-const $emb_dt.null $smt_Datatype)
(define $dt_null () $emb_dt.null)
  
; A datatype having at least one constructor
(declare-parameterized-const $emb_dt.sum
  ((c $smt_DatatypeCons :opaque) (d $smt_Datatype :opaque))
  $smt_Datatype)
(define $dt_sum ((c $smt_DatatypeCons) (d $smt_Datatype))
  ($emb_dt.sum c d))
