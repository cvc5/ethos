; This file defines a deep embedding of SMT-LIB into Eunoia.
; It is used for two purposes:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin Eunoia functions, e.g. $eo_add.
; 2. It is used to define the end signature for defining the model semantics of SMT-LIB.

; All of the functions in this file will be handled by smt_meta.

;;; declarations to define literal types

; The type of $smt_apply_* terms.
; If a term has this type, we know it is an SMT-LIB type,
; but we don't know which one from ordinary type checking.
(declare-const $smt_BuiltinType Type)

; The operator of $smt_apply_* terms
(define $smt_id () $eo_String)

; note: decimal and hexadecimal omitted for now.

;;; Deep embedding of SMT-LIB operator applications into Eunoia

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_type_0
  ((op $smt_id :opaque))
  Type)
(declare-parameterized-const $smt_type_1
  ((W1 Type :implicit) (op $smt_id :opaque) (x1 W1 :opaque))
  Type)
(declare-parameterized-const $smt_apply_0
  ((op $smt_id :opaque))
  $smt_BuiltinType)
(declare-parameterized-const $smt_apply_1
  ((W1 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_2
  ((W1 Type :implicit) (W2 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_3
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_4
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_5
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque) (x5 W5 :opaque)) $smt_BuiltinType)

; Handles the corner case of SMT-LIB equality, which we use for Eunoia terms as well.
(declare-parameterized-const $smt_apply_=
  ((W Type :implicit) (x1 W :opaque) (x2 W :opaque))
  $smt_BuiltinType)

; builtin types, which print as e.g. "sm.Int".
(declare-parameterized-const $smt_builtin_type_0
  ((op $smt_id :opaque))
  Type)
; NOTE: the fact that x1 is not opaque indicates that
; bitvectors print as (_ BitVec w) not (BitVec w).
(declare-parameterized-const $smt_builtin_type_1
  ((W1 Type :implicit) (op $smt_id :opaque) (x1 W1))
  Type)

(define $smt_builtin_Bool () ($smt_type_0 "Bool"))
(define $smt_builtin_Int () ($smt_type_0 "Int"))
(define $smt_builtin_Real () ($smt_type_0 "Real"))
(define $smt_builtin_String () ($smt_type_0 "String"))
(define $smt_builtin_true () ($smt_apply_0 "true"))
(define $smt_builtin_false () ($smt_apply_0 "false"))
(define $smt_builtin_= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_= x1 x2))
(define $smt_builtin_ite ((W Type :implicit) (b $smt_builtin_Bool) (x1 W) (x2 W)) ($smt_apply_3 "ite" b x1 x2))
(define $smt_builtin_z_zero () ($smt_apply_0 "0"))
(define $smt_builtin_z_one () ($smt_apply_0 "1"))
(define $smt_builtin_z_two () ($smt_apply_0 "2"))
(define $smt_builtin_+ ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "+" x1 x2))
(define $smt_builtin_- ((W Type :implicit) (x1 W)) ($smt_apply_1 "-" x1))
(define $smt_builtin_div ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "div" x1 x2))
(define $smt_builtin_mod ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "mod" x1 x2))
(define $smt_builtin_not ((b $smt_builtin_Bool)) ($smt_apply_1 "not" b))
(define $smt_builtin_and ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "and" b1 b2))
(define $smt_builtin_or ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "or" b1 b2))

; TODO: =, ite

; In this signature, we heavily use references to the Datatypes corresponding
; to the final deep embeddings of Eunoia terms (eo.Term) and SMT-LIB terms
; (sm.Term), where the latter is a subfield type of the former.
; Opaque arguments of a symbol X will be an argument of the constructor eo.X
; (respectively sm.X). Symbols with no

; We introduce datatype constructors for these datatypes ($smd_eo.X and $smd_sm.X)
; respectively. It is important that we mark their arguments as :opaque, as this
; correctly models the pattern matching in the smt-meta later.

; Note that these datatypes will be renamed and replaced by their definitions
; which is hardcoded into smt_meta.smt2.
; We could also have these auto-generated, but leads to complications when it
; comes to printing the argument types, as e.g. the argument to sm.Numeral is
; an SMT-LIB numeral, not a symbolic SMT term.

;;; Final deep embedding datatypes

; Now, we introduce placeholders for the final deep embedding.
; - $smt_Term, $smt_Type, $smt_Value are introduced as placeholders for the final datatypes in the deep embedding.
; - The SMT-like literals are declared for $smt_Term.
; - 

; An SMT-LIB term.
; This will be replaced by the datatype sm.Term in the final encoding.
(declare-const $smt_Term Type)

; An SMT-LIB type.
; This will be replaced by the datatype tsm.Type in the final encoding.
(declare-const $smt_Type Type)

; An SMT-LIB value.
; This will be replaced by the datatype vsm.Value in the final encoding.
(declare-const $smt_Value Type)

;;; SMT term datatype constructors

; Note the Bool type is "inlined" into the final signature
(declare-const $smd_sm.True $smt_Term)
(declare-const $smd_sm.False $smt_Term)
(declare-parameterized-const $smd_sm.Numeral ((n $smt_builtin_Int :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Rational ((r $smt_builtin_Real :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.String ((s ($smt_type_0 "String") :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Binary ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $smt_Term)

;;; Eunoia datatype constructors

; The Eunoia representation of an SMT-LIB term.
(declare-parameterized-const $smd_eo.SmtTerm ((t $smt_Term :opaque)) $eo_Term)
(define $eo_smt_term ((t $smt_Term)) ($smd_eo.SmtTerm t))

; The Eunoia representation of an SMT-LIB type.
(declare-parameterized-const $smd_eo.SmtType ((t $smt_Type :opaque)) $eo_Term)
(define $eo_smt_type ((T $smt_Type)) ($smd_eo.SmtType T))

; The Eunoia representation of an SMT-LIB value.
(declare-parameterized-const $smd_eo.SmtValue ((t $smt_Type :opaque)) $eo_Term)
(define $eo_smt_value ((T $smt_Type)) ($smd_eo.SmtValue T))

; The Eunoia representation of "stuckness".
(declare-const $smd_eo.Stuck $eo_Term)

;;; External datatype access

(define $sm_mk_true () $smd_sm.True)
(define $sm_mk_false () $smd_sm.False)
(define $sm_mk_bool ((c $smt_builtin_Bool))
  ($smt_apply_3 "ite" c $sm_mk_true $sm_mk_false))
(define $sm_mk_z ((n $smt_builtin_Int))
  ($smt_apply_1 "sm.Numeral" n))
(define $sm_mk_q ((r $smt_builtin_Real))
  ($smt_apply_1 "sm.Rational" r))
(define $sm_mk_str ((s $smt_builtin_String))
  ($smt_apply_1 "sm.String" s))

;(define $smt_Int () ($smt_builtin_type_0 "Int"))
;(define $smt_Real () ($smt_builtin_type_0 "Real"))
;(define $smt_BitVec ((w $smt_builtin_Int)) (_ ($smt_builtin_type_1 "BitVec") w))
;(define $smt_String () ($smt_builtin_type_0 "String"))

; NOTE: we use equality directly, although we could use (_ sm.True) here.
(define $sm_is_true ((b $smt_Term)) ($smt_apply_= b $sm_mk_true))
(define $sm_is_false ((b $smt_Term)) ($smt_apply_= b $sm_mk_false))
; Assumes that t is a Boolean term
(define $sm_is_bool ((T Type :implicit) (t T))
  ($smt_builtin_or ($sm_is_true t) ($sm_is_false t)))
(define $sm_is_z ((T Type :implicit) (t T))
  ($smt_apply_1 "(_ is sm.Numeral)" t))
(define $sm_is_q ((T Type :implicit) (t T))
  ($smt_apply_1 "(_ is sm.Rational)" t))
(define $sm_is_str ((T Type :implicit) (t T))
  ($smt_apply_1 "(_ is sm.String)" t))

;;; Defining parametric bitvector operators

; The operators in this section are needed to reason about the parametric
; operations on the Eunoia binary literal type.

(program $sm_mk_pow2 ((i $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($sm_mk_pow2 i)  ($smt_apply_3 "ite" ($smt_apply_2 "<=" i $smt_builtin_z_zero)
                      $smt_builtin_z_one
                      ($smt_apply_2 "*" $smt_builtin_z_two ($sm_mk_pow2 ($smt_apply_2 "-" i $smt_builtin_z_one)))))
  )
)
(program $sm_mk_bit ((x $smt_builtin_Int) (i $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Bool
  (
  ; (= (mod (div x ($sm_mk_pow2 i)) 2) 1)
  (($sm_mk_bit x i) ($smt_apply_1 "= 1" ($smt_apply_2 "mod" ($smt_builtin_div x ($sm_mk_pow2 i)) $smt_builtin_z_two)))
  )
)
(program $sm_mk_binary_and ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($sm_mk_binary_and w n1 n2)
     ($smt_apply_3 "ite" ($smt_apply_2 "=" w $smt_builtin_z_zero) $smt_builtin_z_zero
     ($smt_apply_3 "ite" ($smt_apply_2 "=" w $smt_builtin_z_one)
       ($smt_apply_3 "ite"
        ($smt_builtin_and
          ($smt_apply_2 "=" n1 $smt_builtin_z_one)
          ($smt_apply_2 "=" n2 $smt_builtin_z_one))
        $smt_builtin_z_one $smt_builtin_z_zero)
       ($smt_apply_2 "+"
         ($sm_mk_binary_and ($smt_apply_2 "-" w $smt_builtin_z_one) n1 n2)
         ($smt_apply_2 "*" ($sm_mk_pow2 w)
            ($smt_apply_3 "ite" ($smt_builtin_and ($sm_mk_bit n1 w) ($sm_mk_bit n2 w)) $smt_builtin_z_one $smt_builtin_z_zero))))))
  )
)
(program $sm_mk_binary_or ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_xor ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_not ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_max ((w $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($sm_mk_binary_max w) ($smt_apply_1 "- 1" ($sm_mk_pow2 w)))
  )
)
(program $sm_mk_binary_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)
(program $sm_mk_binary_extract
  ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  ; TODO
)

;;; Utilities

(define $eo_stuck () $smd_eo.Stuck)
(define $eo_true () ($eo_smt_term $sm_mk_true))
(define $eo_false () ($eo_smt_term $sm_mk_false))
(define $eo_mk_bool ((x $smt_builtin_Bool))
  ($eo_smt_term ($sm_mk_bool x)))
(define $eo_mk_true () ($eo_smt_term $sm_mk_true))
(define $eo_mk_false () ($eo_smt_term $sm_mk_false))
(define $eo_mk_numeral ((x $smt_builtin_Int))
  ($eo_smt_term ($smd_sm.Numeral x)))
(define $eo_mk_rational ((x $smt_builtin_Real))
  ($eo_smt_term ($smd_sm.Rational x)))
(define $eo_mk_string ((x $smt_builtin_String))
  ($eo_smt_term ($smd_sm.String x)))
(define $eo_binary ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  ($eo_smt_term ($smd_sm.Binary x1 x2)))
; different from above, this may get stuck
(program $eo_mk_binary ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $eo_Term
  (
  (($eo_mk_binary w n)
    ($smt_apply_3 "ite" ($smt_builtin_and ($smt_apply_1 "<= 0" w) ($smt_apply_1 ">= 4294967296" w))
      ($eo_binary w ($smt_apply_2 "mod" n ($sm_mk_pow2 w)))
      $eo_stuck))
  )
)

;;;;;; Eunoia builtin

; We are now ready to define the builtins of Eunoia.
; We define all the Eunoia builtins here that are best to
; define in terms of SMT-LIB operators.

;;; If then else, is ok, requires

; program: $eo_ite
; implements: eo::ite
(define $eo_ite ((x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term))
  ($smt_apply_3 "ite" ($smt_apply_= x1 $eo_mk_true)
    x2
  ($smt_apply_3 "ite" ($smt_apply_= x1 $eo_mk_false)
    x3
    $eo_stuck)))

; TODO: we could define a total version here, which
; can be used if we are sure the condition is not
; stuck. Alternatively this could be automated in
; the compiler.

; program: $eo_is_ok
; implements: eo::is_ok
(define $eo_is_ok ((x $eo_Term))
  ($smt_apply_3 "ite" ($smt_apply_= x $eo_stuck)
    $eo_mk_false
    $eo_mk_true))

; program: $eo_requires
; implements: eo::requires
; NOTE: this must be defined as a program to ensure proper typing
; in the smt_meta_reduce compilation step.
(program $eo_requires ((x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term))
  :signature ($eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($eo_requires x1 x2 x3)
    ($smt_apply_3 "ite"
      ($smt_builtin_and
        ($smt_builtin_not ($smt_apply_= x1 $eo_stuck))
        ($smt_apply_= x1 x2))   ; note the optimization that we don't have to check x2 for stuck.
      x3
      $eo_stuck))
  )
)

;;; Boolean operators

; axiom: $eo_not
(program $eo_not ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_not $eo_true)          $eo_false)
  (($eo_not $eo_false)         $eo_true)
  (($eo_not ($eo_binary w n))  ($eo_mk_binary w ($sm_mk_binary_not w n)))
  )
)

; axiom: $eo_and
(program $eo_and
  ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_and $eo_mk_true $eo_mk_true)   $eo_mk_true)
  (($eo_and $eo_mk_true $eo_mk_false)  $eo_mk_false)
  (($eo_and $eo_mk_false $eo_mk_true)  $eo_mk_false)
  (($eo_and $eo_mk_false $eo_mk_false) $eo_mk_false)
  (($eo_and ($eo_binary w n1) ($eo_binary w n2))
     ($eo_mk_binary w ($sm_mk_binary_and w n1 n2)))
  )
)

; axiom: $eo_or
(program $eo_or
  ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_or $eo_mk_true $eo_mk_true)   $eo_mk_true)
  (($eo_or $eo_mk_true $eo_mk_false)  $eo_mk_true)
  (($eo_or $eo_mk_false $eo_mk_true)  $eo_mk_true)
  (($eo_or $eo_mk_false $eo_mk_false) $eo_mk_false)
  (($eo_or ($eo_binary w n1) ($eo_binary w n2))
     ($eo_mk_binary w ($sm_mk_binary_or w n1 n2)))
  )
)

; axiom: $eo_xor
(program $eo_xor ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_xor $eo_mk_true $eo_mk_true)   $eo_mk_false)
  (($eo_xor $eo_mk_true $eo_mk_false)  $eo_mk_true)
  (($eo_xor $eo_mk_false $eo_mk_true)  $eo_mk_true)
  (($eo_xor $eo_mk_false $eo_mk_false) $eo_mk_false)
  (($eo_xor ($eo_binary w n1) ($eo_binary w n2))
     ($eo_mk_binary w ($sm_mk_binary_or w n1 n2)))
  )
)

;;; Arithmetic operators

(program $eo_add
  ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (r1 $smt_builtin_Real) (r2 $smt_builtin_Real))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_add ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($eo_mk_numeral ($smt_apply_2 "+" n1 n2)))
  (($eo_add ($eo_mk_rational r1) ($eo_mk_rational r2))
    ($eo_mk_rational ($smt_apply_2 "+" r1 r2)))
  (($eo_add ($eo_binary w n1) ($eo_binary w n2))
    ($eo_mk_binary w ($smt_apply_2 "+" n1 n2)))
  )
)

(program $eo_mul
  ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (r1 $smt_builtin_Real) (r2 $smt_builtin_Real))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_mul ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($eo_mk_numeral ($smt_apply_2 "*" n1 n2)))
  (($eo_mul ($eo_mk_rational r1) ($eo_mk_rational r2))
    ($eo_mk_rational ($smt_apply_2 "*" r1 r2)))
  (($eo_mul ($eo_binary w n1) ($eo_binary w n2))
    ($eo_mk_binary w ($smt_apply_2 "*" n1 n2)))
  )
)

(program $eo_qdiv ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (r1 $smt_builtin_Real) (r2 $smt_builtin_Real))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_qdiv ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    (eo::define ((r1 ($smt_apply_1 "to_real" n1)))
    (eo::define ((r2 ($smt_apply_1 "to_real" n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $eo_stuck
      ($eo_mk_rational ($smt_apply_2 "/" r1 r2))))))
  (($eo_qdiv ($eo_mk_rational r1) ($eo_mk_rational r2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0/1" r2)
      $eo_stuck
      ($eo_mk_rational ($smt_apply_2 "/" r1 r2))))
  )
)


(program $eo_zdiv ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_zdiv ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $eo_stuck
      ($eo_mk_numeral ($smt_builtin_div n1 n2))))
  (($eo_zdiv ($eo_binary w n1) ($eo_binary w n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      ($eo_mk_binary w ($sm_mk_binary_max w))
      ($eo_mk_binary w ($smt_builtin_div n1 n2))))
  )
)

(program $eo_zmod ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_zmod ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $eo_stuck
      ($eo_mk_numeral ($smt_apply_2 "mod" n1 n2))))
  (($eo_zmod ($eo_binary w n1) ($eo_binary w n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      ($eo_binary w n1)
      ($eo_mk_binary w ($smt_apply_2 "mod" n1 n2))))
  )
)

(program $eo_is_neg ((n1 $smt_builtin_Int) (r1 $smt_builtin_Real))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_is_neg ($eo_mk_numeral n1))
    ($eo_mk_bool ($smt_apply_1 "> 0 " n1)))
  (($eo_is_neg ($eo_mk_rational r1))
    ($eo_mk_bool ($smt_apply_1 "> 0/1" r1)))
  )
)

; axiom: $eo_neg
(program $eo_neg ((n1 $smt_builtin_Int) (r1 $smt_builtin_Real))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_neg ($eo_mk_numeral n1))
    ($eo_mk_numeral ($smt_apply_1 "-" n1)))
  (($eo_neg ($eo_mk_rational r1))
    ($eo_mk_rational ($smt_apply_1 "-" r1)))
  )
)


;;; String operators

(program $eo_len ((s1 $smt_builtin_String) (w $smt_builtin_Int) (n1 $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_len ($eo_mk_string s1))
    ($eo_mk_numeral ($smt_apply_1 "str.len" s1)))
  (($eo_len ($eo_binary w n1))
    ($eo_mk_numeral w))
  )
)

(program $eo_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int)
   (s1 $smt_builtin_String) (s2 $smt_builtin_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_concat ($eo_mk_string s1) ($eo_mk_string s2))
     ($eo_mk_string ($smt_apply_2 "str.++" s1 s2)))
  (($eo_concat ($eo_binary w1 n1) ($eo_binary w2 n2))
     ($eo_mk_binary ($smt_apply_2 "+" w1 w2) ($sm_mk_binary_concat w1 n1 w2 n2)))
  )
)

(program $eo_extract
  ((s1 $smt_builtin_String) (w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (n3 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($eo_extract ($eo_mk_string s1) ($eo_mk_numeral n2) ($eo_mk_numeral n3))
     ($eo_mk_string ($smt_apply_3 "str.substr" s1 n2 ($smt_apply_1 "+ 1" ($smt_apply_2 "-" n3 n2)))))
  (($eo_extract ($eo_binary w1 n1) ($eo_mk_numeral n2) ($eo_mk_numeral n3))
     ($eo_mk_binary
       ($smt_apply_1 "+ 1" ($smt_apply_2 "-" n3 n2))
       ($sm_mk_binary_extract w1 n1 n2 n3)))
  )
)

(program $eo_find ((s1 $smt_builtin_String) (s2 $smt_builtin_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_find ($eo_mk_string s1) ($eo_mk_string s2))
     ($eo_mk_string ($smt_apply_3 "str.indexof" s1 s2 $smt_builtin_z_zero)))
  )
)

;;; Conversion operators

(program $eo_to_z ((n1 $smt_builtin_Int) (r1 $smt_builtin_Real) (s1 $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_z ($eo_mk_numeral n1))
    ($eo_mk_numeral n1))
  (($eo_to_z ($eo_mk_rational r1))
    ($eo_mk_numeral ($smt_apply_1 "to_int" r1)))
  (($eo_to_z ($eo_mk_string s1))
    ($smt_apply_3 "ite"
      ($smt_apply_1 "= 1" ($smt_apply_1 "str.len" s1))
      ($eo_mk_numeral ($smt_apply_1 "str.to_code" s1))
      $eo_stuck))
  (($eo_to_z ($eo_binary w n1))
    ($eo_mk_numeral n1))
  )
)

(program $eo_to_q ((n1 $smt_builtin_Int) (r1 $smt_builtin_Real) (s1 $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_q ($eo_mk_numeral n1))
    ($eo_mk_rational ($smt_apply_1 "to_real" n1)))
  (($eo_to_q ($eo_mk_rational r1))
    ($eo_mk_rational r1))
  )
)

(program $eo_to_bin ((w $smt_builtin_Int) (w1 $smt_builtin_Int) (n1 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_to_bin ($eo_mk_numeral w) ($eo_mk_numeral n1))
    ($eo_mk_binary w n1))
  (($eo_to_bin ($eo_mk_numeral w) ($eo_binary w1 n1))
    ($eo_mk_binary w n1))
  )
)

(program $eo_to_str ((n1 $smt_builtin_Int) (s1 $smt_builtin_String))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_str ($eo_mk_numeral n1))
    ($smt_apply_3 "ite"
      ($smt_builtin_and ($smt_apply_1 "<= 0" n1) ($smt_apply_1 "> 196608" n1))
      ($eo_mk_string ($smt_apply_1 "str.from_code" n1))
      $eo_stuck))
  (($eo_to_str ($eo_mk_string s1))
    ($eo_mk_string s1))
  ; TODO: technically others here
  )
)

; TODO: make the operators below untyped???

;;; $eo_is_eq

; Returns true if t and s are equivalent values (ground and fully evaluated).
; define: $eo_is_eq
; implements: eo::is_eq
(define $eo_is_eq ((t $eo_Term) (s $eo_Term))
  (eo::ite (eo::is_ok t)
    (eo::ite (eo::is_ok s)
      ($eo_mk_bool ($smt_apply_= s t))  ; Note it is sound to use SMT-LIB equality, since we are guarding stuckness
      $eo_false)
    $eo_false))

;;; $eo_is_bool

; Returns true if x is a Boolean literal.
; define: $eo_is_bool
; implements: eo::is_bool
(program $eo_is_bool ((x $eo_Term))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_is_bool $eo_true)   $eo_true)
  (($eo_is_bool $eo_false)  $eo_true)
  (($eo_is_bool x)          $eo_false)
  )
)

;;; Conversion operators

;;; $eo_is_z

; Returns true if x is a numeral literal.
; define: $eo_is_z
; implements: eo::is_z
(define $eo_is_z ((x $eo_Term))
  ($eo_is_eq ($eo_to_z x) x))

;;; $eo_is_q

; Returns true if x is a rational literal.
; define: $eo_is_q
; implements: eo::is_q
(define $eo_is_q ((x $eo_Term))
  ($eo_is_eq ($eo_to_q x) x))

;;; $eo_is_bin

; Returns true if x is a binary literal.
; define: $eo_is_bin
; implements: eo::is_bin
(define $eo_is_bin ((x $eo_Term))
  ($eo_is_eq ($eo_to_bin ($eo_len x) x) x))

;;; $eo_is_str

; Returns true if x is a string literal.
; define: $eo_is_str
; implements: eo::is_str
(define $eo_is_str ((x $eo_Term))
  ($eo_is_eq ($eo_to_str x) x))

;;; Derived arithmetic

; Goes directly to SMT-LIB Int???
; Forward declaration
(program $eo_hash () :signature ($eo_Term) $eo_Term)

;;; $eo_gt

; Compare arithmetic greater than. Assumes x and y are values.
; Returns true if x > y.
; define: $eo_gt
; implements: eo::gt
(define $eo_gt ((x $eo_Term) (y $eo_Term))
  ($eo_is_neg ($eo_add ($eo_neg x) y)))


;;; $eo_cmp

; An arbitrary deterministic comparison of terms. Returns true if a > b based
; on this ordering.
; define: $eo_cmp
; implements: eo::cmp
(define $eo_cmp ((a $eo_Term) (b $eo_Term))
  ($eo_is_neg ($eo_add ($eo_hash b) ($eo_neg ($eo_hash a)))))

;;; since eo_typeof depends on literal predicates, typeof is only now ready.

; Used to model eo::var
(declare-parameterized-const $eo_Var ((s $eo_String :opaque) (T $eo_Term :opaque)) $eo_Term)

; program: $eo_var
; implements: eo::var
(program $eo_var ((s $smt_builtin_String) (T $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_var ($eo_mk_string s) T)
      (eo::requires ($eo_typeof T) Type
        ($eo_Var s T)))
  )
)

; program: $eo_nameof
; implements: eo::nameof
(program $eo_nameof ((s $eo_Term) (T $eo_Term))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_nameof ($eo_Var s T)) s)
  )
)

; Returns true if x is a variable.
; define: $eo_is_var
; implements: eo::is_var
(define $eo_is_var ((x $eo_Term))
  ($eo_is_eq ($eo_var ($eo_nameof x) ($eo_typeof x)) x))

; fwd-decl: $eo_typeof_main
(program $eo_typeof_main () :signature ($eo_Term) Type)

; program: $eo_typeof
; implements: eo::typeof
(program $eo_typeof
  ((t $eo_Term) (T $eo_Term) (n $smt_builtin_Int) (r $smt_builtin_Real) (s $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_typeof $eo_true)             Bool)
  (($eo_typeof $eo_false)            Bool)
  (($eo_typeof ($eo_mk_numeral n))   $eo_Numeral)
  (($eo_typeof ($eo_mk_rational r))  $eo_Rational)
  (($eo_typeof ($eo_mk_string s))    $eo_String)
  (($eo_typeof ($eo_binary w n))     $eo_Binary)
  (($eo_typeof ($eo_Var s T))        T)
  (($eo_typeof t)                    ($eo_typeof_main t))
  )
)
