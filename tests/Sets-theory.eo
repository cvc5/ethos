(include "Utils.eo")
(include "Arith-theory.eo")
(include "Datatypes-theory.eo")

(declare-type Set (Type))

; NOTE: permits non-set types
(declare-const set.empty (-> (T Type) T))
(declare-const set.universe (-> (T Type) T))

(declare-const set.singleton (-> (T Type :implicit) T (Set T)))
(declare-const set.union (-> (T Type :implicit) (Set T) (Set T) (Set T)))
(declare-const set.inter (-> (T Type :implicit) (Set T) (Set T) (Set T)))
(declare-const set.minus (-> (T Type :implicit) (Set T) (Set T) (Set T)))
(declare-const set.complement (-> (T Type :implicit) (Set T) (Set T)))
(declare-const set.member (-> (T Type :implicit) T (Set T) Bool))
(declare-const set.subset (-> (T Type :implicit) (Set T) (Set T) Bool))
(declare-const set.card (-> (T Type :implicit) (Set T) Int))
(declare-const set.choose (-> (T Type :implicit) (Set T) T))
(declare-const set.is_singleton (-> (T Type :implicit) (Set T) Bool))

(declare-const set.filter (-> (T Type :implicit) (-> T Bool) (Set T) (Set T)))
(declare-const set.map (-> (T Type :implicit) (U Type :implicit) (-> T U) (Set T) (Set U)))
(declare-const set.fold (-> (T Type :implicit) (U Type :implicit) (-> T U U) U (Set T) U))

(declare-const set.comprehension (-> (T Type :implicit) @List Bool T (Set T)))
(declare-const set.insert (-> (T Type :implicit) @List (Set T) (Set T)))

(declare-const rel.tclosure (-> (T Type :implicit) (Set (Tuple T T)) (Set (Tuple T T))))
(declare-const rel.transpose (-> (T Type :implicit) (Set T) (Set (nary.reverse Tuple UnitTuple T))))
(declare-const rel.product (-> (T Type :implicit) (U Type :implicit) (Set T) (Set U) (Set (eo::list_concat Tuple T U))))
(declare-const rel.join (-> (T Type :implicit) (U Type :implicit) (Set T) (Set U) (Set (nary.join Tuple UnitTuple T U))))
(declare-const rel.group (-> (T Type :implicit) @List (Set T) (Set (Set T))))

(declare-const rel.iden (-> (T Type :implicit) (Set (Tuple T)) (Set (Tuple T T))))  
(declare-const rel.join_image (-> (T Type :implicit) (Set (Tuple T T)) Int (Set (Tuple T))))

