; This file gives definitions of builtin eo::X operators.
; We use the convention that each eo::X definition is given a corresponding
; definition $eo_X. Modifying a Eunoia file to use $eo_ instead of eo:: should
; have no impact on behavior (apart from performance), unless otherwise noted.

;;; $eo_nil

; Note that $eo_nil is dynamically modified based on the declared constants,
; as described below. This means we cannot provide a static definition of it
; in this signature, and this is not equivalent to the builtin eo::nil.
; We assume that $eo_nil is defined prior to parsing this file.

; The internal definition of $eo_nil has the following form.
;(program $eo_nil ((T Type) (U Type) (V Type) (W Type))
;  ((-> T U V) (eo::quote W)) W
;  (
;  ; ... Cases for each operator, see description below.
;  )
;)

; For each (declare-parameterized-const f (...) (-> T T T) :right-assoc-nil nil)
; declared in the signature, we add the case to $eo_nil:
;   (($eo_nil f T) nil)
; For example, given:
;   (declare-parameterized-const bvor ((m Int :implicit))
;     (-> (BitVec m) (BitVec m) (BitVec m)) :right-assoc-nil (eo::to_bin 0 m))
; We add this case to $eo_nil above:
;   (($eo_nil bvor (BitVec m))  (eo::to_bin 0 m))


;;; $eo_is_list

(program $eo_is_list_rec
  ((T Type) (U Type) (V Type) (W Type) (X Type)
   (f (-> T U V)) (x T) (y U) (nil W) (z X))
  ((-> T U V) W X) Bool
  (
  (($eo_is_list_rec f nil (f x y)) ($eo_is_list_rec f nil y))
  (($eo_is_list_rec f nil z)       (eo::eq nil z))
  )
)

; Note: >
;   This does not correspond to a builtin operator. It is used as a helper
;   to define the preconditions on most of the operators below.
(define $eo_is_list
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T U V)) (x W))
  ($eo_is_list_rec f ($eo_nil f (eo::typeof x)) x))

;;; $eo_get_elements

(program $eo_get_elements_rec
  ((T Type) (U Type) (V Type) (W Type) (W1 Type) (W2 Type) (X Type)
   (f (-> T U V)) (x W1) (y W2) (z X) (nil W))
  ((-> T U V) W X) eo::List
  (
  (($eo_get_elements_rec f nil (f x y)) (eo::cons eo::List::cons x ($eo_get_elements_rec f nil y)))
  (($eo_get_elements_rec f nil nil)     eo::List::nil)
  )
)

; Note: >
;   This does not correspond to a builtin operator. It is used as a helper
;   to define eo_list_minclude below.
(define $eo_get_elements
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T U V)) (a W))
  (eo::requires ($eo_is_list f a) true
    ($eo_get_elements_rec f ($eo_nil f (eo::typeof a)) a)))

;;; $eo_cons

; define: $eo_cons
; implements: eo::cons
(define $eo_cons
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (W1 Type :implicit) (W2 Type :implicit)
   (f (-> T U V)) (e W1) (a W2))
  (eo::requires ($eo_is_list f a) true (f e a)))

;;; $eo_list_len

(program $eo_list_len_rec
  ((T Type) (U Type) (V Type) (W Type) (f (-> T U V)) (x T) (y U) (nil W))
  ((-> T U V) W) Int
  (
  (($eo_list_len_rec f (f x y))  (eo::add 1 ($eo_list_len_rec f y)))
  (($eo_list_len_rec f nil)      0)
  )
)

; define: $eo_list_len
; implements: eo::list_len
(define $eo_list_len
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T U V)) (a W))
  (eo::requires ($eo_is_list f a) true ($eo_list_len_rec f a)))

;;; $eo_list_concat

(program $eo_list_concat_rec
  ((T Type) (U Type) (V Type) (W Type) (f (-> T V V)) (x W) (y U) (z U) (nil U))
  ((-> T V V) U U) U
  (
  (($eo_list_concat_rec f (f x y) z)  (f x ($eo_list_concat_rec f y z)))
  (($eo_list_concat_rec f nil z)      z)
  )
)

; define: $eo_list_concat
; implements: eo::list_concat
(define $eo_list_concat
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (f (-> T V V)) (a U) (b U))
  (eo::requires ($eo_is_list f a) true
  (eo::requires ($eo_is_list f b) true
    ($eo_list_concat_rec f a b))))

;;; $eo_list_nth

(program $eo_list_nth_rec
  ((T Type) (U Type) (f (-> T T T)) (x U) (y U) (n Int))
  ((-> T T T) U Int) U
  (
  (($eo_list_nth_rec f (f x y) 0)  x)
  (($eo_list_nth_rec f (f x y) n)  ($eo_list_nth_rec f y (eo::add n -1)))
  )
)

; define: $eo_list_nth
; implements: eo::list_nth
(define $eo_list_nth
  ((T Type :implicit) (U Type :implicit)
   (f (-> T T T)) (a U) (n Int))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_nth_rec f a n)))

;;; $eo_list_find

(program $eo_list_find_rec
  ((T Type) (U Type) (V Type) (W Type) (X Type)
   (f (-> T U V)) (x W) (z W) (y U) (z X) (nil W) (n Int))
  ((-> T U V) W X Int) Int
  (
  (($eo_list_find_rec f (f x y) z n)  (eo::ite (eo::eq x z) n
                                        ($eo_list_find_rec f y z (eo::add n 1))))
  (($eo_list_find_rec f nil z n)      -1)
  )
)

; define: $eo_list_find
; implements: eo::list_find
(define $eo_list_find
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (W1 Type :implicit) (W2 Type :implicit)
   (f (-> T U V)) (a W1) (e W2))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_find_rec f a e 0)))

;;; $eo_list_rev

(program $eo_list_rev_rec
  ((T Type) (U Type) (V Type) (W Type)
   (f (-> T V V)) (x W) (y U) (nil U) (acc U))
  ((-> T V V) U U) U
  (
    (($eo_list_rev_rec f (f x y) acc) ($eo_list_rev_rec f y (f x acc)))
    (($eo_list_rev_rec f nil acc)      acc)
  )
)

; define: $eo_list_rev
; implements: eo::list_rev
(define $eo_list_rev
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (f (-> T V V)) (a U))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_rev_rec f a ($eo_nil f (eo::typeof a)))))

;;; $eo_list_erase

(program $eo_list_erase_rec
  ((T Type) (U Type) (V Type) (W Type) (X Type)
   (f (-> T V V)) (x W) (y U) (z X) (nil U))
  ((-> T V V) U X) U
  (
  (($eo_list_erase_rec f (f x y) z)   (eo::ite (eo::eq z x) y
                                        (f x ($eo_list_erase_rec f y z))))
  (($eo_list_erase_rec f nil z)       nil)
  )
)

; define: $eo_list_erase
; implements: eo::list_erase
(define $eo_list_erase
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T V V)) (a U) (e W))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_erase_rec f a e)))

;;; $eo_list_erase_all

(program $eo_list_erase_all_rec
  ((T Type) (U Type) (V Type) (W Type) (X Type)
   (f (-> T V V)) (x W) (y U) (z X) (nil W))
  ((-> T V V) U X) U
  (
  (($eo_list_erase_all_rec f (f x y) z)   (eo::define ((res ($eo_list_erase_all_rec f y z)))
                                            (eo::ite (eo::eq z x) res (f x res))))
  (($eo_list_erase_all_rec f nil z)       nil)
  )
)

; define: $eo_list_erase_all
; implements: eo::list_erase_all
(define $eo_list_erase_all
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T V V)) (a U) (e W))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_erase_all_rec f a e)))

;;; $eo_list_setof

(program $eo_list_setof_rec
  ((T Type) (U Type) (V Type) (W Type)
   (f (-> T V V)) (x W) (y U) (nil U))
  ((-> T V V) U) U
  (
  (($eo_list_setof_rec f (f x y))  (f x ($eo_list_setof_rec f ($eo_list_erase_all f y x))))
  (($eo_list_setof_rec f nil)      nil)
  )
)

; define: $eo_list_setof
; implements: eo::list_setof
(define $eo_list_setof
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (f (-> T V V)) (a U))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_setof_rec f a)))

;;; $eo_list_minclude

(program $eo_list_minclude_rec
  ((T Type) (x T) (y eo::List :list) (z eo::List))
  (eo::List eo::List) Bool
  (
  (($eo_list_minclude_rec (eo::List::cons x y) z)  (eo::define ((res ($eo_list_erase eo::List::cons z x)))
                                                   (eo::ite (eo::eq res z)
                                                     false   ; must have successfully removed occurrence of x from z
                                                     ($eo_list_minclude_rec y res))))
  (($eo_list_minclude_rec eo::List::nil z)          true)
  )
)

; define: $eo_list_minclude
; implements: eo::list_minclude
; Note: >
;   Since $eo_list_erase is a key submethod for defining $eo_list_minclude,
;   and $eo_list_erase requires functions (-> T V V), we convert the elements
;   of both lists to builtin lists eo::List using the auxiliary method
;   $eo_get_elements in this definition.
(define $eo_list_minclude
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (W1 Type :implicit) (W2 Type :implicit)
   (f (-> T U V)) (a W1) (b W2))
  (eo::requires ($eo_is_list f a) true
  (eo::requires ($eo_is_list f b) true
    ($eo_list_minclude_rec ($eo_get_elements f a) ($eo_get_elements f b)))))

;;; $eo_list_meq

; define: $eo_list_meq
; implements: eo::list_meq
(define $eo_list_meq
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (W1 Type :implicit) (W2 Type :implicit)
   (f (-> T U V)) (a W1) (b W2))
  (eo::and ($eo_list_minclude f a b) ($eo_list_minclude f b a)))
