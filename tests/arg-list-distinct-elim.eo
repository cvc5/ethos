

(declare-const not (-> Bool Bool))
(declare-const and (-> Bool Bool Bool) :right-assoc-nil true)
(declare-parameterized-const = ((A Type :implicit)) (-> A A Bool) :chainable and)

(program $mk_nary_cong_rhs ((U Type) (f (-> U U U)) (s1 U) (s U) (t U :list) (tail Bool :list) (nil U))
    :signature (U Bool) U
    (
        (($mk_nary_cong_rhs (f s1 t) (and (= s1 s) tail))  (eo::cons f s ($mk_nary_cong_rhs t tail)))
        (($mk_nary_cong_rhs nil true)                       nil)
    )
)

(declare-rule nary_cong ((U Type) (E Bool) (t U))
    :premise-list E and
    :args (t)
    :conclusion (= t ($mk_nary_cong_rhs t E))
)

(define @List () eo::List)
(define @list.nil () eo::List::nil)
(define @list () eo::List::cons)


(declare-parameterized-const distinct ((xs @List))
  Bool
  :arg-list @list)


(program $mk_distinct-elim-rec ((T Type) (x T) (y T) (xs @List :list) (b Bool))
  :signature (T @List Bool) Bool
  (
  (($mk_distinct-elim-rec x (@list y xs) b)  (eo::cons and (not (= x y)) ($mk_distinct-elim-rec x xs b)))
  (($mk_distinct-elim-rec x @list.nil b)     b)
  )
)

(program $mk_distinct-elim ((T Type) (x T) (xs @List :list))
  :signature (Bool) Bool
  (
  (($mk_distinct-elim (distinct x xs))   ($mk_distinct-elim-rec x xs ($mk_distinct-elim (distinct xs))))
  (($mk_distinct-elim (distinct xs))     true) ; nil case
  )
)

; rule: distinct-elim
; implements: ProofRewriteRule::DISTINCT_ELIM.
; args:
; - eq Bool: The equality between formulas b1 and b to prove.
; requires: Showing that eliminating the operator "distinct" from b1 results in b.
; conclusion: The equality (= b1 b).
(declare-rule distinct-elim ((b1 Bool) (b Bool))
  :args ((= b1 b))
  :requires ((($mk_distinct-elim b1) b))
  :conclusion (= b1 b)
)

(declare-const Int Type)
(declare-const a Int)
(declare-const b Int)
(declare-const c Int)
(declare-const d Int)
(declare-const e Int)
(assume @p0 (= a d))
(assume @p1 (= b e))
(assume @p (= c c))
(step @p3 :rule distinct-elim :args ((= (distinct a b c) (and (not (= a b)) (not (= a c)) (not (= b c))))))
