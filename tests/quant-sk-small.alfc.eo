(include "Quantifiers-rules.eo")
(include "Booleans-rules.eo")
(include "Builtin-rules.eo")
(include "Uf-rules.eo")
(define eo::1.x () (eo::var "eo::1.x" Int))
(define x () (eo::var "x" Int))
(define y () (eo::var "y" Int))
(declare-const P (-> Int Int Bool))
(define @t1 () (forall (@list x y) (P x y)))
(define @t2 () (P eo::1.x 5))
(define @t3 () (exists (@list eo::1.x @list.nil) (not @t2)))
(define @t4 () (not (forall (@list eo::1.x @list.nil) @t2)))
(define @t5 () (skolem (@k.QUANTIFIERS_SKOLEMIZE @t3 eo::1.x)))
(define @t6 () (P @t5 5))
(assume @p1 @t1)
(assume @p2 @t3)
; WARNING: add trust step for THEORY_REWRITE
; trust THEORY_REWRITE
(step @p3 (= @t3 @t4) :rule trust :args ((= @t3 @t4)))
(step @p4 @t4 :rule eq_resolve :premises (@p2 @p3))
(step @p5 (not @t6) :rule skolemize :premises (@p4))
(assume-push @p6 @t1)
(step @p7 @t6 :rule instantiate :premises (@p1) :args ((@list @t5 5)))
(step-pop @p8 (=> @t1 @t6) :rule scope :premises (@p7))
(step @p9 (or (not @t1) @t6) :rule implies_elim :premises (@p8))
(step @p10 false :rule chain_resolution :premises (@p9 @p5 @p1) :args ((and true @t6 false @t1)))

