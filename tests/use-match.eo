(declare-type String ())
(declare-consts <string> String)

(program maybe_nil ((T Type) (U Type) (t T))
  :signature (T U) T
    (
      ((maybe_nil t t)       t)
      ((maybe_nil t "") t)
    )
)

(declare-type Pair (Type Type))
(declare-parameterized-const pair ((U Type :implicit) (T Type :implicit)) (-> U T (Pair U T)))
(declare-parameterized-const = ((T Type :implicit)) (-> T T Bool))

; nary.append cons c xs
; Appends `c` to the head of `xs`.
(program nary.append
    ((L Type) (cons (-> L L L)) (c L) (xs L :list))
    ((-> L L L) L L) L
    (
        ((nary.append cons c xs) (cons c xs))
    )
)

(declare-const str.++ (-> String String String) :right-assoc-nil "")

; `check_true b`
; returns true if b is true, returns false otherwise
(program check_true ((b Bool))
  :signature (Bool) Bool
  (
    ((check_true true) true)
    ((check_true b) false)
  )
)
(define check_length_one ((s String)) (check_true (eo::is_eq (eo::len s) 1)))

(program string_collect_acc ((t String) (tail String :list))
  :signature (String) (Pair String String)
  (
    ((string_collect_acc "")         (pair "" ""))
    ; Check if t is a word constant
    ((string_collect_acc (str.++ t tail))
      (eo::ite (check_length_one t)
        (eo::match ((s1 String) (s2 String)) 
          (string_collect_acc tail)
          (
            ((pair "" s2) (pair t s2))
            ((pair s1 s2) (pair (eo::concat t s1) s2))
          )
        )
        (pair "" (str.++ t tail))))
  )
)


(declare-rule collect_acc ((s String))
  :args (s)
  :conclusion (eo::match ((s1 String) (s2 String :list)) 
                (string_collect_acc s) 
                (
                  ((pair "" s2)  (= s s2))
                  ((pair s1 s2)       (= s (str.++ s1 s2)))
                )
              )
)

(declare-const x String)
(step @p0 (= (str.++ "A" "B" x) (str.++ "AB" x)) :rule collect_acc :args ((str.++ "A" "B" x)))
