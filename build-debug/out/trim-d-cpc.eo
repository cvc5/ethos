; This file is used for bootstrapping the semantics of Eunoia.
; We use a naming convention where eo:: operators are defined as ordinary
; programs with prefix $eo_. We additionally setup further desugaring
; to be done in later stages. Overall, this includes:
; 1. Definition of the builtin Eunoia list.
; 2. A definition of $eo_eq.
; 3. Definition of derived list operators.
; 4. Definition of $eo_cons and (a template for) $eo_nil.
; 5. Definition of a template of $eo_typeof_main, which is used in
;    part to define $eo_typeof.
; 6. Templates for $eo_dt_constructors and $eo_dt_selectors.
; 7. A placeholder command echo "include eo_builtin_smt" to specify
;    where further eo:: builtins should be defined.
; 8. Placeholders for defining a test environment for analyzing properties
;    of proof rules ($eo_model_eval/$eo_model_typeof/$eo_model_is_input).
; This file contains templates $EO_*$ which are automatically filled in
; by user definitions. This includes:
; 1. The literal type definitions (EO_LITERAL_TYPE_DECL).
; 2. All user declarations and definitions (EO_DEFS).
; 3. Cases of $eo_dt_constructors, $eo_dt_selectors, $eo_nil, $eo_typeof_main.
; 4. A verification condition (EO_VC).

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; proofs

; The return type of proof rules.
(declare-const $eo_Proof Type)
; Constructor of proofs, takes a formula that is proven.
(declare-parameterized-const $eo_pf ((F Bool :opaque)) $eo_Proof)
; Extracts the proven formula from a proof term.
(program $eo_proven ((F Bool))
  :signature ($eo_Proof) Bool
  (
  (($eo_proven ($eo_pf F)) F)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; literal types

; declare: Int
(declare-const Int Type)
; type-rules: NUMERAL
(declare-consts <numeral> Int)
; type-rules: NUMERAL
(define $eo_Numeral () Int)
; declare: Real
(declare-const Real Type)
; type-rules: RATIONAL
(declare-consts <rational> Real)
; type-rules: RATIONAL
(define $eo_Rational () Real)
; declare: BitVec
(declare-const BitVec (-> Int Type))
; type-rules: BINARY
(declare-consts <binary> (BitVec (eo::len eo::self)))
; (approx) type-rules: BINARY
(define $eo_Binary () (BitVec 1))
; declare: Char
(declare-const Char Type)
; declare: Seq
(declare-const Seq (-> Type Type))
; type-rules: STRING
(declare-consts <string> (Seq Char))
; type-rules: STRING
(define $eo_String () (Seq Char))


;;; $eo_List

; The builtin Eunoia list.
(declare-const $eo_List Type)
(declare-const $eo_List_nil $eo_List)
(declare-parameterized-const $eo_List_cons ((T Type :implicit))
  (-> T $eo_List $eo_List))

;;; forward declarations

; forward declaration
(program $eo_typeof ((T Type)) :signature (T) Type)

; forward declaration
(program $eo_nil ((T Type) (U Type) (V Type) (W Type))
  :signature ((-> T U V) (eo::quote W)) W)

; forward declaration
(program $eo_dt_constructors () :signature (Type) $eo_List)

; forward declaration
(program $eo_dt_selectors ((T Type)) :signature (T) $eo_List)

;;; core utilities

; The methods in this section are temporary definitions to eliminate
; dependencies on other builtin constructs.

; note: This is used to ensure signature does not depend on ite.
(program $eo_prepend_if ((T Type) (V Type) (x T) (f (-> T V V)) (res V))
  :signature (Bool (-> T V V) V V) V
  (
  (($eo_prepend_if true f x res)  (f x res))
  (($eo_prepend_if false f x res) res)
  )
)

;;; Core SMT-like builtins

; We use a "lazy" include style that allows this file to
; be parsable without including the file.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; eo_builtin_smt

; This will contain the definitions of eo::add, etc.
; It is (for now) specific to a deep embedding into SMT.
(echo "include eo_builtin_smt :deps $eo_typeof_main $eo_String $eo_Numeral $eo_Rational $eo_Binary $eo_typeof ")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; desugar core

;;;;;; List operators

;;; $eo_is_list

; Note: a helper for $eo_is_list.
(program $eo_is_list_rec
  ((T Type) (U Type) (V Type) (W Type) (X Type)
   (f (-> T U V)) (g (-> T U V)) (x T) (y U) (nil W) (z X))
  :signature ((-> T U V) W X) Bool
  (
  (($eo_is_list_rec f nil (g x y)) (eo::ite (eo::eq f g)
                                      ($eo_is_list_rec f nil y) false))
  (($eo_is_list_rec f nil z)       (eo::eq nil z))
  )
)

; Note: >
;   This does not correspond to a builtin operator. It is used as a helper
;   to define the preconditions for most of the operators below.
(define $eo_is_list
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T U V)) (x W))
  ($eo_is_list_rec f ($eo_nil f ($eo_typeof x)) x))

;;; $eo_cons

; define: $eo_cons
; implements: eo::cons
(define $eo_cons
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (W1 Type :implicit) (W2 Type :implicit)
   (f (-> T U V)) (e W1) (a W2))
  (eo::requires ($eo_is_list f a) true (f e a)))

;;; $eo_get_elements

; Note: a helper for $eo_get_elements.
(program $eo_get_elements_rec
  ((T Type) (U Type) (V Type) (W Type) (W1 Type) (W2 Type) (X Type)
   (f (-> T U V)) (x W1) (y W2) (z X) (nil W))
  :signature (X) $eo_List
  (
  (($eo_get_elements_rec (f x y)) ($eo_List_cons x ($eo_get_elements_rec y)))
  (($eo_get_elements_rec nil)     $eo_List_nil)
  )
)

; Note: >
;   This does not correspond to a builtin operator. It is used as a helper
;   to define eo_list_minclude below.
(define $eo_get_elements
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T U V)) (a W))
  (eo::requires ($eo_is_list f a) true
    ($eo_get_elements_rec a)))

;;; $eo_list_len

; Note: a helper for $eo_list_len.
(program $eo_list_len_rec
  ((T Type) (U Type) (V Type) (W Type) (f (-> T U V)) (x T) (y U) (nil W))
  :signature (W) $eo_Numeral
  (
  (($eo_list_len_rec (f x y))  (eo::add 1 ($eo_list_len_rec y)))
  (($eo_list_len_rec nil)      0)
  )
)

; define: $eo_list_len
; implements: eo::list_len
(define $eo_list_len
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T U V)) (a W))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_len_rec a)))

;;; $eo_list_concat

; Note: a helper for $eo_list_concat.
(program $eo_list_concat_rec
  ((T Type) (U Type) (V Type) (W Type) (f (-> T V V)) (x W) (y U) (z U) (nil U))
  :signature (U U) U
  (
  (($eo_list_concat_rec (f x y) z)  (f x ($eo_list_concat_rec y z)))
  (($eo_list_concat_rec nil z)      z)
  )
)

; define: $eo_list_concat
; implements: eo::list_concat
(define $eo_list_concat
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (f (-> T V V)) (a U) (b U))
  (eo::requires ($eo_is_list f a) true
  (eo::requires ($eo_is_list f b) true
    ($eo_list_concat_rec a b))))

;;; $eo_list_nth

; Note: a helper for $eo_list_nth.
(program $eo_list_nth_rec
  ((T Type) (U Type) (f (-> T T T)) (x U) (y U) (n $eo_Numeral))
  :signature (U $eo_Numeral) U
  (
  (($eo_list_nth_rec (f x y) 0)  x)
  (($eo_list_nth_rec (f x y) n)  ($eo_list_nth_rec y (eo::add n -1)))
  )
)

; define: $eo_list_nth
; implements: eo::list_nth
(define $eo_list_nth
  ((T Type :implicit) (U Type :implicit)
   (f (-> T T T)) (a U) (n $eo_Numeral))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_nth_rec a n)))

;;; $eo_list_find

; Note: a helper for $eo_list_find.
(program $eo_list_find_rec
  ((T Type) (U Type) (V Type) (W Type) (X Type)
   (f (-> T U V)) (x W) (z W) (y U) (z X) (nil W) (n $eo_Numeral))
  :signature (W X $eo_Numeral) $eo_Numeral
  (
  (($eo_list_find_rec (f x y) z n)  (eo::ite (eo::eq x z) n
                                      ($eo_list_find_rec y z (eo::add n 1))))
  (($eo_list_find_rec nil z n)      -1)
  )
)

; define: $eo_list_find
; implements: eo::list_find
(define $eo_list_find
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (W1 Type :implicit) (W2 Type :implicit)
   (f (-> T U V)) (a W1) (e W2))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_find_rec a e 0)))

;;; $eo_list_rev

; Note: a helper for $eo_list_rev.
(program $eo_list_rev_rec
  ((T Type) (U Type) (V Type) (W Type)
   (f (-> T V V)) (x W) (y U) (nil U) (acc U))
  :signature (U U) U
  (
    (($eo_list_rev_rec (f x y) acc) ($eo_list_rev_rec y (f x acc)))
    (($eo_list_rev_rec nil acc)      acc)
  )
)

; define: $eo_list_rev
; implements: eo::list_rev
(define $eo_list_rev
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (f (-> T V V)) (a U))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_rev_rec a ($eo_nil f ($eo_typeof a)))))

;;; $eo_list_erase

; Note: a helper for $eo_list_erase.
(program $eo_list_erase_rec
  ((T Type) (U Type) (V Type) (W Type) (X Type)
   (f (-> T V V)) (x W) (y U) (z X) (nil U))
  :signature (U X) U
  (
  (($eo_list_erase_rec (f x y) z)   (eo::ite (eo::eq x z) y
                                      (f x ($eo_list_erase_rec y z))))
  (($eo_list_erase_rec nil z)       nil)
  )
)

; define: $eo_list_erase
; implements: eo::list_erase
(define $eo_list_erase
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T V V)) (a U) (e W))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_erase_rec a e)))

;;; $eo_list_erase_all

; Note: a helper for $eo_list_erase_all.
(program $eo_list_erase_all_rec
  ((T Type) (U Type) (V Type) (W Type) (X Type)
   (f (-> T V V)) (x W) (y U) (z X) (nil W))
  :signature (U X) U
  (
  (($eo_list_erase_all_rec (f x y) z)  ($eo_prepend_if (eo::not (eo::eq z x))
                                            f x ($eo_list_erase_all_rec y z)))
  (($eo_list_erase_all_rec nil z)       nil)
  )
)

; define: $eo_list_erase_all
; implements: eo::list_erase_all
(define $eo_list_erase_all
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T V V)) (a U) (e W))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_erase_all_rec a e)))

;;; $eo_list_setof

; Note: a helper for $eo_list_setof.
(program $eo_list_setof_rec
  ((T Type) (U Type) (V Type) (W Type)
   (f (-> T V V)) (x W) (y U) (nil U))
  :signature (U) U
  (
  (($eo_list_setof_rec (f x y))  (f x ($eo_list_setof_rec ($eo_list_erase_all f y x))))
  (($eo_list_setof_rec nil)      nil)
  )
)

; define: $eo_list_setof
; implements: eo::list_setof
(define $eo_list_setof
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (f (-> T V V)) (a U))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_setof_rec a)))

;;; $eo_list_minclude

; program: $eo_list_minclude_rec
; - y $eo_List: The first list.
; - z $eo_List: The second list.
; - rmLast Bool: false if we failed to remove the last element of y from z.
; return: true iff we successfully remove all elements of y from z.
; note: a helper for $eo_list_minclude.
(program $eo_list_minclude_rec
  ((T Type) (x T) (y $eo_List :list) (z $eo_List))
  :signature ($eo_List $eo_List Bool) Bool
  (
  (($eo_list_minclude_rec y z false)            false)
  (($eo_list_minclude_rec ($eo_List_cons x y) z true)
    (eo::define ((res ($eo_list_erase $eo_List_cons z x)))
      ; pass true iff we successfully removed x from z.
      ($eo_list_minclude_rec y res (eo::not (eo::eq res z)))))
  (($eo_list_minclude_rec $eo_List_nil z true)  true)
  )
)

; define: $eo_list_minclude
; implements: eo::list_minclude
; Note: >
;   Since $eo_list_erase is a key submethod for defining $eo_list_minclude,
;   and $eo_list_erase requires functions (-> T V V), we convert the elements
;   of both lists to builtin lists $eo_List using the auxiliary method
;   $eo_get_elements in this definition.
(define $eo_list_minclude
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (W1 Type :implicit) (W2 Type :implicit)
   (f (-> T U V)) (a W1) (b W2))
  (eo::requires ($eo_is_list f a) true
  (eo::requires ($eo_is_list f b) true
    ($eo_list_minclude_rec ($eo_get_elements f a) ($eo_get_elements f b) true))))

;;; $eo_list_meq

; define: $eo_list_meq
; implements: eo::list_meq
(define $eo_list_meq
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (W1 Type :implicit) (W2 Type :implicit)
   (f (-> T U V)) (a W1) (b W2))
  (eo::and ($eo_list_minclude f a b) ($eo_list_minclude f b a)))

;;; $eo_list_diff

; Note: a helper for $eo_list_diff.
(program $eo_list_diff_rec
  ((T Type) (V Type) (x T) (y V) (f (-> T V V)) (nil V) (z V))
  :signature (V V) V
  (
  (($eo_list_diff_rec (f x y) z)  (eo::define ((res ($eo_list_erase f z x)))
                                    ($eo_prepend_if (eo::eq res z)
                                      f x ($eo_list_diff_rec y res))))
  (($eo_list_diff_rec nil z)      nil)
  )
)

; define: $eo_list_diff
; implements: eo::list_diff
(define $eo_list_diff
  ((T Type :implicit) (V Type :implicit)
   (f (-> T V V)) (a V) (b V))
  (eo::requires ($eo_is_list f a) true
  (eo::requires ($eo_is_list f b) true
    ($eo_list_diff_rec a b))))

;;; $eo_list_inter

; Note: a helper for $eo_list_inter
(program $eo_list_inter_rec
  ((T Type) (V Type) (x T) (y V) (f (-> T V V)) (nil V) (z V))
  :signature (V V) V
  (
  (($eo_list_inter_rec (f x y) z) (eo::define ((res ($eo_list_erase f z x)))
                                    ($eo_prepend_if (eo::not (eo::eq res z))
                                      f x ($eo_list_inter_rec y res))))
  (($eo_list_inter_rec nil z)     nil)
  )
)

; define: $eo_list_inter
; implements: eo::list_inter
(define $eo_list_inter
  ((T Type :implicit) (V Type :implicit)
   (f (-> T V V)) (a V) (b V))
  (eo::requires ($eo_is_list f a) true
  (eo::requires ($eo_is_list f b) true
    ($eo_list_inter_rec a b))))

;;; $eo_list_singleton_elim

; Note: a helper for $eo_list_singleton_elim.
(program $eo_list_singleton_elim_2
  ((T Type) (f (-> T T T)) (x T) (y T) (z T) (nil T))
  :signature (T T) T
  (
  (($eo_list_singleton_elim_2 nil (f x y))  (eo::ite (eo::eq y nil) x (f x y)))
  (($eo_list_singleton_elim_2 nil z)        z)
  )
)

; define: $eo_list_singleton_elim
; implements: eo::list_singleton_elim
(define $eo_list_singleton_elim
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T U V)) (a W))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_singleton_elim_2 ($eo_nil f ($eo_typeof a)) a)))

; all further definitions

; declare: @@Pair
(declare-const @@Pair (-> Type (-> Type Type)))
; declare: @@pair
(declare-parameterized-const @@pair ((U Type :implicit) ($eo_x_1 U) (T Type :implicit) ($eo_x_2 T)) (_ (@@Pair U) T))
; program: $pair_first
(program $pair_first ((S Type) (T Type) (s S) (t T))
  :signature ((_ (@@Pair T) S)) T
  (
  (($pair_first (_ (@@pair t) s)) t)
  )
)
; program: $pair_second
(program $pair_second ((T Type) (S Type) (t T) (s S))
  :signature ((_ (@@Pair T) S)) S
  (
  (($pair_second (_ (@@pair t) s)) s)
  )
)
; declare: ite
(declare-parameterized-const ite (($eo_x_1 Bool) (A Type :implicit) ($eo_x_2 A) ($eo_x_3 A)) A)
; declare: not
(declare-const not (-> Bool Bool))
; declare: or
(declare-const or (-> Bool (-> Bool Bool)))
; declare: and
(declare-const and (-> Bool (-> Bool Bool)))
; declare: =>
(declare-const => (-> Bool (-> Bool Bool)))
; declare: xor
(declare-const xor (-> Bool (-> Bool Bool)))
; declare: =
(declare-parameterized-const = ((A Type :implicit) ($eo_x_1 A) ($eo_x_2 A)) Bool)
; program: $arith_typeunion
(program $arith_typeunion ()
  :signature (Type Type) Type
  (
  (($arith_typeunion Int Int) Int)
  (($arith_typeunion Real Real) Real)
  (($arith_typeunion Real Int) Real)
  (($arith_typeunion Int Real) Real)
  )
)
; program: $is_arith_type
(program $is_arith_type ()
  :signature (Type) Bool
  (
  (($is_arith_type Int) true)
  (($is_arith_type Real) true)
  )
)
; declare: +
(declare-parameterized-const + ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) ($arith_typeunion T U))
; declare: -
(declare-parameterized-const - ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) ($arith_typeunion T U))
; declare: *
(declare-parameterized-const * ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) ($arith_typeunion T U))
; declare: <
(declare-parameterized-const < ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
; declare: <=
(declare-parameterized-const <= ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
; declare: >
(declare-parameterized-const > ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
; declare: >=
(declare-parameterized-const >= ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
; declare: to_real
(declare-parameterized-const to_real ((T Type :implicit) ($eo_x_1 T)) Real)
; declare: to_int
(declare-parameterized-const to_int ((T Type :implicit) ($eo_x_1 T)) Int)
; declare: is_int
(declare-parameterized-const is_int ((T Type :implicit) ($eo_x_1 T)) Bool)
; declare: abs
(declare-parameterized-const abs ((T Type :implicit) ($eo_x_1 T)) T)
; declare: -
(declare-parameterized-const $eoo_-.2 ((T Type :implicit) ($eo_x_1 T)) T)
; declare: div
(declare-const div (-> Int (-> Int Int)))
; declare: mod
(declare-const mod (-> Int (-> Int Int)))
; declare: int.pow2
(declare-const int.pow2 (-> Int Int))
; declare: int.log2
(declare-const int.log2 (-> Int Int))
; declare: int.ispow2
(declare-const int.ispow2 (-> Int Bool))
; declare: div_total
(declare-const div_total (-> Int (-> Int Int)))
; declare: mod_total
(declare-const mod_total (-> Int (-> Int Int)))
; program: $arith_eval_int_log_2_rec
(program $arith_eval_int_log_2_rec ((x Int))
  :signature (Int) Int
  (
  (($arith_eval_int_log_2_rec 1) 0)
  (($arith_eval_int_log_2_rec x) (eo::add 1 ($arith_eval_int_log_2_rec (eo::zdiv x 2))))
  )
)
; program: $arith_eval_int_pow_2_rec
(program $arith_eval_int_pow_2_rec ((x Int))
  :signature (Int) Int
  (
  (($arith_eval_int_pow_2_rec 0) 1)
  (($arith_eval_int_pow_2_rec x) (eo::mul 2 ($arith_eval_int_pow_2_rec (eo::add x -1))))
  )
)
; program: $bv_bitwidth
(program $bv_bitwidth ((n Int))
  :signature (Type) Int
  (
  (($bv_bitwidth (BitVec n)) n)
  )
)
; declare: @bvsize
(declare-parameterized-const @bvsize ((m Int :implicit) ($eo_x_1 (BitVec m))) Int)
; declare: concat
(declare-parameterized-const concat ((n Int :implicit) ($eo_x_1 (BitVec n)) (m Int :implicit) ($eo_x_2 (BitVec m))) (BitVec (eo::add n m)))
; declare: extract
(declare-parameterized-const extract ((h Int) (l Int) (n Int :implicit) ($eo_x_1 (BitVec n))) (BitVec (eo::requires (eo::gt (eo::add l 1) 0) true (eo::requires (eo::gt n h) true (eo::add (eo::add h (eo::neg l)) 1)))))
; declare: repeat
(declare-parameterized-const repeat ((i Int) (n Int :implicit) ($eo_x_1 (BitVec n))) (BitVec (eo::mul i n)))
; declare: bvnot
(declare-parameterized-const bvnot ((m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec m))
; declare: bvand
(declare-parameterized-const bvand ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
; declare: bvor
(declare-parameterized-const bvor ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
; declare: bvxor
(declare-parameterized-const bvxor ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
; declare: bvneg
(declare-parameterized-const bvneg ((m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec m))
; declare: bvadd
(declare-parameterized-const bvadd ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
; declare: bvmul
(declare-parameterized-const bvmul ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
; declare: bvudiv
(declare-parameterized-const bvudiv ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
; declare: bvurem
(declare-parameterized-const bvurem ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
; declare: bvsub
(declare-parameterized-const bvsub ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
; declare: bvult
(declare-parameterized-const bvult ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
; declare: bvule
(declare-parameterized-const bvule ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
; declare: bvugt
(declare-parameterized-const bvugt ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
; declare: bvuge
(declare-parameterized-const bvuge ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
; declare: bvslt
(declare-parameterized-const bvslt ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
; declare: bvsle
(declare-parameterized-const bvsle ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
; declare: bvsgt
(declare-parameterized-const bvsgt ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
; declare: bvsge
(declare-parameterized-const bvsge ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
; declare: bvshl
(declare-parameterized-const bvshl ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
; declare: bvlshr
(declare-parameterized-const bvlshr ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
; declare: bvashr
(declare-parameterized-const bvashr ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
; declare: zero_extend
(declare-parameterized-const zero_extend ((i Int) (m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec (eo::add m i)))
; declare: sign_extend
(declare-parameterized-const sign_extend ((i Int) (m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec (eo::add m i)))
; declare: @bv
(declare-parameterized-const @bv ((value Int) (w Int)) (BitVec w))
; declare: seq.empty
(declare-parameterized-const seq.empty ((T Type :implicit)) (Seq T))
; program: $seq_empty
(program $seq_empty ((T Type))
  :signature ((eo::quote T)) T
  (
  (($seq_empty (Seq Char)) "")
  (($seq_empty T) (as seq.empty T))
  )
)
; declare: str.len
(declare-parameterized-const str.len ((T Type :implicit) ($eo_x_1 (Seq T))) Int)
; declare: str.++
(declare-parameterized-const str.++ ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) (Seq T))
; declare: str.substr
(declare-parameterized-const str.substr ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 Int) ($eo_x_3 Int)) (Seq T))
; declare: str.contains
(declare-parameterized-const str.contains ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) Bool)
; declare: str.replace
(declare-parameterized-const str.replace ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T)) ($eo_x_3 (Seq T))) (Seq T))
; declare: str.indexof
(declare-parameterized-const str.indexof ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T)) ($eo_x_3 Int)) Int)
; declare: str.at
(declare-parameterized-const str.at ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 Int)) (Seq T))
; declare: str.prefixof
(declare-parameterized-const str.prefixof ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) Bool)
; declare: str.suffixof
(declare-parameterized-const str.suffixof ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) Bool)
; declare: str.rev
(declare-parameterized-const str.rev ((T Type :implicit) ($eo_x_1 (Seq T))) (Seq T))
; declare: str.update
(declare-parameterized-const str.update ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 Int) ($eo_x_3 (Seq T))) (Seq T))
; declare: str.to_lower
(declare-const str.to_lower (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
; declare: str.to_upper
(declare-const str.to_upper (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
; declare: str.to_code
(declare-const str.to_code (-> (Seq Char) Int))
; declare: str.from_code
(declare-const str.from_code (-> Int (Seq Char)))
; declare: str.to_int
(declare-const str.to_int (-> (Seq Char) Int))
; declare: str.from_int
(declare-const str.from_int (-> Int (Seq Char)))
; declare: str.<=
(declare-const str.<= (eo::define ((_v0 (Seq Char))) (-> _v0 (-> _v0 Bool))))
; declare: str.replace_all
(declare-parameterized-const str.replace_all ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T)) ($eo_x_3 (Seq T))) (Seq T))
; declare: /
(declare-parameterized-const / ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Real)
; declare: /_total
(declare-parameterized-const /_total ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Real)
; program: $bv_unfold_repeat_rec
(program $bv_unfold_repeat_rec ((m Int) (n Int) (b (BitVec m)))
  :signature ((eo::quote n) (BitVec m)) (BitVec (eo::mul n m))
  (
  (($bv_unfold_repeat_rec 0 b) (eo::to_bin 0 0))
  (($bv_unfold_repeat_rec n b) (eo::cons concat b ($bv_unfold_repeat_rec (eo::add n -1) b)))
  )
)
; program: $str_nary_intro
(program $str_nary_intro ((T Type) (ss (Seq T)) (t (Seq T)))
  :signature ((Seq T)) (Seq T)
  (
  (($str_nary_intro (_ (str.++ t) ss)) (_ (str.++ t) ss))
  (($str_nary_intro t) (eo::define ((_v0 ($seq_empty (eo::typeof t)))) (eo::ite (eo::eq t _v0) t (eo::cons str.++ t _v0))))
  )
)
; program: $str_nary_elim
(program $str_nary_elim ((T Type) (ss (Seq T)) (t (Seq T)))
  :signature ((Seq T)) (Seq T)
  (
  (($str_nary_elim (_ (str.++ t) ss)) (eo::ite (eo::eq ss ($seq_empty (eo::typeof t))) t (_ (str.++ t) ss)))
  (($str_nary_elim t) (eo::requires t ($seq_empty (eo::typeof t)) t))
  )
)
; program: $str_flatten_word
(program $str_flatten_word ((U Type) (t (Seq U)))
  :signature ((Seq U)) (Seq U)
  (
  (($str_flatten_word "") "")
  (($str_flatten_word t) (eo::cons str.++ (eo::extract t 0 0) ($str_flatten_word (eo::extract t 1 (eo::len t)))))
  )
)
; program: $str_flatten
(program $str_flatten ((U Type) (tail (Seq U)) (t (Seq U)))
  :signature ((Seq U)) (Seq U)
  (
  (($str_flatten (_ (str.++ t) tail)) (eo::define ((_v0 ($str_flatten tail))) (eo::ite (eo::is_eq (eo::is_neg (eo::add 1 (eo::neg (eo::len t)))) true) (eo::list_concat str.++ ($str_flatten_word t) _v0) (eo::cons str.++ t _v0))))
  (($str_flatten t) (eo::requires t ($seq_empty (eo::typeof t)) t))
  )
)
; program: $str_collect_acc
(program $str_collect_acc ((U Type) (t (Seq U)) (tail (Seq U)))
  :signature ((Seq U)) (eo::define ((_v0 (Seq U))) (_ (@@Pair _v0) _v0))
  (
  (($str_collect_acc (_ (str.++ t) tail)) (eo::define ((_v0 ($str_collect_acc tail))) (eo::define ((_v1 ($pair_second _v0))) (eo::define ((_v2 ($pair_first _v0))) (eo::ite (eo::is_eq (eo::len t) 1) (eo::ite (eo::eq _v2 "") (_ (@@pair t) _v1) (_ (@@pair (eo::concat t _v2)) _v1)) (_ (@@pair "") (_ (str.++ t) tail)))))))
  (($str_collect_acc "") (_ (@@pair "") ""))
  )
)
; program: $str_collect
(program $str_collect ((U Type) (s (Seq U)) (t (Seq U)))
  :signature ((Seq U)) (Seq U)
  (
  (($str_collect (_ (str.++ t) s)) (eo::define ((_v0 ($str_collect_acc (_ (str.++ t) s)))) (eo::define ((_v1 ($pair_first _v0))) (eo::ite (eo::eq _v1 "") (eo::cons str.++ t ($str_collect s)) (eo::cons str.++ _v1 ($str_collect ($pair_second _v0)))))))
  (($str_collect t) (eo::requires t ($seq_empty (eo::typeof t)) t))
  )
)
; program: $str_from_int_eval_rec
(program $str_from_int_eval_rec ((n Int) (s (Seq Char)))
  :signature (Int (Seq Char)) (Seq Char)
  (
  (($str_from_int_eval_rec n s) (eo::ite (eo::eq n 0) (eo::ite (eo::eq s "") "0" s) ($str_from_int_eval_rec (eo::zdiv n 10) (eo::concat (eo::to_str (eo::add 48 (eo::zmod n 10))) s))))
  )
)
; program: $str_to_int_eval_rec
(program $str_to_int_eval_rec ((s2 (Seq Char)) (s1 (Seq Char)) (e Int) (n Int))
  :signature ((Seq Char) Int Int) Int
  (
  (($str_to_int_eval_rec (_ (str.++ s1) s2) e n) (eo::define ((_v0 (eo::add (eo::to_z s1) -48))) (eo::ite (eo::and (eo::gt 10 _v0) (eo::not (eo::is_neg _v0))) ($str_to_int_eval_rec s2 (eo::mul e 10) (eo::add (eo::mul _v0 e) n)) -1)))
  (($str_to_int_eval_rec "" e n) n)
  )
)
; program: $str_case_conv_rec
(program $str_case_conv_rec ((s1 (Seq Char)) (s2 (Seq Char)) (isLower Bool))
  :signature ((Seq Char) Bool) (Seq Char)
  (
  (($str_case_conv_rec (_ (str.++ s1) s2) true) (eo::define ((_v0 (eo::to_z s1))) (eo::concat (eo::to_str (eo::add _v0 (eo::ite (eo::and (eo::gt 91 _v0) (eo::gt _v0 64)) 32 0))) ($str_case_conv_rec s2 true))))
  (($str_case_conv_rec (_ (str.++ s1) s2) false) (eo::define ((_v0 (eo::to_z s1))) (eo::concat (eo::to_str (eo::add _v0 (eo::ite (eo::and (eo::gt 123 _v0) (eo::gt _v0 96)) -32 0))) ($str_case_conv_rec s2 false))))
  (($str_case_conv_rec "" isLower) "")
  )
)
; program: $str_leq_eval_rec
(program $str_leq_eval_rec ((s2 (Seq Char)) (t2 (Seq Char)) (s1 (Seq Char)) (t1 (Seq Char)))
  :signature ((Seq Char) (Seq Char)) Bool
  (
  (($str_leq_eval_rec (_ (str.++ s1) s2) (_ (str.++ t1) t2)) (eo::ite (eo::eq s1 t1) ($str_leq_eval_rec s2 t2) (eo::gt (eo::to_z t1) (eo::to_z s1))))
  (($str_leq_eval_rec "" t1) true)
  (($str_leq_eval_rec s1 t1) false)
  )
)
; program: $str_eval_replace_all_rec
(program $str_eval_replace_all_rec ((u (Seq Char)) (n Int) (s (Seq Char)) (t (Seq Char)) (lent Int))
  :signature ((Seq Char) (Seq Char) (Seq Char) Int Int) (Seq Char)
  (
  (($str_eval_replace_all_rec s t u -1 lent) s)
  (($str_eval_replace_all_rec s t u n lent) (eo::define ((_v0 (eo::extract s (eo::add n lent) (eo::len s)))) (eo::concat (eo::concat (eo::extract s 0 (eo::add n -1)) u) ($str_eval_replace_all_rec _v0 t u (eo::find _v0 t) lent))))
  )
)
; declare: int_to_bv
(declare-parameterized-const int_to_bv ((w Int) ($eo_x_1 Int)) (BitVec w))
; declare: ubv_to_int
(declare-parameterized-const ubv_to_int ((m Int :implicit) ($eo_x_1 (BitVec m))) Int)
; declare: sbv_to_int
(declare-parameterized-const sbv_to_int ((m Int :implicit) ($eo_x_1 (BitVec m))) Int)
; program: $run_evaluate
(program $run_evaluate ((S Type) (bs Bool) (b Bool) (b2 Bool) (ys S) (T Type) (y T) (i2 Int) (x T) (i1 Int) (sys (Seq T)) (sz (Seq T)) (ssz (Seq Char)) (ssy (Seq Char)) (ssx (Seq Char)) (sy (Seq T)) (sx (Seq T)) (m Int) (ybs (BitVec m)) (n Int) (zbs (BitVec n)) (yb (BitVec m)) (xb (BitVec m)) (z S))
  :signature (S) S
  (
  (($run_evaluate (_ (= x) y)) (eo::define ((_v0 ($run_evaluate y))) (eo::define ((_v1 ($run_evaluate x))) (eo::define ((_v2 (eo::eq _v1 _v0))) (eo::ite (eo::and (eo::is_q _v1) (eo::is_q _v0)) _v2 (eo::ite (eo::and (eo::is_z _v1) (eo::is_z _v0)) _v2 (eo::ite (eo::and (eo::is_bin _v1) (eo::is_bin _v0)) _v2 (eo::ite (eo::and (eo::is_str _v1) (eo::is_str _v0)) _v2 (eo::ite (eo::and (eo::is_bool _v1) (eo::is_bool _v0)) _v2 (_ (= _v1) _v0))))))))))
  (($run_evaluate (not b)) (eo::not ($run_evaluate b)))
  (($run_evaluate (_ (_ (ite b) x) y)) (eo::ite ($run_evaluate b) ($run_evaluate x) ($run_evaluate y)))
  (($run_evaluate (_ (or b) bs)) (eo::or ($run_evaluate b) ($run_evaluate bs)))
  (($run_evaluate (_ (=> b) b2)) (eo::or (eo::not ($run_evaluate b)) ($run_evaluate b2)))
  (($run_evaluate (_ (and b) bs)) (eo::and ($run_evaluate b) ($run_evaluate bs)))
  (($run_evaluate (_ (xor b) b2)) (eo::xor ($run_evaluate b) ($run_evaluate b2)))
  (($run_evaluate (_ (< x) z)) (eo::is_neg (eo::add (eo::to_q ($run_evaluate x)) (eo::neg (eo::to_q ($run_evaluate z))))))
  (($run_evaluate (_ (<= x) z)) (eo::define ((_v0 (eo::add (eo::to_q ($run_evaluate x)) (eo::neg (eo::to_q ($run_evaluate z)))))) (eo::or (eo::is_neg _v0) (eo::eq _v0 0/1))))
  (($run_evaluate (_ (> x) z)) (eo::is_neg (eo::add (eo::to_q ($run_evaluate z)) (eo::neg (eo::to_q ($run_evaluate x))))))
  (($run_evaluate (_ (>= x) z)) (eo::define ((_v0 (eo::add (eo::to_q ($run_evaluate z)) (eo::neg (eo::to_q ($run_evaluate x)))))) (eo::or (eo::is_neg _v0) (eo::eq _v0 0/1))))
  (($run_evaluate (_ (+ x) ys)) (eo::define ((_v0 ($run_evaluate ys))) (eo::define ((_v1 ($run_evaluate x))) (eo::define ((_v2 (eo::to_q _v0))) (eo::define ((_v3 (eo::to_q _v1))) (eo::define ((_v4 (eo::add _v3 _v2))) (eo::ite (eo::eq _v1 _v3) _v4 (eo::ite (eo::eq _v0 _v2) _v4 (eo::add _v1 _v0)))))))))
  (($run_evaluate (_ (- x) z)) (eo::define ((_v0 (eo::neg ($run_evaluate z)))) (eo::define ((_v1 ($run_evaluate x))) (eo::define ((_v2 (eo::to_q _v0))) (eo::define ((_v3 (eo::to_q _v1))) (eo::define ((_v4 (eo::add _v3 _v2))) (eo::ite (eo::eq _v1 _v3) _v4 (eo::ite (eo::eq _v0 _v2) _v4 (eo::add _v1 _v0)))))))))
  (($run_evaluate (_ (* x) ys)) (eo::define ((_v0 ($run_evaluate ys))) (eo::define ((_v1 ($run_evaluate x))) (eo::define ((_v2 (eo::to_q _v0))) (eo::define ((_v3 (eo::to_q _v1))) (eo::define ((_v4 (eo::mul _v3 _v2))) (eo::ite (eo::eq _v1 _v3) _v4 (eo::ite (eo::eq _v0 _v2) _v4 (eo::mul _v1 _v0)))))))))
  (($run_evaluate ($eoo_-.2 x)) (eo::neg ($run_evaluate x)))
  (($run_evaluate (_ (/ x) y)) (eo::qdiv (eo::to_q ($run_evaluate x)) (eo::to_q ($run_evaluate y))))
  (($run_evaluate (_ (/_total x) y)) (eo::define ((_v0 (eo::to_q ($run_evaluate y)))) (eo::ite (eo::eq _v0 0/1) 0/1 (eo::qdiv (eo::to_q ($run_evaluate x)) _v0))))
  (($run_evaluate (_ (div i1) i2)) (eo::zdiv ($run_evaluate i1) ($run_evaluate i2)))
  (($run_evaluate (_ (div_total i1) i2)) (eo::define ((_v0 ($run_evaluate i2))) (eo::ite (eo::eq _v0 0) 0 (eo::zdiv ($run_evaluate i1) _v0))))
  (($run_evaluate (_ (mod i1) i2)) (eo::zmod ($run_evaluate i1) ($run_evaluate i2)))
  (($run_evaluate (_ (mod_total i1) i2)) (eo::define ((_v0 ($run_evaluate i2))) (eo::define ((_v1 ($run_evaluate i1))) (eo::ite (eo::eq _v0 0) _v1 (eo::zmod _v1 _v0)))))
  (($run_evaluate (to_real x)) (eo::to_q ($run_evaluate x)))
  (($run_evaluate (to_int x)) (eo::to_z ($run_evaluate x)))
  (($run_evaluate (is_int x)) (eo::define ((_v0 ($run_evaluate x))) (eo::eq (eo::to_q (eo::to_z _v0)) (eo::to_q _v0))))
  (($run_evaluate (abs x)) (eo::define ((_v0 ($run_evaluate x))) (eo::ite (eo::is_neg _v0) (eo::neg _v0) _v0)))
  (($run_evaluate (int.log2 i1)) (eo::define ((_v0 ($run_evaluate i1))) (eo::ite (eo::is_neg (eo::neg _v0)) ($arith_eval_int_log_2_rec _v0) 0)))
  (($run_evaluate (int.pow2 i1)) (eo::define ((_v0 ($run_evaluate i1))) (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) 0 ($arith_eval_int_pow_2_rec _v0)) (int.pow2 _v0))))
  (($run_evaluate (int.ispow2 i1)) (eo::define ((_v0 ($run_evaluate i1))) (eo::define ((_v1 (eo::ite (eo::is_neg (eo::neg _v0)) ($arith_eval_int_log_2_rec _v0) 0))) (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) false (eo::eq _v0 (eo::ite (eo::is_z _v1) (eo::ite (eo::is_neg _v1) 0 ($arith_eval_int_pow_2_rec _v1)) (int.pow2 _v1)))) (int.ispow2 _v0)))))
  (($run_evaluate (_ (str.++ sx) sys)) (eo::concat ($run_evaluate sx) ($run_evaluate sys)))
  (($run_evaluate (str.len sx)) (eo::len ($run_evaluate sx)))
  (($run_evaluate (_ (_ (str.substr sx) n) m)) (eo::define ((_v0 ($run_evaluate n))) (eo::extract ($run_evaluate sx) _v0 (eo::add (eo::add _v0 ($run_evaluate m)) -1))))
  (($run_evaluate (_ (str.at sx) n)) (eo::define ((_v0 ($run_evaluate n))) (eo::extract ($run_evaluate sx) _v0 _v0)))
  (($run_evaluate (_ (str.contains sx) sy)) (eo::not (eo::is_neg (eo::find ($run_evaluate sx) ($run_evaluate sy)))))
  (($run_evaluate (_ (_ (str.replace sx) sy) sz)) (eo::define ((_v0 ($run_evaluate sx))) (eo::define ((_v1 ($run_evaluate sy))) (eo::define ((_v2 (eo::find (eo::to_str _v0) (eo::to_str _v1)))) (eo::ite (eo::is_neg _v2) _v0 (eo::concat (eo::concat (eo::extract _v0 0 (eo::add _v2 -1)) ($run_evaluate sz)) (eo::extract _v0 (eo::add _v2 (eo::len _v1)) (eo::len _v0))))))))
  (($run_evaluate (_ (_ (str.replace_all ssx) ssy) ssz)) (eo::ite (eo::and (eo::and (eo::is_str ssx) (eo::is_str ssy)) (eo::is_str ssz)) (eo::ite (eo::eq ssy "") ssx ($str_eval_replace_all_rec ssx ssy ssz (eo::find ssx ssy) (eo::len ssy))) (_ (_ (str.replace_all ssx) ssy) ssz)))
  (($run_evaluate (_ (str.prefixof sx) sy)) (eo::define ((_v0 ($run_evaluate sx))) (eo::eq _v0 (eo::extract ($run_evaluate sy) 0 (eo::add (eo::len _v0) -1)))))
  (($run_evaluate (_ (str.suffixof sx) sy)) (eo::define ((_v0 ($run_evaluate sy))) (eo::define ((_v1 (eo::len _v0))) (eo::define ((_v2 ($run_evaluate sx))) (eo::eq _v2 (eo::extract _v0 (eo::add _v1 (eo::neg (eo::len _v2))) (eo::add _v1 -1)))))))
  (($run_evaluate (_ (_ (str.indexof sx) sy) n)) (eo::define ((_v0 ($run_evaluate sx))) (eo::define ((_v1 (eo::len _v0))) (eo::define ((_v2 (eo::find (eo::to_str (eo::extract _v0 n _v1)) (eo::to_str ($run_evaluate sy))))) (eo::define ((_v3 ($run_evaluate n))) (eo::ite (eo::is_neg _v3) -1 (eo::ite (eo::gt _v3 _v1) -1 (eo::ite (eo::is_neg _v2) _v2 (eo::add n _v2)))))))))
  (($run_evaluate (str.to_code ssx)) (eo::define ((_v0 ($run_evaluate ssx))) (eo::define ((_v1 (eo::len _v0))) (eo::ite (eo::eq _v1 1) (eo::to_z _v0) (eo::ite (eo::is_z _v1) -1 (str.to_code _v0))))))
  (($run_evaluate (str.from_code n)) (eo::define ((_v0 ($run_evaluate n))) (eo::ite (eo::ite (eo::is_z _v0) (eo::ite (eo::ite (eo::eq 196608 _v0) true (eo::gt 196608 _v0)) (eo::not (eo::is_neg _v0)) false) false) (eo::to_str n) "")))
  (($run_evaluate (str.to_int ssx)) (eo::define ((_v0 ($run_evaluate ssx))) (eo::ite (eo::is_str _v0) (eo::ite (eo::eq _v0 "") -1 ($str_to_int_eval_rec (eo::list_rev str.++ ($str_flatten ($str_nary_intro _v0))) 1 0)) (str.to_int _v0))))
  (($run_evaluate (str.from_int n)) (eo::define ((_v0 ($run_evaluate n))) (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) "" ($str_from_int_eval_rec _v0 "")) (str.from_int _v0))))
  (($run_evaluate (_ (str.<= ssx) ssy)) (eo::define ((_v0 ($run_evaluate ssy))) (eo::define ((_v1 ($run_evaluate ssx))) (eo::ite (eo::and (eo::is_str _v1) (eo::is_str _v0)) ($str_leq_eval_rec ($str_flatten ($str_nary_intro _v1)) ($str_flatten ($str_nary_intro _v0))) (_ (str.<= _v1) _v0)))))
  (($run_evaluate (str.to_lower ssx)) (eo::define ((_v0 ($run_evaluate ssx))) (eo::ite (eo::is_str _v0) ($str_case_conv_rec ($str_flatten ($str_nary_intro _v0)) true) (str.to_lower _v0))))
  (($run_evaluate (str.to_upper ssx)) (eo::define ((_v0 ($run_evaluate ssx))) (eo::ite (eo::is_str _v0) ($str_case_conv_rec ($str_flatten ($str_nary_intro _v0)) false) (str.to_upper _v0))))
  (($run_evaluate (str.rev sx)) (eo::define ((_v0 ($run_evaluate sx))) (eo::ite (eo::is_str _v0) ($str_nary_elim ($str_collect (eo::list_rev str.++ ($str_flatten ($str_nary_intro _v0))))) (str.rev _v0))))
  (($run_evaluate (_ (_ (str.update sx) n) sy)) (eo::define ((_v0 ($run_evaluate sx))) (eo::define ((_v1 (eo::len _v0))) (eo::define ((_v2 ($run_evaluate sy))) (eo::define ((_v3 ($run_evaluate n))) (eo::ite (eo::or (eo::gt 0 _v3) (eo::gt _v3 _v1)) _v0 (eo::concat (eo::concat (eo::extract _v0 0 (eo::add _v3 -1)) (eo::extract _v2 0 (eo::add (eo::add (eo::neg _v3) _v1) -1))) (eo::extract _v0 (eo::add _v3 (eo::len _v2)) _v1))))))))
  (($run_evaluate (bvnot xb)) (eo::not ($run_evaluate xb)))
  (($run_evaluate (bvneg xb)) (eo::neg ($run_evaluate xb)))
  (($run_evaluate (_ (bvadd xb) ybs)) (eo::add ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvmul xb) ybs)) (eo::mul ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvudiv xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($bv_bitwidth (eo::typeof xb)))) (eo::ite (eo::eq (eo::to_z _v0) 0) (eo::to_bin _v1 (eo::add (eo::ite (eo::is_z _v1) (eo::ite (eo::is_neg _v1) 0 ($arith_eval_int_pow_2_rec _v1)) (int.pow2 _v1)) -1)) (eo::zdiv ($run_evaluate xb) _v0)))))
  (($run_evaluate (_ (bvurem xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($run_evaluate xb))) (eo::ite (eo::eq (eo::to_z _v0) 0) _v1 (eo::zmod _v1 _v0)))))
  (($run_evaluate (_ (bvand xb) ybs)) (eo::and ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvor xb) ybs)) (eo::or ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvxor xb) ybs)) (eo::xor ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (concat xb) zbs)) (eo::concat ($run_evaluate xb) ($run_evaluate zbs)))
  (($run_evaluate (_ (bvsub xb) yb)) (eo::add ($run_evaluate xb) (eo::neg ($run_evaluate yb))))
  (($run_evaluate (_ (_ (extract m) n) xb)) (eo::extract ($run_evaluate xb) n m))
  (($run_evaluate (_ (bvult xb) yb)) ($run_evaluate (_ (bvugt yb) xb)))
  (($run_evaluate (_ (bvule xb) yb)) ($run_evaluate (_ (bvuge yb) xb)))
  (($run_evaluate (_ (bvugt xb) yb)) (eo::gt (eo::to_z ($run_evaluate xb)) (eo::to_z ($run_evaluate yb))))
  (($run_evaluate (_ (bvuge xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($run_evaluate xb))) (eo::or (eo::gt _v1 _v0) (eo::eq _v1 _v0)))))
  (($run_evaluate (_ (bvslt xb) yb)) ($run_evaluate (_ (bvsgt yb) xb)))
  (($run_evaluate (_ (bvsle xb) yb)) ($run_evaluate (_ (bvsge yb) xb)))
  (($run_evaluate (_ (bvsgt xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($bv_bitwidth (eo::typeof _v0)))) (eo::define ((_v2 (eo::to_z (eo::extract _v0 0 (eo::add _v1 -2))))) (eo::define ((_v3 (eo::add _v1 -1))) (eo::define ((_v4 ($run_evaluate xb))) (eo::define ((_v5 ($bv_bitwidth (eo::typeof _v4)))) (eo::define ((_v6 (eo::to_z (eo::extract _v4 0 (eo::add _v5 -2))))) (eo::define ((_v7 (eo::add _v5 -1))) (eo::gt (eo::ite (eo::eq (eo::extract _v4 _v7 _v7) #b1) (eo::add (eo::neg (eo::ite (eo::is_z _v7) (eo::ite (eo::is_neg _v7) 0 ($arith_eval_int_pow_2_rec _v7)) (int.pow2 _v7))) _v6) _v6) (eo::ite (eo::eq (eo::extract _v0 _v3 _v3) #b1) (eo::add (eo::neg (eo::ite (eo::is_z _v3) (eo::ite (eo::is_neg _v3) 0 ($arith_eval_int_pow_2_rec _v3)) (int.pow2 _v3))) _v2) _v2)))))))))))
  (($run_evaluate (_ (bvsge xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($bv_bitwidth (eo::typeof _v0)))) (eo::define ((_v2 (eo::to_z (eo::extract _v0 0 (eo::add _v1 -2))))) (eo::define ((_v3 (eo::add _v1 -1))) (eo::define ((_v4 (eo::ite (eo::eq (eo::extract _v0 _v3 _v3) #b1) (eo::add (eo::neg (eo::ite (eo::is_z _v3) (eo::ite (eo::is_neg _v3) 0 ($arith_eval_int_pow_2_rec _v3)) (int.pow2 _v3))) _v2) _v2))) (eo::define ((_v5 ($run_evaluate xb))) (eo::define ((_v6 ($bv_bitwidth (eo::typeof _v5)))) (eo::define ((_v7 (eo::to_z (eo::extract _v5 0 (eo::add _v6 -2))))) (eo::define ((_v8 (eo::add _v6 -1))) (eo::define ((_v9 (eo::ite (eo::eq (eo::extract _v5 _v8 _v8) #b1) (eo::add (eo::neg (eo::ite (eo::is_z _v8) (eo::ite (eo::is_neg _v8) 0 ($arith_eval_int_pow_2_rec _v8)) (int.pow2 _v8))) _v7) _v7))) (eo::or (eo::gt _v9 _v4) (eo::eq _v9 _v4)))))))))))))
  (($run_evaluate (_ (bvshl xb) yb)) (eo::define ((_v0 (eo::to_z ($run_evaluate yb)))) (eo::define ((_v1 ($bv_bitwidth (eo::typeof xb)))) (eo::ite (eo::gt _v0 _v1) (eo::to_bin _v1 0) (eo::to_bin _v1 (eo::mul (eo::to_z ($run_evaluate xb)) (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) 0 ($arith_eval_int_pow_2_rec _v0)) (int.pow2 _v0))))))))
  (($run_evaluate (_ (bvlshr xb) yb)) (eo::define ((_v0 (eo::to_z ($run_evaluate yb)))) (eo::define ((_v1 ($bv_bitwidth (eo::typeof xb)))) (eo::ite (eo::gt _v0 _v1) (eo::to_bin _v1 0) (eo::to_bin _v1 (eo::zdiv (eo::to_z ($run_evaluate xb)) (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) 0 ($arith_eval_int_pow_2_rec _v0)) (int.pow2 _v0))))))))
  (($run_evaluate (_ (bvashr xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($run_evaluate xb))) (eo::define ((_v2 (eo::add ($bv_bitwidth (eo::typeof _v1)) -1))) (eo::ite (eo::eq (eo::extract _v1 _v2 _v2) #b0) ($run_evaluate (_ (bvlshr _v1) _v0)) ($run_evaluate (bvnot (_ (bvlshr (bvnot _v1)) _v0))))))))
  (($run_evaluate (_ (repeat n) xb)) (eo::define ((_v0 ($run_evaluate xb))) (eo::define ((_v1 ($run_evaluate n))) ($run_evaluate (eo::ite (eo::and (eo::is_z _v1) (eo::not (eo::is_neg _v1))) ($bv_unfold_repeat_rec _v1 _v0) (_ (repeat _v1) _v0))))))
  (($run_evaluate (_ (sign_extend n) xb)) (eo::define ((_v0 ($run_evaluate xb))) (eo::define ((_v1 (eo::add ($bv_bitwidth (eo::typeof _v0)) -1))) (eo::define ((_v2 (eo::extract _v0 _v1 _v1))) (eo::define ((_v3 ($run_evaluate n))) (eo::concat ($run_evaluate (eo::ite (eo::and (eo::is_z _v3) (eo::not (eo::is_neg _v3))) ($bv_unfold_repeat_rec _v3 _v2) (_ (repeat _v3) _v2))) _v0))))))
  (($run_evaluate (_ (zero_extend n) xb)) (eo::define ((_v0 ($run_evaluate n))) (eo::concat ($run_evaluate (eo::ite (eo::and (eo::is_z _v0) (eo::not (eo::is_neg _v0))) ($bv_unfold_repeat_rec _v0 #b0) (_ (repeat _v0) #b0))) ($run_evaluate xb))))
  (($run_evaluate (_ (@bv n) m)) (eo::to_bin ($run_evaluate m) ($run_evaluate n)))
  (($run_evaluate (@bvsize xb)) ($bv_bitwidth (eo::typeof xb)))
  (($run_evaluate (_ (int_to_bv n) m)) (eo::to_bin ($run_evaluate n) ($run_evaluate m)))
  (($run_evaluate (ubv_to_int xb)) (eo::to_z ($run_evaluate xb)))
  (($run_evaluate (sbv_to_int xb)) (eo::define ((_v0 ($bv_bitwidth (eo::typeof xb)))) (eo::define ((_v1 (eo::to_z ($run_evaluate xb)))) (eo::define ((_v2 (eo::add _v0 -1))) (eo::ite (eo::eq (eo::extract xb _v2 _v2) #b0) _v1 (eo::add _v1 (eo::neg (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) 0 ($arith_eval_int_pow_2_rec _v0)) (int.pow2 _v0)))))))))
  (($run_evaluate z) z)
  )
)
; program: $eo_prog_evaluate
(program $eo_prog_evaluate (($eo_arg_0 Type) (U Type) (t U))
  :signature ($eo_arg_0) Bool
  (
  (($eo_prog_evaluate t) (_ (= t) ($run_evaluate t)))
  )
)


;;; type checking

; program: $eo_typeof_apply
(program $eo_typeof_apply ((T Type) (U Type) (V Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_apply (-> T U) V) (eo::requires T V U))
  )
)

; non-ground type defintions

; program: $eo_typeof_@@pair
(program $eo_typeof_@@pair ((U Type) (T Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_@@pair U T) (_ (@@Pair U) T))
  )
)
; program: $eo_typeof_ite
(program $eo_typeof_ite ((A Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_ite Bool A) (-> A A))
  )
)
; program: $eo_typeof_=
(program $eo_typeof_= ((A Type))
  :signature (Type) Type
  (
  (($eo_typeof_= A) (-> A Bool))
  )
)
; program: $eo_typeof_+
(program $eo_typeof_+ ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_+ T U) ($arith_typeunion T U))
  )
)
; program: $eo_typeof_-
(program $eo_typeof_- ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_- T U) ($arith_typeunion T U))
  )
)
; program: $eo_typeof_*
(program $eo_typeof_* ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_* T U) ($arith_typeunion T U))
  )
)
; program: $eo_typeof_<
(program $eo_typeof_< ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_< T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Bool)))
  )
)
; program: $eo_typeof_<=
(program $eo_typeof_<= ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_<= T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Bool)))
  )
)
; program: $eo_typeof_>
(program $eo_typeof_> ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_> T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Bool)))
  )
)
; program: $eo_typeof_>=
(program $eo_typeof_>= ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_>= T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Bool)))
  )
)
; program: $eo_typeof_to_real
(program $eo_typeof_to_real ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_to_real T) (eo::requires ($is_arith_type T) true Real))
  )
)
; program: $eo_typeof_to_int
(program $eo_typeof_to_int ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_to_int T) (eo::requires ($is_arith_type T) true Int))
  )
)
; program: $eo_typeof_is_int
(program $eo_typeof_is_int ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_is_int T) (eo::requires ($is_arith_type T) true Bool))
  )
)
; program: $eo_typeof_abs
(program $eo_typeof_abs ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_abs T) (eo::requires ($is_arith_type T) true T))
  )
)
; program: $eo_typeof_$eoo_-.2
(program $eo_typeof_$eoo_-.2 ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_$eoo_-.2 T) (eo::requires ($is_arith_type T) true T))
  )
)
; program: $eo_typeof_@bvsize
(program $eo_typeof_@bvsize ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_@bvsize (BitVec m)) Int)
  )
)
; program: $eo_typeof_concat
(program $eo_typeof_concat ((n Int) (m Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_concat (BitVec n) (BitVec m)) (BitVec (eo::add n m)))
  )
)
; program: $eo_typeof_extract
(program $eo_typeof_extract ((n Int) (h Int) (l Int))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_extract h l (BitVec n)) (BitVec (eo::requires (eo::gt (eo::add l 1) 0) true (eo::requires (eo::gt n h) true (eo::add (eo::add h (eo::neg l)) 1)))))
  )
)
; program: $eo_typeof_repeat
(program $eo_typeof_repeat ((i Int) (n Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_repeat i (BitVec n)) (BitVec (eo::mul i n)))
  )
)
; program: $eo_typeof_bvnot
(program $eo_typeof_bvnot ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvnot (BitVec m)) (BitVec m))
  )
)
; program: $eo_typeof_bvand
(program $eo_typeof_bvand ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvand (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_bvor
(program $eo_typeof_bvor ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvor (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_bvxor
(program $eo_typeof_bvxor ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvxor (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_bvneg
(program $eo_typeof_bvneg ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvneg (BitVec m)) (BitVec m))
  )
)
; program: $eo_typeof_bvadd
(program $eo_typeof_bvadd ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvadd (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_bvmul
(program $eo_typeof_bvmul ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvmul (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_bvudiv
(program $eo_typeof_bvudiv ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvudiv (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_bvurem
(program $eo_typeof_bvurem ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvurem (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_bvsub
(program $eo_typeof_bvsub ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsub (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_bvult
(program $eo_typeof_bvult ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvult (BitVec m)) (-> (BitVec m) Bool))
  )
)
; program: $eo_typeof_bvule
(program $eo_typeof_bvule ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvule (BitVec m)) (-> (BitVec m) Bool))
  )
)
; program: $eo_typeof_bvugt
(program $eo_typeof_bvugt ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvugt (BitVec m)) (-> (BitVec m) Bool))
  )
)
; program: $eo_typeof_bvuge
(program $eo_typeof_bvuge ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvuge (BitVec m)) (-> (BitVec m) Bool))
  )
)
; program: $eo_typeof_bvslt
(program $eo_typeof_bvslt ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvslt (BitVec m)) (-> (BitVec m) Bool))
  )
)
; program: $eo_typeof_bvsle
(program $eo_typeof_bvsle ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsle (BitVec m)) (-> (BitVec m) Bool))
  )
)
; program: $eo_typeof_bvsgt
(program $eo_typeof_bvsgt ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsgt (BitVec m)) (-> (BitVec m) Bool))
  )
)
; program: $eo_typeof_bvsge
(program $eo_typeof_bvsge ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsge (BitVec m)) (-> (BitVec m) Bool))
  )
)
; program: $eo_typeof_bvshl
(program $eo_typeof_bvshl ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvshl (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_bvlshr
(program $eo_typeof_bvlshr ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvlshr (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_bvashr
(program $eo_typeof_bvashr ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvashr (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_zero_extend
(program $eo_typeof_zero_extend ((m Int) (i Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_zero_extend i (BitVec m)) (BitVec (eo::add m i)))
  )
)
; program: $eo_typeof_sign_extend
(program $eo_typeof_sign_extend ((m Int) (i Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_sign_extend i (BitVec m)) (BitVec (eo::add m i)))
  )
)
; program: $eo_typeof_@bv
(program $eo_typeof_@bv ((value Int) (w Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_@bv value w) (BitVec w))
  )
)
; program: $eo_typeof_seq.empty
(program $eo_typeof_seq.empty ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_seq.empty (Seq T)) (Seq T))
  )
)
; program: $eo_typeof_str.len
(program $eo_typeof_str.len ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.len (Seq T)) Int)
  )
)
; program: $eo_typeof_str.++
(program $eo_typeof_str.++ ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.++ (Seq T)) (eo::define ((_v0 (Seq T))) (-> _v0 _v0)))
  )
)
; program: $eo_typeof_str.substr
(program $eo_typeof_str.substr ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.substr (Seq T)) (-> Int (-> Int (Seq T))))
  )
)
; program: $eo_typeof_str.contains
(program $eo_typeof_str.contains ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.contains (Seq T)) (-> (Seq T) Bool))
  )
)
; program: $eo_typeof_str.replace
(program $eo_typeof_str.replace ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.replace (Seq T)) (eo::define ((_v0 (Seq T))) (-> _v0 (-> _v0 _v0))))
  )
)
; program: $eo_typeof_str.indexof
(program $eo_typeof_str.indexof ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.indexof (Seq T)) (-> (Seq T) (-> Int Int)))
  )
)
; program: $eo_typeof_str.at
(program $eo_typeof_str.at ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.at (Seq T)) (-> Int (Seq T)))
  )
)
; program: $eo_typeof_str.prefixof
(program $eo_typeof_str.prefixof ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.prefixof (Seq T)) (-> (Seq T) Bool))
  )
)
; program: $eo_typeof_str.suffixof
(program $eo_typeof_str.suffixof ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.suffixof (Seq T)) (-> (Seq T) Bool))
  )
)
; program: $eo_typeof_str.rev
(program $eo_typeof_str.rev ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.rev (Seq T)) (Seq T))
  )
)
; program: $eo_typeof_str.update
(program $eo_typeof_str.update ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.update (Seq T)) (eo::define ((_v0 (Seq T))) (-> Int (-> _v0 _v0))))
  )
)
; program: $eo_typeof_str.replace_all
(program $eo_typeof_str.replace_all ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.replace_all (Seq T)) (eo::define ((_v0 (Seq T))) (-> _v0 (-> _v0 _v0))))
  )
)
; program: $eo_typeof_/
(program $eo_typeof_/ ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_/ T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Real)))
  )
)
; program: $eo_typeof_/_total
(program $eo_typeof_/_total ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_/_total T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Real)))
  )
)
; program: $eo_typeof_int_to_bv
(program $eo_typeof_int_to_bv ((w Int))
  :signature (Type) Type
  (
  (($eo_typeof_int_to_bv w) (-> Int (BitVec w)))
  )
)
; program: $eo_typeof_ubv_to_int
(program $eo_typeof_ubv_to_int ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_ubv_to_int (BitVec m)) Int)
  )
)
; program: $eo_typeof_sbv_to_int
(program $eo_typeof_sbv_to_int ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_sbv_to_int (BitVec m)) Int)
  )
)


; program: $eo_typeof_fun_type
; Calling ($eo_typeof_fun_type Ut Tt) returns the type of (-> U T), 
; given that U has type Ut and T has type Tt. 
(program $eo_typeof_fun_type ()
  :signature (Type Type) Type
  (
  (($eo_typeof_fun_type Type Type) Type)
  )
)

; program: $eo_typeof_main
; This defines the type rules for non-builtin terms. It is used as a subroutine
; of the final $eo_typeof routine, defined in eo_builtin_smt.eo.
(program $eo_typeof_main
  (($eo_T Type) ($eo_U Type) ($eo_V Type) ($eo_W Type) 
   ($eo_f (-> $eo_U $eo_V $eo_T)) ($eo_x $eo_U) ($eo_t $eo_T)
   ($eo_W1 Type) ($eo_x1 $eo_W1)
   ($eo_W2 Type) ($eo_x2 $eo_W2)
   ($eo_W3 Type) ($eo_x3 $eo_W3)
   ($eo_W4 Type) ($eo_x4 $eo_W4)) ; assumes functions can be monomorphized with at most 4 arguments
  :signature ($eo_T) Type
  (
  (($eo_typeof_main Type)                   Type)
  (($eo_typeof_main (-> $eo_T $eo_U))
    ; requires both children are types
    ($eo_typeof_fun_type ($eo_typeof $eo_T) ($eo_typeof $eo_U)))
  (($eo_typeof_main Bool)                   Type)
  (($eo_typeof_main true)                   Bool)
  (($eo_typeof_main false)                  Bool)
  ; TODO: auto-generate these?
  (($eo_typeof_main $eo_List)               Type)
  (($eo_typeof_main $eo_List_nil)           $eo_List)
  (($eo_typeof_main ($eo_List_cons $eo_x1)) (-> $eo_List $eo_List))
  ; type-rule: Int
  (($eo_typeof_main Int) Type)
  ; type-rule: Real
  (($eo_typeof_main Real) Type)
  ; type-rule: BitVec
  (($eo_typeof_main BitVec) (-> Int Type))
  ; type-rule: Char
  (($eo_typeof_main Char) Type)
  ; type-rule: Seq
  (($eo_typeof_main Seq) (-> Type Type))
  ; type-rule: @@Pair
  (($eo_typeof_main @@Pair) (-> Type (-> Type Type)))
  ; type-rule: @@pair
  (($eo_typeof_main (_ (@@pair $eo_x1) $eo_x2)) ($eo_typeof_@@pair ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: ite
  (($eo_typeof_main (_ (ite $eo_x1) $eo_x2)) ($eo_typeof_ite ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: not
  (($eo_typeof_main not) (-> Bool Bool))
  ; type-rule: or
  (($eo_typeof_main or) (-> Bool (-> Bool Bool)))
  ; type-rule: and
  (($eo_typeof_main and) (-> Bool (-> Bool Bool)))
  ; type-rule: =>
  (($eo_typeof_main =>) (-> Bool (-> Bool Bool)))
  ; type-rule: xor
  (($eo_typeof_main xor) (-> Bool (-> Bool Bool)))
  ; type-rule: =
  (($eo_typeof_main (= $eo_x1)) ($eo_typeof_= ($eo_typeof $eo_x1)))
  ; type-rule: +
  (($eo_typeof_main (_ (+ $eo_x1) $eo_x2)) ($eo_typeof_+ ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: -
  (($eo_typeof_main (_ (- $eo_x1) $eo_x2)) ($eo_typeof_- ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: *
  (($eo_typeof_main (_ (* $eo_x1) $eo_x2)) ($eo_typeof_* ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: <
  (($eo_typeof_main (_ (< $eo_x1) $eo_x2)) ($eo_typeof_< ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: <=
  (($eo_typeof_main (_ (<= $eo_x1) $eo_x2)) ($eo_typeof_<= ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: >
  (($eo_typeof_main (_ (> $eo_x1) $eo_x2)) ($eo_typeof_> ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: >=
  (($eo_typeof_main (_ (>= $eo_x1) $eo_x2)) ($eo_typeof_>= ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: to_real
  (($eo_typeof_main (to_real $eo_x1)) ($eo_typeof_to_real ($eo_typeof $eo_x1)))
  ; type-rule: to_int
  (($eo_typeof_main (to_int $eo_x1)) ($eo_typeof_to_int ($eo_typeof $eo_x1)))
  ; type-rule: is_int
  (($eo_typeof_main (is_int $eo_x1)) ($eo_typeof_is_int ($eo_typeof $eo_x1)))
  ; type-rule: abs
  (($eo_typeof_main (abs $eo_x1)) ($eo_typeof_abs ($eo_typeof $eo_x1)))
  ; type-rule: -
  (($eo_typeof_main ($eoo_-.2 $eo_x1)) ($eo_typeof_$eoo_-.2 ($eo_typeof $eo_x1)))
  ; type-rule: div
  (($eo_typeof_main div) (-> Int (-> Int Int)))
  ; type-rule: mod
  (($eo_typeof_main mod) (-> Int (-> Int Int)))
  ; type-rule: int.pow2
  (($eo_typeof_main int.pow2) (-> Int Int))
  ; type-rule: int.log2
  (($eo_typeof_main int.log2) (-> Int Int))
  ; type-rule: int.ispow2
  (($eo_typeof_main int.ispow2) (-> Int Bool))
  ; type-rule: div_total
  (($eo_typeof_main div_total) (-> Int (-> Int Int)))
  ; type-rule: mod_total
  (($eo_typeof_main mod_total) (-> Int (-> Int Int)))
  ; type-rule: @bvsize
  (($eo_typeof_main (@bvsize $eo_x1)) ($eo_typeof_@bvsize ($eo_typeof $eo_x1)))
  ; type-rule: concat
  (($eo_typeof_main (_ (concat $eo_x1) $eo_x2)) ($eo_typeof_concat ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: extract
  (($eo_typeof_main (_ (_ (extract $eo_x1) $eo_x2) $eo_x3)) ($eo_typeof_extract $eo_x1 $eo_x2 ($eo_typeof $eo_x3)))
  ; type-rule: repeat
  (($eo_typeof_main (_ (repeat $eo_x1) $eo_x2)) ($eo_typeof_repeat $eo_x1 ($eo_typeof $eo_x2)))
  ; type-rule: bvnot
  (($eo_typeof_main (bvnot $eo_x1)) ($eo_typeof_bvnot ($eo_typeof $eo_x1)))
  ; type-rule: bvand
  (($eo_typeof_main (bvand $eo_x1)) ($eo_typeof_bvand ($eo_typeof $eo_x1)))
  ; type-rule: bvor
  (($eo_typeof_main (bvor $eo_x1)) ($eo_typeof_bvor ($eo_typeof $eo_x1)))
  ; type-rule: bvxor
  (($eo_typeof_main (bvxor $eo_x1)) ($eo_typeof_bvxor ($eo_typeof $eo_x1)))
  ; type-rule: bvneg
  (($eo_typeof_main (bvneg $eo_x1)) ($eo_typeof_bvneg ($eo_typeof $eo_x1)))
  ; type-rule: bvadd
  (($eo_typeof_main (bvadd $eo_x1)) ($eo_typeof_bvadd ($eo_typeof $eo_x1)))
  ; type-rule: bvmul
  (($eo_typeof_main (bvmul $eo_x1)) ($eo_typeof_bvmul ($eo_typeof $eo_x1)))
  ; type-rule: bvudiv
  (($eo_typeof_main (bvudiv $eo_x1)) ($eo_typeof_bvudiv ($eo_typeof $eo_x1)))
  ; type-rule: bvurem
  (($eo_typeof_main (bvurem $eo_x1)) ($eo_typeof_bvurem ($eo_typeof $eo_x1)))
  ; type-rule: bvsub
  (($eo_typeof_main (bvsub $eo_x1)) ($eo_typeof_bvsub ($eo_typeof $eo_x1)))
  ; type-rule: bvult
  (($eo_typeof_main (bvult $eo_x1)) ($eo_typeof_bvult ($eo_typeof $eo_x1)))
  ; type-rule: bvule
  (($eo_typeof_main (bvule $eo_x1)) ($eo_typeof_bvule ($eo_typeof $eo_x1)))
  ; type-rule: bvugt
  (($eo_typeof_main (bvugt $eo_x1)) ($eo_typeof_bvugt ($eo_typeof $eo_x1)))
  ; type-rule: bvuge
  (($eo_typeof_main (bvuge $eo_x1)) ($eo_typeof_bvuge ($eo_typeof $eo_x1)))
  ; type-rule: bvslt
  (($eo_typeof_main (bvslt $eo_x1)) ($eo_typeof_bvslt ($eo_typeof $eo_x1)))
  ; type-rule: bvsle
  (($eo_typeof_main (bvsle $eo_x1)) ($eo_typeof_bvsle ($eo_typeof $eo_x1)))
  ; type-rule: bvsgt
  (($eo_typeof_main (bvsgt $eo_x1)) ($eo_typeof_bvsgt ($eo_typeof $eo_x1)))
  ; type-rule: bvsge
  (($eo_typeof_main (bvsge $eo_x1)) ($eo_typeof_bvsge ($eo_typeof $eo_x1)))
  ; type-rule: bvshl
  (($eo_typeof_main (bvshl $eo_x1)) ($eo_typeof_bvshl ($eo_typeof $eo_x1)))
  ; type-rule: bvlshr
  (($eo_typeof_main (bvlshr $eo_x1)) ($eo_typeof_bvlshr ($eo_typeof $eo_x1)))
  ; type-rule: bvashr
  (($eo_typeof_main (bvashr $eo_x1)) ($eo_typeof_bvashr ($eo_typeof $eo_x1)))
  ; type-rule: zero_extend
  (($eo_typeof_main (_ (zero_extend $eo_x1) $eo_x2)) ($eo_typeof_zero_extend $eo_x1 ($eo_typeof $eo_x2)))
  ; type-rule: sign_extend
  (($eo_typeof_main (_ (sign_extend $eo_x1) $eo_x2)) ($eo_typeof_sign_extend $eo_x1 ($eo_typeof $eo_x2)))
  ; type-rule: @bv
  (($eo_typeof_main (_ (@bv $eo_x1) $eo_x2)) ($eo_typeof_@bv $eo_x1 $eo_x2))
  ; type-rule: seq.empty
  (($eo_typeof_main (as seq.empty $eo_x1)) ($eo_typeof_seq.empty $eo_x1))
  ; type-rule: str.len
  (($eo_typeof_main (str.len $eo_x1)) ($eo_typeof_str.len ($eo_typeof $eo_x1)))
  ; type-rule: str.++
  (($eo_typeof_main (str.++ $eo_x1)) ($eo_typeof_str.++ ($eo_typeof $eo_x1)))
  ; type-rule: str.substr
  (($eo_typeof_main (str.substr $eo_x1)) ($eo_typeof_str.substr ($eo_typeof $eo_x1)))
  ; type-rule: str.contains
  (($eo_typeof_main (str.contains $eo_x1)) ($eo_typeof_str.contains ($eo_typeof $eo_x1)))
  ; type-rule: str.replace
  (($eo_typeof_main (str.replace $eo_x1)) ($eo_typeof_str.replace ($eo_typeof $eo_x1)))
  ; type-rule: str.indexof
  (($eo_typeof_main (str.indexof $eo_x1)) ($eo_typeof_str.indexof ($eo_typeof $eo_x1)))
  ; type-rule: str.at
  (($eo_typeof_main (str.at $eo_x1)) ($eo_typeof_str.at ($eo_typeof $eo_x1)))
  ; type-rule: str.prefixof
  (($eo_typeof_main (str.prefixof $eo_x1)) ($eo_typeof_str.prefixof ($eo_typeof $eo_x1)))
  ; type-rule: str.suffixof
  (($eo_typeof_main (str.suffixof $eo_x1)) ($eo_typeof_str.suffixof ($eo_typeof $eo_x1)))
  ; type-rule: str.rev
  (($eo_typeof_main (str.rev $eo_x1)) ($eo_typeof_str.rev ($eo_typeof $eo_x1)))
  ; type-rule: str.update
  (($eo_typeof_main (str.update $eo_x1)) ($eo_typeof_str.update ($eo_typeof $eo_x1)))
  ; type-rule: str.to_lower
  (($eo_typeof_main str.to_lower) (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
  ; type-rule: str.to_upper
  (($eo_typeof_main str.to_upper) (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
  ; type-rule: str.to_code
  (($eo_typeof_main str.to_code) (-> (Seq Char) Int))
  ; type-rule: str.from_code
  (($eo_typeof_main str.from_code) (-> Int (Seq Char)))
  ; type-rule: str.to_int
  (($eo_typeof_main str.to_int) (-> (Seq Char) Int))
  ; type-rule: str.from_int
  (($eo_typeof_main str.from_int) (-> Int (Seq Char)))
  ; type-rule: str.<=
  (($eo_typeof_main str.<=) (eo::define ((_v0 (Seq Char))) (-> _v0 (-> _v0 Bool))))
  ; type-rule: str.replace_all
  (($eo_typeof_main (str.replace_all $eo_x1)) ($eo_typeof_str.replace_all ($eo_typeof $eo_x1)))
  ; type-rule: /
  (($eo_typeof_main (_ (/ $eo_x1) $eo_x2)) ($eo_typeof_/ ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: /_total
  (($eo_typeof_main (_ (/_total $eo_x1) $eo_x2)) ($eo_typeof_/_total ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  ; type-rule: int_to_bv
  (($eo_typeof_main (int_to_bv $eo_x1)) ($eo_typeof_int_to_bv $eo_x1))
  ; type-rule: ubv_to_int
  (($eo_typeof_main (ubv_to_int $eo_x1)) ($eo_typeof_ubv_to_int ($eo_typeof $eo_x1)))
  ; type-rule: sbv_to_int
  (($eo_typeof_main (sbv_to_int $eo_x1)) ($eo_typeof_sbv_to_int ($eo_typeof $eo_x1)))

  (($eo_typeof_main ($eo_f $eo_x))          ($eo_typeof_apply ($eo_typeof $eo_f) ($eo_typeof $eo_x)))
  )
)

(program $eo_lit_type_Numeral ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_Numeral t) Int)
  )
)
(program $eo_lit_type_Rational ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_Rational t) Real)
  )
)
(program $eo_lit_type_Binary ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_Binary t) (BitVec (eo::len t)))
  )
)
(program $eo_lit_type_String ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_String t) (Seq Char))
  )
)


;;; datatype constructors

; TODO: meta semantics for arbitrary unknown datatypes?

; program: $eo_dt_constructors
; implements: eo::dt_constructors
(program $eo_dt_constructors
  ((T Type))
  :signature (Type) $eo_List
  (

  )
)

; program: $eo_dt_selectors
; implements: eo::dt_selectors
(program $eo_dt_selectors ((T Type) (t T))
  :signature (T) $eo_List
  (

  )
)

;;; eo::nil definitions

; program: $eo_nil_bvand
(program $eo_nil_bvand (($eoT_3 Type) (m Int))
  :signature ((eo::quote $eoT_3)) $eoT_3
  (
  (($eo_nil_bvand (BitVec m)) (eo::not (eo::to_bin m 0)))
  )
)
; program: $eo_nil_bvor
(program $eo_nil_bvor (($eoT_4 Type) (m Int))
  :signature ((eo::quote $eoT_4)) $eoT_4
  (
  (($eo_nil_bvor (BitVec m)) (eo::to_bin m 0))
  )
)
; program: $eo_nil_bvxor
(program $eo_nil_bvxor (($eoT_5 Type) (m Int))
  :signature ((eo::quote $eoT_5)) $eoT_5
  (
  (($eo_nil_bvxor (BitVec m)) (eo::to_bin m 0))
  )
)
; program: $eo_nil_bvadd
(program $eo_nil_bvadd (($eoT_6 Type) (m Int))
  :signature ((eo::quote $eoT_6)) $eoT_6
  (
  (($eo_nil_bvadd (BitVec m)) (eo::to_bin m 0))
  )
)
; program: $eo_nil_bvmul
(program $eo_nil_bvmul (($eoT_7 Type) (m Int))
  :signature ((eo::quote $eoT_7)) $eoT_7
  (
  (($eo_nil_bvmul (BitVec m)) (eo::to_bin m 1))
  )
)
; program: $eo_nil_str.++
(program $eo_nil_str.++ (($eoT_8 Type) (T Type))
  :signature ((eo::quote $eoT_8)) $eoT_8
  (
  (($eo_nil_str.++ (Seq T)) ($seq_empty (Seq T)))
  )
)


; program: $eo_nil
; implements: eo::nil
(program $eo_nil
  ((T Type) (U Type) (V Type) (W Type) (f (-> T U V)))
  :signature ((-> T U V) (eo::quote W)) W
  (
  (($eo_nil or T) false)
  (($eo_nil and T) true)
  (($eo_nil + T) 0)
  (($eo_nil * T) 1)
  (($eo_nil concat T) (eo::to_bin 0 0))
  (($eo_nil bvand T) ($eo_nil_bvand T))
  (($eo_nil bvor T) ($eo_nil_bvor T))
  (($eo_nil bvxor T) ($eo_nil_bvxor T))
  (($eo_nil bvadd T) ($eo_nil_bvadd T))
  (($eo_nil bvmul T) ($eo_nil_bvmul T))
  (($eo_nil str.++ T) ($eo_nil_str.++ T))

  ; builtin case of $eo_List
  (($eo_nil $eo_List_cons $eo_List) $eo_List_nil)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_smt

; The following functions may be used to define the verification condition we
; will write below.

; A placeholder for asking whether a formula evaluates to true in a model.
(program $eo_model_sat () :signature (Bool) Bool)
; A placeholder for asking whether a formula evaluates to false in a model.
(program $eo_model_unsat () :signature (Bool) Bool)

; We will include the definition of the above functions here.
(echo "include eo_model_sat :deps $eo_typeof_main $eo_is_ok $eo_dt_constructors $eo_dt_selectors $eo_List_nil $eo_List_cons $eo_lit_type_Numeral $eo_lit_type_Rational $eo_lit_type_String $eo_lit_type_Binary ")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; vc

;; verification conditions

; program: $eovc_evaluate
(program $eovc_evaluate ((U Type) (t U))
  :signature (U) Bool
  (
  (($eovc_evaluate t) (eo::define ((_v0 ($eo_prog_evaluate t))) (eo::requires ($eo_typeof _v0) Bool (eo::requires ($eo_model_unsat _v0) true true))))
  )
)
(echo "smt-meta $eovc_evaluate :deps $eo_proven $smtx_hash $eo_reverse_hash $smtx_value_hash $smtx_reverse_value_hash $eo_Bool $eo_Type $eo_fun_type $eo_apply $eo_mk_apply ")


