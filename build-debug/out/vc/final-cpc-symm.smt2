(set-logic UFDTSNIRA)

; A Eunoia internal term
(declare-datatype eo.Term
  (
  ; Application of a Eunoia term
  (eo.Apply (eo.Apply.arg1 eo.Term) (eo.Apply.arg2 eo.Term))
  ; A term used to define the semantics of SMT-LIB.
  ;(eo.SmtTerm (eo.SmtTerm.val sm.Term))
  ; Represents "stuckness"
  (eo.Stuck)
  ; generated by signature
  ; declare $eo_List
  (eo.$eo_List)
  ; declare $eo_List_nil
  (eo.$eo_List_nil)
  ; declare $eo_List_cons
  (eo.$eo_List_cons)
  ; declare @Map
  (eo.@Map)
  ; declare @smt_RatPair
  (eo.@smt_RatPair)
  ; declare @Map_nil
  (eo.@Map_nil)
  ; declare @smt_ratPair
  (eo.@smt_ratPair)

  ; none
  (eo.None)
  )
)

;(declare-datatype sm.Type
;  (
;  )
;)
(declare-datatype sm.Term
  (
  ; Core
  (sm.Type)
  (sm.FunType (sm.FunType.arg1 sm.Term) (sm.FunType.arg2 sm.Term))
  (sm.Apply (sm.Apply.arg1 sm.Term) (sm.Apply.arg2 sm.Term))
  ; Booleans
  (sm.BoolType)
  (sm.True)
  (sm.False)
  ; builtin literal types
  (sm.Numeral (sm.Numeral.val Int))
  (sm.Rational (sm.Rational.val Real))
  (sm.String (sm.String.val String))
  (sm.Binary (sm.Binary.width Int) (sm.Binary.val Int))

  ; Eunoia terms (these are not legal SMT-LIB terms).
  ; A term used to define the semantics of SMT-LIB.
  ; FIXME: invert this
  (sm.EoTerm (eo.EoTerm.val eo.Term))
  ; Represents "stuckness"
  (sm.Stuck)
  ; generated by signature
  ; declare $eo_undef_type
  (sm.$eo_undef_type)
  ; declare Int
  (sm.Int)
  ; declare Real
  (sm.Real)
  ; declare Char
  (sm.Char)
  ; declare Seq
  (sm.Seq)
  ; declare $smt_unknown_type
  (sm.$smt_unknown_type)
  ; declare $smt_BitVec
  (sm.$smt_BitVec (sm.$smt_BitVec.arg1 sm.Term))
  ; declare $smt_fail
  (sm.$smt_fail)
  ; declare not
  (sm.not)
  ; declare and
  (sm.and)
  ; declare $eo_Var
  (sm.$eo_Var)
  ; declare =
  (sm.=)
  ; declare BitVec
  (sm.BitVec)
  ; declare $smt_unknown_type_enum
  (sm.$smt_unknown_type_enum (sm.$smt_unknown_type_enum.arg1 sm.Term) (sm.$smt_unknown_type_enum.arg2 sm.Term))
  ; declare $smt_Const
  (sm.$smt_Const (sm.$smt_Const.arg1 sm.Term) (sm.$smt_Const.arg2 sm.Term) (sm.$smt_Const.arg3 sm.Term))

  )
)

;;; Literal conversions

; smt-define: $smt_to_eo_bool
(define-fun $smt_to_eo_bool ((x Bool)) sm.Term
  (ite x sm.True sm.False))
  
; smt-define: $smt_from_eo_bool
(define-fun $smt_from_eo_bool ((x sm.Term)) Bool
  (= x sm.True))

; smt-define: $sm_is_Boolean
(define-fun $sm_is_Boolean ((x sm.Term)) Bool
  (or (= x sm.True) (= x sm.False)))
  
; smt-define: $smt_to_eo_z
(define-fun $smt_to_eo_z ((x Int)) sm.Term
  (sm.Numeral x))
  
; smt-define: $smt_from_eo_z
(define-fun $smt_from_eo_z ((x sm.Term)) Int
  (sm.Numeral.val x))

; smt-define: $smt_to_eo_q
(define-fun $smt_to_eo_q ((x Real)) sm.Term
  (sm.Rational x))
  
; smt-define: $smt_from_eo_q
(define-fun $smt_from_eo_q ((x sm.Term)) Real
  (sm.Rational.val x))

; smt-define: $smt_to_eo_str
(define-fun $smt_to_eo_str ((x String)) sm.Term
  (sm.String x))
  
; smt-define: $smt_from_eo_str
(define-fun $smt_from_eo_str ((x sm.Term)) String
  (sm.String.val x))

;;; Utilities

; Stuckness propagates through non-nullary constructors
(define-fun $sm_FunType ((x sm.Term) (y sm.Term)) sm.Term
  (ite (or (= x sm.Stuck) (= y sm.Stuck))
    sm.Stuck
    (sm.FunType x y)))

(define-fun $sm_Apply ((x sm.Term) (y sm.Term)) sm.Term
  (ite (or (= x sm.Stuck) (= y sm.Stuck))
    sm.Stuck
    (sm.Apply x y)))


;;; Definitions of forward declared programs in SMT preamble

; note: should never be called on negative numbers
(declare-fun $sm_pow2_eval (Int) Int)
(assert (! (forall ((i Int))
  (= ($sm_pow2_eval i) (ite (<= i 0) 1 (* 2 ($sm_pow2_eval (- i 1)))))) :named sm.eval_pow2))

; program: $sm_Binary
; Forward declaration in model_smt_preamble.eo
(define-fun $sm_Binary ((w Int) (x Int)) sm.Term
  (ite (and (<= 0 w) (< w 4294967296))
    (sm.Binary w (mod x ($sm_pow2_eval w)))
    sm.Stuck))

(define-fun $sm_bit ((x Int) (i Int)) Bool
  (= (mod (div x ($sm_pow2_eval i)) 2) 1))

(declare-fun $sm_Binary_and (Int Int Int) Int)
(assert (! (forall ((w Int) (x1 Int) (x2 Int))
  (= ($sm_Binary_and w x1 x2)
    (ite (= w 0) 0
    (ite (= w 1) (ite (and (= x1 1) (= x2 1)) 1 0)
      (+ ($sm_Binary_and (- w 1) x1 x2) (* ($sm_pow2_eval w)
         (ite (and ($sm_bit x1 w) ($sm_bit x2 w)) 1 0))))))) :named sm.eval_bin_and))

; ((w Int) (x1 Int) (x2 Int))
(declare-fun $sm_Binary_or (Int Int Int) Int) ; TODO

; ((w Int) (x1 Int) (x2 Int))
(declare-fun $sm_Binary_xor (Int Int Int) Int) ; TODO

; ((w Int) (x1 Int))
(declare-fun $sm_Binary_not (Int Int) Int) ; TODO

;;; Core operators

; axiom: $eo_is_ok
(define-fun $eo_is_ok ((x1 sm.Term)) sm.Term
  ($smt_to_eo_bool (not (= x1 sm.Stuck))))

; axiom: $eo_ite
(define-fun $eo_ite ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term)) sm.Term
  (ite (= x1 sm.True)
    x2
  (ite (= x1 sm.False)
    x3
    sm.Stuck)))

; axiom: $eo_requires
(define-fun $eo_requires ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term)) sm.Term
  (ite (and (not (= x1 sm.Stuck)) (not (= x2 sm.Stuck)) (= x1 x2))
    x3
    sm.Stuck))

; axiom: $eo_hash
; note: This is defined axiomatically.
(declare-fun $eo_hash (sm.Term) sm.Term)
(assert (! (forall ((x sm.Term))
  (=> (not (= x sm.Stuck))
    ((_ is sm.Numeral) ($eo_hash x)))) :named sm.hash_numeral))
(assert (! (forall ((x sm.Term) (y sm.Term))
  (=> (and (not (= x sm.Stuck)) (not (= y sm.Stuck))
    (= ($eo_hash x) ($eo_hash y))) (= x y))) :named sm.hash_inj))

;;; User defined symbols

; fwd-decl: $eo_typeof
(declare-fun $eo_typeof (sm.Term) sm.Term)

; fwd-decl: $eo_model_sat
(declare-fun $eo_model_sat (sm.Term) sm.Term)

; fwd-decl: $sm_Binary
(declare-fun $sm_Binary (sm.Term sm.Term) sm.Term)

; fwd-decl: $sm_Binary_and
(declare-fun $sm_Binary_and (sm.Term sm.Term sm.Term) sm.Term)

; fwd-decl: $sm_Binary_concat
(declare-fun $sm_Binary_concat (sm.Term sm.Term sm.Term sm.Term) sm.Term)

; define $eo_and
(define-fun $eo_and ((x1 sm.Term) (x2 sm.Term)) sm.Term ($eo_ite (and ($sm_is_Boolean x1) ($sm_is_Boolean x2)) ($smt_to_eo_bool (and ($smt_from_eo_bool x1) ($smt_from_eo_bool x2))) ($eo_ite ($smt_to_eo_bool (and ((_ is sm.Binary)x1) ((_ is sm.Binary)x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))) ($sm_Binary ($sm_Binary_and (sm.Binary.width x1) (sm.Binary.val x1) (sm.Binary.val x2)) (sm.Binary.width x1)) sm.$smt_fail)))

; define $eo_add
(define-fun $eo_add ((x1 sm.Term) (x2 sm.Term)) sm.Term ($eo_ite (and ($smt_to_eo_bool ((_ is sm.Numeral)x1)) ($smt_to_eo_bool ((_ is sm.Numeral)x2))) ($smt_to_eo_z (+ ($smt_from_eo_z x1) ($smt_from_eo_z x2))) ($eo_ite (and ($smt_to_eo_bool ((_ is sm.Rational)x1)) ($smt_to_eo_bool ((_ is sm.Rational)x2))) ($smt_to_eo_q (+ ($smt_from_eo_q x1) ($smt_from_eo_q x2))) ($eo_ite ($smt_to_eo_bool (and ((_ is sm.Binary)x1) ((_ is sm.Binary)x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))) ($sm_Binary (+ (sm.Binary.val x1) (sm.Binary.val x2)) (sm.Binary.width x1)) ($eo_requires sm.True sm.False sm.True)))))

; define $eo_qdiv
(define-fun $eo_qdiv ((x1 sm.Term) (x2 sm.Term)) sm.Term ($eo_ite ($smt_to_eo_bool (and ((_ is sm.Numeral)x1) ((_ is sm.Numeral)x2) (not (= ($smt_from_eo_z x2) (sm.Numeral 0))))) ($smt_to_eo_q (/ (to_real ($smt_from_eo_z x1)) (to_real ($smt_from_eo_z x2)))) ($eo_ite ($smt_to_eo_bool (and ((_ is sm.Rational)x1) ((_ is sm.Rational)x2) (not (= ($smt_from_eo_q x2) (sm.Rational 0/1))))) ($smt_to_eo_q (/ ($smt_from_eo_q x1) ($smt_from_eo_q x2))) ($eo_requires sm.True sm.False sm.True))))

; define $eo_zdiv
(define-fun $eo_zdiv ((x1 sm.Term) (x2 sm.Term)) sm.Term ($eo_ite ($smt_to_eo_bool (and ((_ is sm.Numeral)x1) ((_ is sm.Numeral)x2) (not (= ($smt_from_eo_z x2) (sm.Numeral 0))))) ($smt_to_eo_z (div ($smt_from_eo_z x1) ($smt_from_eo_z x2))) ($eo_ite ($smt_to_eo_bool (and ((_ is sm.Binary)x1) ((_ is sm.Binary)x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))) ($sm_Binary (div (sm.Binary.val x1) (sm.Binary.val x2)) (sm.Binary.width x1)) ($eo_requires sm.True sm.False sm.True))))

; define $eo_zmod
(define-fun $eo_zmod ((x1 sm.Term) (x2 sm.Term)) sm.Term ($eo_ite ($smt_to_eo_bool (and ((_ is sm.Numeral)x1) ((_ is sm.Numeral)x2) (not (= ($smt_from_eo_z x2) (sm.Numeral 0))))) ($smt_to_eo_z (mod ($smt_from_eo_z x1) ($smt_from_eo_z x2))) ($eo_ite ($smt_to_eo_bool (and ((_ is sm.Binary)x1) ((_ is sm.Binary)x2) (= (sm.Binary.width x1) (sm.Binary.width x2)))) ($sm_Binary (mod (sm.Binary.val x1) (sm.Binary.val x2)) (sm.Binary.width x1)) ($eo_requires sm.True sm.False sm.True))))

; define $eo_neg
(define-fun $eo_neg ((x1 sm.Term)) sm.Term ($eo_ite ($smt_to_eo_bool ((_ is sm.Numeral)x1)) ($smt_to_eo_z (- ($smt_from_eo_z x1))) ($eo_ite ($smt_to_eo_bool ((_ is sm.Rational)x1)) ($smt_to_eo_q (- ($smt_from_eo_q x1))) ($eo_requires sm.True sm.False sm.True))))

; define $eo_len
(define-fun $eo_len ((x1 sm.Term)) sm.Term ($eo_ite ((_ is sm.Binary)x1) ($smt_to_eo_z (sm.Binary.width x1)) ($eo_ite ((_ is sm.String)x1) ($smt_to_eo_z (str.len ($smt_from_eo_str x1))) ($eo_requires sm.True sm.False sm.True))))

; define $eo_concat
(define-fun $eo_concat ((x1 sm.Term) (x2 sm.Term)) sm.Term ($eo_ite (and ((_ is sm.String)x1) ((_ is sm.String)x2)) ($smt_to_eo_str (str.++ ($smt_from_eo_str x1) ($smt_from_eo_str x2))) ($eo_ite (and ((_ is sm.Binary)x1) ((_ is sm.Binary)x2)) ($sm_Binary_concat (sm.Binary.width x1) (sm.Binary.val x1) (sm.Binary.width x2) (sm.Binary.val x2)) ($eo_requires sm.True sm.False sm.True))))

; define $eo_to_z
(define-fun $eo_to_z ((x1 sm.Term)) sm.Term ($eo_ite ((_ is sm.Numeral)x1) x1 ($eo_ite ((_ is sm.Rational)x1) ($smt_to_eo_z (to_int ($smt_from_eo_q x1))) ($eo_ite ((_ is sm.Binary)x1) ($smt_to_eo_z (sm.Binary.val x1)) ($eo_ite (and ((_ is sm.String)x1) (= (str.len ($smt_from_eo_str x1)) (sm.Numeral 1))) ($smt_to_eo_z (str.to_code ($smt_from_eo_str x1))) ($eo_requires sm.True sm.False sm.True))))))

; define $eo_to_q
(define-fun $eo_to_q ((x1 sm.Term)) sm.Term ($eo_ite ((_ is sm.Numeral)x1) ($smt_to_eo_q (to_real ($smt_from_eo_z x1))) ($eo_ite ((_ is sm.Rational)x1) x1 ($eo_requires sm.True sm.False sm.True))))

; define $eo_to_bin
(define-fun $eo_to_bin ((x1 sm.Term) (x2 sm.Term)) sm.Term ($eo_ite (and ((_ is sm.Numeral)x1) ((_ is sm.Numeral)x2)) ($sm_Binary ($smt_from_eo_z x1) ($smt_from_eo_z x2)) ($eo_ite (and ((_ is sm.Numeral)x1) ((_ is sm.Numeral)x2)) ($sm_Binary ($smt_from_eo_z x1) (sm.Binary.val x2)) ($eo_requires sm.True sm.False sm.True))))

; define $eo_to_str
(define-fun $eo_to_str ((x1 sm.Term)) sm.Term ($eo_ite ((_ is sm.Numeral)x1) ($smt_to_eo_str (str.from_code ($smt_from_eo_z x1))) ($eo_ite ((_ is sm.String)x1) x1 ($eo_requires sm.True sm.False sm.True))))

; fwd-decl: $eo_dt_constructors
(declare-fun $eo_dt_constructors (sm.Term) sm.Term)

; fwd-decl: $eo_dt_selectors
(declare-fun $eo_dt_selectors (sm.Term) sm.Term)

; program: $eo_eq
(define-fun $eo_eq ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    sm.Stuck
  (ite (= x2 x1)
    sm.True
  (ite true
    sm.False
    sm.Stuck)))
)

; define $eo_is_eq
(define-fun $eo_is_eq ((t sm.Term) (s sm.Term)) sm.Term ($eo_ite ($eo_and ($eo_is_ok t) ($eo_is_ok s)) ($eo_eq s t) sm.False))

; define $eo_is_z
(define-fun $eo_is_z ((x sm.Term)) sm.Term ($eo_ite ($eo_and ($eo_is_ok ($eo_to_z x)) ($eo_is_ok x)) ($eo_eq x ($eo_to_z x)) sm.False))

; define $eo_is_q
(define-fun $eo_is_q ((x sm.Term)) sm.Term ($eo_ite ($eo_and ($eo_is_ok ($eo_to_q x)) ($eo_is_ok x)) ($eo_eq x ($eo_to_q x)) sm.False))

; define $eo_is_bin
(define-fun $eo_is_bin ((x sm.Term)) sm.Term ($eo_ite ($eo_and ($eo_is_ok ($eo_to_bin ($eo_len x) x)) ($eo_is_ok x)) ($eo_eq x ($eo_to_bin ($eo_len x) x)) sm.False))

; define $eo_is_str
(define-fun $eo_is_str ((x sm.Term)) sm.Term ($eo_ite ($eo_and ($eo_is_ok ($eo_to_str x)) ($eo_is_ok x)) ($eo_eq x ($eo_to_str x)) sm.False))

; define $eo_is_bool
(define-fun $eo_is_bool ((x sm.Term)) sm.Term ($eo_ite ($eo_ite ($eo_and ($eo_is_ok x) sm.True) ($eo_eq sm.True x) sm.False) sm.True ($eo_ite ($eo_and ($eo_is_ok x) sm.True) ($eo_eq sm.False x) sm.False)))

; program: $mk_symm
(define-fun $mk_symm ((x1 sm.Term)) sm.Term
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite (and ((_ is sm.Apply) x1) ((_ is sm.Apply) (sm.Apply.arg1 x1)) (= (sm.Apply.arg1 (sm.Apply.arg1 x1)) sm.=))
    ($sm_Apply ($sm_Apply sm.= (sm.Apply.arg2 x1)) (sm.Apply.arg2 (sm.Apply.arg1 x1)))
  (ite (and ((_ is sm.Apply) x1) ((_ is sm.Apply) (sm.Apply.arg2 x1)) ((_ is sm.Apply) (sm.Apply.arg1 (sm.Apply.arg2 x1))) (= (sm.Apply.arg1 (sm.Apply.arg1 (sm.Apply.arg2 x1))) sm.=) (= (sm.Apply.arg1 x1) sm.not))
    ($sm_Apply sm.not ($sm_Apply ($sm_Apply sm.= (sm.Apply.arg2 (sm.Apply.arg2 x1))) (sm.Apply.arg2 (sm.Apply.arg1 (sm.Apply.arg2 x1)))))
    sm.Stuck)))
)

; program: $eo_typeof_apply
(define-fun $eo_typeof_apply ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    sm.Stuck
  (ite (and ((_ is sm.FunType) x1) (= x2 (sm.FunType.arg1 x1)))
    (sm.FunType.arg2 x1)
    sm.Stuck))
)

; program: $eo_typeof_=
(define-fun $eo_typeof_= ((x1 sm.Term)) sm.Term
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite true
    ($sm_FunType x1 sm.BoolType)
    sm.Stuck))
)

; program: $eo_typeof_main
(define-fun $eo_typeof_main ((x1 sm.Term)) sm.Term
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite (= x1 sm.Type)
    sm.Type
  (ite ((_ is sm.FunType) x1)
    ($eo_requires ($eo_typeof (sm.FunType.arg1 x1)) sm.Type ($eo_requires ($eo_typeof (sm.FunType.arg2 x1)) sm.Type sm.Type))
  (ite (= x1 sm.BoolType)
    sm.Type
  (ite (= x1 sm.True)
    sm.BoolType
  (ite (= x1 sm.False)
    sm.BoolType
  (ite (= x1 sm.Int)
    sm.Type
  (ite (= x1 sm.Real)
    sm.Type
  (ite (= x1 sm.Char)
    sm.Type
  (ite (= x1 sm.Seq)
    ($sm_FunType sm.Type sm.Type)
  (ite (= x1 sm.not)
    ($sm_FunType sm.BoolType sm.BoolType)
  (ite (= x1 sm.and)
    ($sm_FunType sm.BoolType ($sm_FunType sm.BoolType sm.BoolType))
  (ite (and ((_ is sm.Apply) x1) (= (sm.Apply.arg1 x1) sm.=))
    ($eo_typeof_= ($eo_typeof (sm.Apply.arg2 x1)))
  (ite (= x1 sm.BitVec)
    ($sm_FunType sm.Int sm.Type)
  (ite ((_ is sm.Apply) x1)
    ($eo_typeof_apply ($eo_typeof (sm.Apply.arg1 x1)) ($eo_typeof (sm.Apply.arg2 x1)))
    sm.Stuck)))))))))))))))
)

; program: $eo_dt_constructors
(assert (! (forall ((x1 sm.Term))
  (= ($eo_dt_constructors x1)
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite true
    ($eo_requires sm.True sm.False sm.True)
    sm.Stuck))))
 :named sm.axiom.$eo_dt_constructors))

; program: $eo_dt_selectors
(assert (! (forall ((x1 sm.Term))
  (= ($eo_dt_selectors x1)
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite true
    ($eo_requires sm.True sm.False sm.True)
    sm.Stuck))))
 :named sm.axiom.$eo_dt_selectors))

; program: $eo_typeof
(assert (! (forall ((x1 sm.Term))
  (= ($eo_typeof x1)
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite (and ((_ is sm.Apply) x1) ((_ is sm.Apply) (sm.Apply.arg1 x1)) (= (sm.Apply.arg1 (sm.Apply.arg1 x1)) sm.$eo_Var))
    (sm.Apply.arg2 x1)
  (ite true
    ($eo_ite ($eo_ite ($eo_ite ($eo_and ($eo_is_ok x1) sm.True) ($eo_eq sm.True x1) sm.False) sm.True ($eo_ite ($eo_and ($eo_is_ok x1) sm.True) ($eo_eq sm.False x1) sm.False)) sm.BoolType ($eo_ite ($eo_ite ($eo_and ($eo_is_ok ($eo_to_z x1)) ($eo_is_ok x1)) ($eo_eq x1 ($eo_to_z x1)) sm.False) sm.Int ($eo_ite ($eo_ite ($eo_and ($eo_is_ok ($eo_to_q x1)) ($eo_is_ok x1)) ($eo_eq x1 ($eo_to_q x1)) sm.False) sm.Real ($eo_ite ($eo_ite ($eo_and ($eo_is_ok ($eo_to_str x1)) ($eo_is_ok x1)) ($eo_eq x1 ($eo_to_str x1)) sm.False) ($sm_Apply sm.Seq sm.Char) ($eo_ite ($eo_ite ($eo_and ($eo_is_ok ($eo_to_bin ($eo_len x1) x1)) ($eo_is_ok x1)) ($eo_eq x1 ($eo_to_bin ($eo_len x1) x1)) sm.False) sm.$eo_undef_type ($eo_typeof_main x1))))))
    sm.Stuck)))))
 :named sm.axiom.$eo_typeof))

; program: $eorx_symm
(define-fun $eorx_symm ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    sm.Stuck
  (ite (= x2 sm.BoolType)
    ($mk_symm x1)
    sm.Stuck))
)

; program: $eor_symm
(define-fun $eor_symm ((x1 sm.Term)) sm.Term
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite true
    ($eorx_symm x1 ($eo_typeof x1))
    sm.Stuck))
)

; program: $eovc_symm
(define-fun $eovc_symm ((x1 sm.Term)) sm.Term
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite true
    ($eo_requires ($eo_model_sat x1) sm.True ($eo_requires ($eo_model_sat ($eor_symm x1)) sm.False sm.True))
    sm.Stuck))
)

; program: $eo_type_enum
(define-fun $eo_type_enum ((x1 sm.Term) (x2 sm.Term)) sm.Term
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    sm.Stuck
  (ite true
    ($eo_requires sm.True sm.False sm.True)
    sm.Stuck))
)

; program: $eo_const_predicate
(define-fun $eo_const_predicate ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term)) sm.Term
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck) (= x3 sm.Stuck))
    sm.Stuck
  (ite true
    ($eo_requires sm.True sm.False sm.True)
    sm.Stuck))
)

; program: $eo_model_eval
(define-fun $eo_model_eval ((x1 sm.Term)) sm.Term
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite true
    ($eo_requires sm.True sm.False sm.True)
    sm.Stuck))
)

; fwd-decl: $smt_typeof
(declare-fun $smt_typeof (sm.Term) sm.Term)

; program: $smt_list_concat
(declare-fun $smt_list_concat (sm.Term sm.Term) sm.Term)
(assert (! (forall ((x1 sm.Term) (x2 sm.Term))
  (= ($smt_list_concat x1 x2)
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    sm.Stuck
  (ite (and ((_ is sm.Apply) x1) ((_ is sm.Apply) (sm.Apply.arg2 x1)) (= (sm.Apply.arg2 (sm.Apply.arg2 x1)) (sm.EoTerm eo.$eo_List_nil)) ((_ is sm.Apply) (sm.Apply.arg1 (sm.Apply.arg2 x1))) (= (sm.Apply.arg1 (sm.Apply.arg1 (sm.Apply.arg2 x1))) (sm.EoTerm eo.$eo_List_cons)) ((_ is sm.Apply) (sm.Apply.arg1 x1)) (= (sm.Apply.arg1 (sm.Apply.arg1 x1)) (sm.EoTerm eo.$eo_List_cons)))
    ($sm_Apply ($sm_Apply (sm.EoTerm eo.$eo_List_cons) (sm.Apply.arg2 (sm.Apply.arg1 x1))) ($sm_Apply ($sm_Apply (sm.EoTerm eo.$eo_List_cons) ($smt_list_concat (sm.Apply.arg2 (sm.Apply.arg1 (sm.Apply.arg2 x1))) x2)) (sm.EoTerm eo.$eo_List_nil)))
  (ite (= x1 (sm.EoTerm eo.$eo_List_nil))
    x2
    sm.Stuck)))))
 :named sm.axiom.$smt_list_concat))

; program: $smt_rat_enum_rec
(declare-fun $smt_rat_enum_rec (sm.Term sm.Term) sm.Term)
(assert (! (forall ((x1 sm.Term) (x2 sm.Term))
  (= ($smt_rat_enum_rec x1 x2)
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    sm.Stuck
  (ite (and (= x1 (sm.Numeral 0)) ((_ is sm.Apply) x2) ((_ is sm.Apply) (sm.Apply.arg2 x2)) (= (sm.Apply.arg2 (sm.Apply.arg2 x2)) (sm.EoTerm eo.$eo_List_nil)) ((_ is sm.Apply) (sm.Apply.arg1 (sm.Apply.arg2 x2))) (= (sm.Apply.arg1 (sm.Apply.arg1 (sm.Apply.arg2 x2))) (sm.EoTerm eo.$eo_List_cons)) ((_ is sm.Apply) (sm.Apply.arg1 x2)) (= (sm.Apply.arg1 (sm.Apply.arg1 x2)) (sm.EoTerm eo.$eo_List_cons)))
    (sm.Apply.arg2 (sm.Apply.arg1 x2))
  (ite (and ((_ is sm.Apply) x2) ((_ is sm.Apply) (sm.Apply.arg2 x2)) (= (sm.Apply.arg2 (sm.Apply.arg2 x2)) (sm.EoTerm eo.$eo_List_nil)) ((_ is sm.Apply) (sm.Apply.arg1 (sm.Apply.arg2 x2))) (= (sm.Apply.arg1 (sm.Apply.arg1 (sm.Apply.arg2 x2))) (sm.EoTerm eo.$eo_List_cons)) ((_ is sm.Apply) (sm.Apply.arg1 x2)) ((_ is sm.Apply) (sm.Apply.arg2 (sm.Apply.arg1 x2))) ((_ is sm.Apply) (sm.Apply.arg1 (sm.Apply.arg2 (sm.Apply.arg1 x2)))) (= (sm.Apply.arg1 (sm.Apply.arg1 (sm.Apply.arg2 (sm.Apply.arg1 x2)))) (sm.EoTerm eo.@smt_ratPair)) (= (sm.Apply.arg1 (sm.Apply.arg1 x2)) (sm.EoTerm eo.$eo_List_cons)))
    ($smt_rat_enum_rec ($eo_add x1 (sm.Numeral (- 1))) ($smt_list_concat (sm.Apply.arg2 (sm.Apply.arg1 (sm.Apply.arg2 x2))) ($sm_Apply ($sm_Apply (sm.EoTerm eo.$eo_List_cons) ($sm_Apply ($sm_Apply (sm.EoTerm eo.@smt_ratPair) ($eo_add (sm.Apply.arg2 (sm.Apply.arg1 (sm.Apply.arg2 (sm.Apply.arg1 x2)))) (sm.Apply.arg2 (sm.Apply.arg2 (sm.Apply.arg1 x2))))) (sm.Apply.arg2 (sm.Apply.arg2 (sm.Apply.arg1 x2))))) ($sm_Apply ($sm_Apply (sm.EoTerm eo.$eo_List_cons) ($sm_Apply ($sm_Apply (sm.EoTerm eo.$eo_List_cons) ($sm_Apply ($sm_Apply (sm.EoTerm eo.@smt_ratPair) (sm.Apply.arg2 (sm.Apply.arg1 (sm.Apply.arg2 (sm.Apply.arg1 x2))))) ($eo_add (sm.Apply.arg2 (sm.Apply.arg1 (sm.Apply.arg2 (sm.Apply.arg1 x2)))) (sm.Apply.arg2 (sm.Apply.arg2 (sm.Apply.arg1 x2)))))) ($sm_Apply ($sm_Apply (sm.EoTerm eo.$eo_List_cons) (sm.EoTerm eo.$eo_List_nil)) (sm.EoTerm eo.$eo_List_nil)))) (sm.EoTerm eo.$eo_List_nil)))))
    sm.Stuck)))))
 :named sm.axiom.$smt_rat_enum_rec))

; program: $smt_rat_to_num
(define-fun $smt_rat_to_num ((x1 sm.Term)) sm.Term
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite (and ((_ is sm.Apply) x1) ((_ is sm.Apply) (sm.Apply.arg1 x1)) (= (sm.Apply.arg1 (sm.Apply.arg1 x1)) (sm.EoTerm eo.@smt_ratPair)))
    ($eo_qdiv (sm.Apply.arg2 (sm.Apply.arg1 x1)) (sm.Apply.arg2 x1))
    sm.Stuck))
)

; program: $smt_type_enum
(declare-fun $smt_type_enum (sm.Term sm.Term) sm.Term)
(assert (! (forall ((x1 sm.Term) (x2 sm.Term))
  (= ($smt_type_enum x1 x2)
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    sm.Stuck
  (ite (= x1 sm.Int)
    ($eo_ite ($eo_eq ($eo_zmod x2 (sm.Numeral 2)) (sm.Numeral 0)) ($eo_zdiv x2 (sm.Numeral 2)) ($eo_neg ($eo_zdiv x2 (sm.Numeral 2))))
  (ite (and ((_ is sm.Apply) x1) (= (sm.Apply.arg2 x1) sm.Char) (= (sm.Apply.arg1 x1) sm.Seq))
    ($eo_ite ($eo_eq x2 (sm.Numeral 0)) (sm.String "") ($eo_concat ($eo_to_str ($eo_zmod x2 (sm.Numeral 196608))) ($smt_type_enum ($sm_Apply sm.Seq sm.Char) ($eo_zdiv x2 (sm.Numeral 196608)))))
  (ite (= x1 sm.Real)
    ($eo_ite ($eo_eq ($eo_zmod ($eo_zdiv ($eo_zdiv x2 (sm.Numeral 2)) (sm.Numeral 2)) (sm.Numeral 2)) (sm.Numeral 0)) ($eo_ite ($eo_eq ($eo_zmod ($eo_zdiv x2 (sm.Numeral 2)) (sm.Numeral 2)) (sm.Numeral 0)) ($smt_rat_to_num ($smt_rat_enum_rec ($eo_zdiv ($eo_zdiv x2 (sm.Numeral 2)) (sm.Numeral 2)) ($sm_Apply ($sm_Apply (sm.EoTerm eo.$eo_List_cons) ($sm_Apply ($sm_Apply (sm.EoTerm eo.@smt_ratPair) (sm.Numeral 1)) (sm.Numeral 1))) ($sm_Apply ($sm_Apply (sm.EoTerm eo.$eo_List_cons) (sm.EoTerm eo.$eo_List_nil)) (sm.EoTerm eo.$eo_List_nil))))) (sm.$smt_unknown_type_enum sm.Real ($eo_zdiv ($eo_zdiv x2 (sm.Numeral 2)) (sm.Numeral 2)))) ($eo_neg ($eo_ite ($eo_eq ($eo_zmod ($eo_zdiv x2 (sm.Numeral 2)) (sm.Numeral 2)) (sm.Numeral 0)) ($smt_rat_to_num ($smt_rat_enum_rec ($eo_zdiv ($eo_zdiv x2 (sm.Numeral 2)) (sm.Numeral 2)) ($sm_Apply ($sm_Apply (sm.EoTerm eo.$eo_List_cons) ($sm_Apply ($sm_Apply (sm.EoTerm eo.@smt_ratPair) (sm.Numeral 1)) (sm.Numeral 1))) ($sm_Apply ($sm_Apply (sm.EoTerm eo.$eo_List_cons) (sm.EoTerm eo.$eo_List_nil)) (sm.EoTerm eo.$eo_List_nil))))) (sm.$smt_unknown_type_enum sm.Real ($eo_zdiv ($eo_zdiv x2 (sm.Numeral 2)) (sm.Numeral 2))))))
  (ite ((_ is sm.$smt_BitVec) x1)
    ($eo_requires ($eo_to_z ($eo_to_bin (sm.$smt_BitVec.arg1 x1) x2)) x2 ($eo_to_bin (sm.$smt_BitVec.arg1 x1) x2))
  (ite true
    ($eo_ite ($eo_is_ok ($eo_type_enum x1 x2)) ($eo_type_enum x1 x2) (sm.$smt_unknown_type_enum x1 x2))
    sm.Stuck))))))))
 :named sm.axiom.$smt_type_enum))

; program: $smt_type_enum_contains_rec
(declare-fun $smt_type_enum_contains_rec (sm.Term sm.Term sm.Term) sm.Term)
(assert (! (forall ((x1 sm.Term) (x2 sm.Term) (x3 sm.Term))
  (= ($smt_type_enum_contains_rec x1 x2 x3)
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck) (= x3 sm.Stuck))
    sm.Stuck
  (ite true
    ($eo_ite ($eo_is_ok ($smt_type_enum x1 x3)) ($eo_ite ($eo_eq ($smt_type_enum x1 x3) x2) sm.True ($smt_type_enum_contains_rec x1 x3 ($eo_add x3 (sm.Numeral 1)))) sm.False)
    sm.Stuck))))
 :named sm.axiom.$smt_type_enum_contains_rec))

; fwd-decl: $smt_is_value
(declare-fun $smt_is_value (sm.Term sm.Term) sm.Term)

; program: $smt_map_is_value
(define-fun $smt_map_is_value ((x1 sm.Term)) sm.Term
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite (and ((_ is sm.Apply) x1) ((_ is sm.Apply) (sm.Apply.arg1 x1)) ((_ is sm.Apply) (sm.Apply.arg1 (sm.Apply.arg1 x1))) (= (sm.Apply.arg1 (sm.Apply.arg1 (sm.Apply.arg1 x1))) (sm.EoTerm eo.@Map_nil)))
    ($smt_is_value (sm.Apply.arg2 (sm.Apply.arg1 x1)) (sm.Apply.arg2 x1))
    sm.Stuck))
)

; program: $smt_dt_is_value
(declare-fun $smt_dt_is_value (sm.Term) sm.Term)
(assert (! (forall ((x1 sm.Term))
  (= ($smt_dt_is_value x1)
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite ((_ is sm.Apply) x1)
    ($eo_ite ($smt_is_value ($smt_typeof (sm.Apply.arg2 x1)) (sm.Apply.arg2 x1)) ($smt_dt_is_value (sm.Apply.arg1 x1)) sm.False)
  (ite true
    ($eo_is_ok ($eo_dt_selectors x1))
    sm.Stuck)))))
 :named sm.axiom.$smt_dt_is_value))

; program: $smt_is_value
(assert (! (forall ((x1 sm.Term) (x2 sm.Term))
  (= ($smt_is_value x1 x2)
  (ite (or (= x1 sm.Stuck) (= x2 sm.Stuck))
    sm.Stuck
  (ite (= x1 sm.$smt_unknown_type)
    sm.False
  (ite (and (= x1 sm.BoolType) (= x2 sm.True))
    sm.True
  (ite (and (= x1 sm.BoolType) (= x2 sm.False))
    sm.True
  (ite (= x1 sm.Int)
    ($smt_to_eo_bool ((_ is sm.Numeral)x2))
  (ite (= x1 sm.Real)
    ($smt_to_eo_bool ((_ is sm.Rational)x2))
  (ite (and ((_ is sm.Apply) x1) (= (sm.Apply.arg2 x1) sm.Char) (= (sm.Apply.arg1 x1) sm.Seq))
    ($smt_to_eo_bool ((_ is sm.String)x2))
  (ite (and ((_ is sm.Apply) x1) ((_ is sm.Apply) (sm.Apply.arg1 x1)) (= (sm.Apply.arg1 (sm.Apply.arg1 x1)) (sm.EoTerm eo.@Map)))
    ($smt_map_is_value x2)
  (ite true
    ($eo_ite ($eo_is_ok ($eo_dt_constructors x1)) ($smt_dt_is_value x2) ($smt_type_enum_contains_rec x1 x2 (sm.Numeral 0)))
    sm.Stuck)))))))))))
 :named sm.axiom.$smt_is_value))

; fwd-decl: $smt_model_eval
(declare-fun $smt_model_eval (sm.Term) sm.Term)

; fwd-decl: $smt_model_lookup
(declare-fun $smt_model_lookup (sm.Term sm.Term sm.Term) sm.Term)

; program: $smt_model_eval
(assert (! (forall ((x1 sm.Term))
  (= ($smt_model_eval x1)
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite (and ((_ is sm.Apply) x1) (= (sm.Apply.arg1 x1) sm.not))
    ($smt_to_eo_bool (not ($smt_from_eo_bool ($smt_model_eval (sm.Apply.arg2 x1)))))
  (ite (and ((_ is sm.Apply) x1) ((_ is sm.Apply) (sm.Apply.arg1 x1)) (= (sm.Apply.arg1 (sm.Apply.arg1 x1)) sm.and))
    ($smt_to_eo_bool (and ($smt_from_eo_bool ($smt_model_eval (sm.Apply.arg2 (sm.Apply.arg1 x1)))) ($smt_from_eo_bool ($smt_model_eval (sm.Apply.arg2 x1)))))
  (ite (and ((_ is sm.Apply) x1) ((_ is sm.Apply) (sm.Apply.arg1 x1)) (= (sm.Apply.arg1 (sm.Apply.arg1 x1)) sm.=))
    ($eo_ite ($eo_and ($smt_is_value ($smt_typeof (sm.Apply.arg2 (sm.Apply.arg1 x1))) ($smt_model_eval (sm.Apply.arg2 (sm.Apply.arg1 x1)))) ($smt_is_value ($smt_typeof (sm.Apply.arg2 (sm.Apply.arg1 x1))) ($smt_model_eval (sm.Apply.arg2 x1)))) ($smt_to_eo_bool (= ($smt_model_eval (sm.Apply.arg2 (sm.Apply.arg1 x1))) ($smt_model_eval (sm.Apply.arg2 x1)))) ($sm_Apply ($sm_Apply sm.= (sm.Apply.arg2 (sm.Apply.arg1 x1))) (sm.Apply.arg2 x1)))
  (ite ((_ is sm.$smt_Const) x1)
    ($eo_ite ($smt_model_eval ($eo_ite ($eo_eq (sm.$smt_Const.arg1 x1) (sm.Numeral 0)) sm.True ($eo_ite ($eo_is_ok ($eo_const_predicate (sm.$smt_Const.arg1 x1) (sm.$smt_Const.arg2 x1) (sm.$smt_Const.arg3 x1))) ($eo_const_predicate (sm.$smt_Const.arg1 x1) (sm.$smt_Const.arg2 x1) (sm.$smt_Const.arg3 x1)) sm.True))) ($smt_model_lookup (sm.$smt_Const.arg1 x1) (sm.$smt_Const.arg2 x1) (sm.$smt_Const.arg3 x1)) (sm.$smt_Const (sm.$smt_Const.arg1 x1) (sm.$smt_Const.arg2 x1) (sm.$smt_Const.arg3 x1)))
  (ite ((_ is sm.Apply) x1)
    ($eo_ite ($eo_is_ok ($eo_model_eval ($sm_Apply ($smt_model_eval (sm.Apply.arg1 x1)) ($smt_model_eval (sm.Apply.arg2 x1))))) ($eo_model_eval ($sm_Apply ($smt_model_eval (sm.Apply.arg1 x1)) ($smt_model_eval (sm.Apply.arg2 x1)))) ($sm_Apply ($smt_model_eval (sm.Apply.arg1 x1)) ($smt_model_eval (sm.Apply.arg2 x1))))
  (ite true
    ($eo_ite ($eo_is_ok ($eo_model_eval x1)) ($eo_model_eval x1) x1)
    sm.Stuck)))))))))
 :named sm.axiom.$smt_model_eval))

; program: $eo_model_sat
(assert (! (forall ((x1 sm.Term))
  (= ($eo_model_sat x1)
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite true
    ($smt_model_eval x1)
    sm.Stuck))))
 :named sm.axiom.$eo_model_sat))

; program: $smt_typeof
(assert (! (forall ((x1 sm.Term))
  (= ($smt_typeof x1)
  (ite (= x1 sm.Stuck)
    sm.Stuck
  (ite (= x1 sm.$smt_unknown_type)
    sm.Type
  (ite ((_ is sm.$smt_Const) x1)
    (sm.$smt_Const.arg3 x1)
  (ite true
    ($eo_ite ($eo_is_ok ($eo_typeof x1)) ($eo_typeof x1) sm.$smt_unknown_type)
    sm.Stuck))))))
 :named sm.axiom.$smt_typeof))



;;; The verification condition

;;;; final verification condition for $eovc_symm
(assert (! (exists ((x1 sm.Term))
  (= ($eovc_symm x1) sm.True)) :named sm.conjecture.$eovc_symm))


(check-sat)
