(set-logic UFDTSNIRA)

; TODO: types vs terms
;(declare-datatype sm.Type
;  (
;  )
;)
(declare-datatype sm.Term
  (
  ; The type of types  TODO: maybe this is Eunoia??
  (sm.Type)
  ; Application of an SMT-LIB term
  (sm.Apply (sm.Apply.arg1 sm.Term) (sm.Apply.arg2 sm.Term))
  ; Booleans
  (sm.BoolType)
  (sm.True)
  (sm.False)
  ; Literal types
  (sm.Numeral (sm.Numeral.arg1 Int))
  (sm.Rational (sm.Rational.arg1 Real))
  (sm.String (sm.String.arg1 String))
  (sm.Binary (sm.Binary.arg1 Int) (sm.Binary.arg2 Int))

  ; generated by signature
  ; declare $eo_undef_type SMT_TERM
  (sm.$eo_undef_type)
  ; declare Int SMT_TERM
  (sm.Int)
  ; declare Real SMT_TERM
  (sm.Real)
  ; declare Char SMT_TERM
  (sm.Char)
  ; declare Seq SMT_TERM
  (sm.Seq)
  ; declare $smt_unknown_type SMT_TERM
  (sm.$smt_unknown_type)
  ; declare not SMT_TERM
  (sm.not)
  ; declare and SMT_TERM
  (sm.and)
  ; declare $eo_Var SMT_TERM
  (sm.$eo_Var)
  ; declare = SMT_TERM
  (sm.=)
  ; declare BitVec SMT_TERM
  (sm.BitVec)
  ; declare $smt_FunType SMT_TERM
  (sm.$smt_FunType (sm.$smt_FunType.arg1 sm.Term) (sm.$smt_FunType.arg2 sm.Term))

  )
)

; A Eunoia internal term
(declare-datatype eo.Term
  (
  ; Application of a Eunoia term
  (eo.FunType (eo.FunType.arg1 eo.Term) (eo.FunType.arg2 eo.Term))
  ; Application of a Eunoia term
  (eo.Apply (eo.Apply.arg1 eo.Term) (eo.Apply.arg2 eo.Term))
  ; The SMT-LIB embedding of a Eunoia term
  (eo.SmtTerm (eo.SmtTerm.arg1 sm.Term))
  ; Defines "stuckness"
  (eo.Stuck)

  ; generated by signature
  ; declare $eo_List EUNOIA_TERM
  (eo.$eo_List)
  ; declare @Map EUNOIA_TERM
  (eo.@Map)
  ; declare @Map_nil EUNOIA_TERM
  (eo.@Map_nil)

  )
)

; convert to SMT
(define-fun eo.to_smt ((x eo.Term)) sm.Term (eo.SmtTerm.arg1 x))
(define-fun smt.to_eo ((x sm.Term)) eo.Term (eo.SmtTerm x))

;;; Utilities

; Stuckness propagates through non-nullary constructors
(define-fun $eo_FunType ((x eo.Term) (y eo.Term)) eo.Term
  (ite (or (= x eo.Stuck) (= y eo.Stuck))
    eo.Stuck
    (eo.FunType x y)))

(define-fun $eo_Apply ((x eo.Term) (y eo.Term)) eo.Term
  (ite (or (= x eo.Stuck) (= y eo.Stuck))
    eo.Stuck
    (eo.Apply x y)))

;;; Core operators

; Note that these cannot be lifted further since their semantics wrt
; stuckness is non-standard.

; axiom: $eo_is_ok
(define-fun $eo_is_ok ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    (eo.SmtTerm sm.False)
    (eo.SmtTerm sm.True)))

; axiom: $eo_ite
(define-fun $eo_ite ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term)) eo.Term
  (ite (= x1 (eo.SmtTerm sm.True))
    x2
  (ite (= x1 (eo.SmtTerm sm.False))
    x3
    eo.Stuck)))

; axiom: $eo_requires
(define-fun $eo_requires ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term)) eo.Term
  (ite (and (not (= x1 eo.Stuck)) (not (= x2 eo.Stuck)) (= x1 x2))
    x3
    eo.Stuck))

; axiom: $eo_hash
; note: This is defined axiomatically.
; TODO: break dependence on sm.Numeral??
(declare-fun $eo_hash (eo.Term) eo.Term)
(assert (! (forall ((x eo.Term))
  (=> (not (= x eo.Stuck))
    (and
      ((_ is eo.SmtTerm) ($eo_hash x))
      ((_ is sm.Numeral) (eo.to_smt ($eo_hash x)))))) :named sm.hash_numeral))
(assert (! (forall ((x eo.Term) (y eo.Term))
  (=> (and (not (= x eo.Stuck)) (not (= y eo.Stuck))
    (= ($eo_hash x) ($eo_hash y))) (= x y))) :named sm.hash_inj))

;;; User defined symbols

; fwd-decl: $eo_typeof
(declare-fun $eo_typeof (eo.Term) eo.Term)

; fwd-decl: $eo_model_sat
(declare-fun $eo_model_sat (eo.Term) eo.Term)

; program: $sm_mk_pow2
(declare-fun $sm_mk_pow2 (Int) Int)
(assert (! (forall ((x1 Int))
  (= ($sm_mk_pow2 x1)
  (ite (<= x1 0) 1 (* 2 ($sm_mk_pow2 (- x1 1))))
)) :named sm.axiom.$sm_mk_pow2))

; program: $sm_mk_bit
(define-fun $sm_mk_bit ((x1 Int) (x2 Int)) Bool
  (= 1 (mod (div x1 ($sm_mk_pow2 x2)) 2))
)

; program: $sm_mk_binary_and
(declare-fun $sm_mk_binary_and (Int Int Int) Int)
(assert (! (forall ((x1 Int) (x2 Int) (x3 Int))
  (= ($sm_mk_binary_and x1 x2 x3)
  (ite (= x1 0) 0 (ite (= x1 1) (ite (and (= x2 1) (= x3 1)) 1 0) (+ ($sm_mk_binary_and (- x1 1) x2 x3) (* ($sm_mk_pow2 x1) (ite (and ($sm_mk_bit x2 x1) ($sm_mk_bit x3 x1)) 1 0)))))
)) :named sm.axiom.$sm_mk_binary_and))

; fwd-decl: $sm_mk_binary_not
(declare-fun $sm_mk_binary_not (Int Int) Int)

; program: $sm_mk_binary_max
(define-fun $sm_mk_binary_max ((x1 Int)) Int
  (- 1 ($sm_mk_pow2 x1))
)

; fwd-decl: $sm_mk_binary_concat
(declare-fun $sm_mk_binary_concat (Int Int Int Int) Int)

; program: $eo_mk_bool
(define-fun $eo_mk_bool ((x1 Bool)) eo.Term
  (eo.SmtTerm (ite x1 sm.True sm.False))
)

; program: $eo_mk_numeral
(define-fun $eo_mk_numeral ((x1 Int)) eo.Term
  (eo.SmtTerm (sm.Numeral x1))
)

; program: $eo_mk_rational
(define-fun $eo_mk_rational ((x1 Real)) eo.Term
  (eo.SmtTerm (sm.Rational x1))
)

; program: $eo_mk_string
(define-fun $eo_mk_string ((x1 String)) eo.Term
  (eo.SmtTerm (sm.String x1))
)

; program: $eo_mk_binary
(define-fun $eo_mk_binary ((x1 Int) (x2 Int)) eo.Term
  (ite (and (<= 0 x1) (<= x1 4294967296)) (eo.SmtTerm (sm.Binary x1 (mod x2 ($sm_mk_pow2 x1)))) eo.Stuck)
)

; fwd-decl: $smt_from_eo_bool
(declare-fun $smt_from_eo_bool (eo.Term) Bool)

; program: $eo_not
(define-fun $eo_not ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) (= (eo.SmtTerm.arg1 x1) sm.True))
    (eo.SmtTerm sm.False)
  (ite (and ((_ is eo.SmtTerm) x1) (= (eo.SmtTerm.arg1 x1) sm.False))
    (eo.SmtTerm sm.True)
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Binary) (eo.SmtTerm.arg1 x1)))
    ($eo_mk_binary (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) ($sm_mk_binary_not (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg2 (eo.SmtTerm.arg1 x1))))
    eo.Stuck)))))

; program: $eo_and
(define-fun $eo_and ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Binary) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.Binary) (eo.SmtTerm.arg1 x2)) (= (sm.Binary.arg1 (eo.SmtTerm.arg1 x2)) (sm.Binary.arg1 (eo.SmtTerm.arg1 x1))))
    ($eo_mk_binary (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) ($sm_mk_binary_and (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg2 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg2 (eo.SmtTerm.arg1 x2))))
  (ite true
    (ite (and (or (= sm.True (eo.to_smt x1)) (= sm.False (eo.to_smt x1))) (or (= sm.True (eo.to_smt x2)) (= sm.False (eo.to_smt x2)))) ($eo_mk_bool (and (= sm.True (eo.to_smt x1)) (= sm.True (eo.to_smt x2)))) eo.Stuck)
    eo.Stuck))))

; program: $eo_add
(define-fun $eo_add ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x2)))
    ($eo_mk_numeral (+ (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1)) (sm.Numeral.arg1 (eo.SmtTerm.arg1 x2))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Rational) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.Rational) (eo.SmtTerm.arg1 x2)))
    ($eo_mk_rational (+ (sm.Rational.arg1 (eo.SmtTerm.arg1 x1)) (sm.Rational.arg1 (eo.SmtTerm.arg1 x2))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Binary) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.Binary) (eo.SmtTerm.arg1 x2)) (= (sm.Binary.arg1 (eo.SmtTerm.arg1 x2)) (sm.Binary.arg1 (eo.SmtTerm.arg1 x1))))
    ($eo_mk_binary (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) (+ (sm.Binary.arg2 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg2 (eo.SmtTerm.arg1 x2))))
    eo.Stuck)))))

; program: $eo_zdiv
(define-fun $eo_zdiv ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x2)))
    (ite (= 0 (sm.Numeral.arg1 (eo.SmtTerm.arg1 x2))) eo.Stuck ($eo_mk_numeral (div (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1)) (sm.Numeral.arg1 (eo.SmtTerm.arg1 x2)))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Binary) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.Binary) (eo.SmtTerm.arg1 x2)) (= (sm.Binary.arg1 (eo.SmtTerm.arg1 x2)) (sm.Binary.arg1 (eo.SmtTerm.arg1 x1))))
    (ite (= 0 (sm.Binary.arg2 (eo.SmtTerm.arg1 x2))) ($eo_mk_binary (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) ($sm_mk_binary_max (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)))) ($eo_mk_binary (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) (div (sm.Binary.arg2 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg2 (eo.SmtTerm.arg1 x2)))))
    eo.Stuck))))

; program: $eo_zmod
(define-fun $eo_zmod ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x2)))
    (ite (= 0 (sm.Numeral.arg1 (eo.SmtTerm.arg1 x2))) eo.Stuck ($eo_mk_numeral (mod (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1)) (sm.Numeral.arg1 (eo.SmtTerm.arg1 x2)))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Binary) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.Binary) (eo.SmtTerm.arg1 x2)) (= (sm.Binary.arg1 (eo.SmtTerm.arg1 x2)) (sm.Binary.arg1 (eo.SmtTerm.arg1 x1))))
    (ite (= 0 (sm.Binary.arg2 (eo.SmtTerm.arg1 x2))) (eo.SmtTerm (sm.Binary (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg2 (eo.SmtTerm.arg1 x1)))) ($eo_mk_binary (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) (mod (sm.Binary.arg2 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg2 (eo.SmtTerm.arg1 x2)))))
    eo.Stuck))))

; program: $eo_neg
(define-fun $eo_neg ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x1)))
    ($eo_mk_numeral (-  (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Rational) (eo.SmtTerm.arg1 x1)))
    ($eo_mk_rational (- (sm.Rational.arg1 (eo.SmtTerm.arg1 x1))))
    eo.Stuck))))

; program: $eo_len
(define-fun $eo_len ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.String) (eo.SmtTerm.arg1 x1)))
    ($eo_mk_numeral (str.len (sm.String.arg1 (eo.SmtTerm.arg1 x1))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Binary) (eo.SmtTerm.arg1 x1)))
    ($eo_mk_numeral (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)))
    eo.Stuck))))

; program: $eo_concat
(define-fun $eo_concat ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.String) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.String) (eo.SmtTerm.arg1 x2)))
    ($eo_mk_string (str.++ (sm.String.arg1 (eo.SmtTerm.arg1 x1)) (sm.String.arg1 (eo.SmtTerm.arg1 x2))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Binary) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.Binary) (eo.SmtTerm.arg1 x2)))
    ($eo_mk_binary (+ (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg1 (eo.SmtTerm.arg1 x2))) ($sm_mk_binary_concat (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg2 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg1 (eo.SmtTerm.arg1 x2)) (sm.Binary.arg2 (eo.SmtTerm.arg1 x2))))
    eo.Stuck))))

; program: $eo_to_z
(define-fun $eo_to_z ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x1)))
    ($eo_mk_numeral (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1)))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Rational) (eo.SmtTerm.arg1 x1)))
    ($eo_mk_numeral (to_int (sm.Rational.arg1 (eo.SmtTerm.arg1 x1))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.String) (eo.SmtTerm.arg1 x1)))
    (ite (= 1 (str.len (sm.String.arg1 (eo.SmtTerm.arg1 x1)))) ($eo_mk_numeral (str.to_code (sm.String.arg1 (eo.SmtTerm.arg1 x1)))) eo.Stuck)
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Binary) (eo.SmtTerm.arg1 x1)))
    ($eo_mk_numeral (sm.Binary.arg2 (eo.SmtTerm.arg1 x1)))
    eo.Stuck))))))

; program: $eo_to_q
(define-fun $eo_to_q ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x1)))
    ($eo_mk_rational (to_real (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Rational) (eo.SmtTerm.arg1 x1)))
    ($eo_mk_rational (sm.Rational.arg1 (eo.SmtTerm.arg1 x1)))
    eo.Stuck))))

; program: $eo_to_bin
(define-fun $eo_to_bin ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x2)))
    ($eo_mk_binary (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1)) (sm.Numeral.arg1 (eo.SmtTerm.arg1 x2)))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x1)) ((_ is eo.SmtTerm) x2) ((_ is sm.Binary) (eo.SmtTerm.arg1 x2)))
    ($eo_mk_binary (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg2 (eo.SmtTerm.arg1 x2)))
    eo.Stuck))))

; program: $eo_to_str
(define-fun $eo_to_str ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x1)))
    (ite (and (<= 0 (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1))) (> 196608 (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1)))) ($eo_mk_string (str.from_code (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1)))) eo.Stuck)
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.String) (eo.SmtTerm.arg1 x1)))
    ($eo_mk_string (sm.String.arg1 (eo.SmtTerm.arg1 x1)))
    eo.Stuck))))

; fwd-decl: $eo_dt_constructors
(declare-fun $eo_dt_constructors (eo.Term) eo.Term)

; fwd-decl: $eo_dt_selectors
(declare-fun $eo_dt_selectors (eo.Term) eo.Term)

; program: $eo_eq
(define-fun $eo_eq ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (= x2 x1)
    (eo.SmtTerm sm.True)
  (ite true
    (eo.SmtTerm sm.False)
    eo.Stuck))))

; define $eo_is_eq
(define-fun $eo_is_eq ((t eo.Term) (s eo.Term)) eo.Term ($eo_ite ($eo_and ($eo_is_ok t) ($eo_is_ok s)) ($eo_eq s t) (eo.SmtTerm sm.False)))

; define $eo_is_z
(define-fun $eo_is_z ((x eo.Term)) eo.Term ($eo_ite ($eo_and ($eo_is_ok ($eo_to_z x)) ($eo_is_ok x)) ($eo_eq x ($eo_to_z x)) (eo.SmtTerm sm.False)))

; define $eo_is_q
(define-fun $eo_is_q ((x eo.Term)) eo.Term ($eo_ite ($eo_and ($eo_is_ok ($eo_to_q x)) ($eo_is_ok x)) ($eo_eq x ($eo_to_q x)) (eo.SmtTerm sm.False)))

; define $eo_is_bin
(define-fun $eo_is_bin ((x eo.Term)) eo.Term ($eo_ite ($eo_and ($eo_is_ok ($eo_to_bin ($eo_len x) x)) ($eo_is_ok x)) ($eo_eq x ($eo_to_bin ($eo_len x) x)) (eo.SmtTerm sm.False)))

; define $eo_is_str
(define-fun $eo_is_str ((x eo.Term)) eo.Term ($eo_ite ($eo_and ($eo_is_ok ($eo_to_str x)) ($eo_is_ok x)) ($eo_eq x ($eo_to_str x)) (eo.SmtTerm sm.False)))

; define $eo_is_bool
(define-fun $eo_is_bool ((x eo.Term)) eo.Term ($eo_ite ($eo_ite ($eo_and ($eo_is_ok x) (eo.SmtTerm sm.True)) ($eo_eq (eo.SmtTerm sm.True) x) (eo.SmtTerm sm.False)) (eo.SmtTerm sm.True) ($eo_ite ($eo_and ($eo_is_ok x) (eo.SmtTerm sm.True)) ($eo_eq (eo.SmtTerm sm.False) x) (eo.SmtTerm sm.False))))

; program: $mk_symm
(define-fun $mk_symm ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Apply) (eo.SmtTerm.arg1 x1)) ((_ is sm.Apply) (sm.Apply.arg1 (eo.SmtTerm.arg1 x1))) (= (sm.Apply.arg1 (sm.Apply.arg1 (eo.SmtTerm.arg1 x1))) sm.=))
    (eo.SmtTerm (sm.Apply (sm.Apply sm.= (sm.Apply.arg2 (eo.SmtTerm.arg1 x1))) (sm.Apply.arg2 (sm.Apply.arg1 (eo.SmtTerm.arg1 x1)))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Apply) (eo.SmtTerm.arg1 x1)) ((_ is sm.Apply) (sm.Apply.arg2 (eo.SmtTerm.arg1 x1))) ((_ is sm.Apply) (sm.Apply.arg1 (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)))) (= (sm.Apply.arg1 (sm.Apply.arg1 (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)))) sm.=) (= (sm.Apply.arg1 (eo.SmtTerm.arg1 x1)) sm.not))
    (eo.SmtTerm (sm.Apply sm.not (sm.Apply (sm.Apply sm.= (sm.Apply.arg2 (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)))) (sm.Apply.arg2 (sm.Apply.arg1 (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)))))))
    eo.Stuck))))

; program: $eo_typeof_apply
(define-fun $eo_typeof_apply ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (and ((_ is eo.FunType) x1) (= x2 (eo.FunType.arg1 x1)))
    (eo.FunType.arg2 x1)
    eo.Stuck)))

; program: $eo_typeof_=
(define-fun $eo_typeof_= ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eo_FunType x1 (eo.SmtTerm sm.BoolType))
    eo.Stuck)))

; program: $eo_typeof_main
(define-fun $eo_typeof_main ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (= x1 (eo.SmtTerm sm.Type))
    (eo.SmtTerm sm.Type)
  (ite ((_ is eo.FunType) x1)
    ($eo_requires ($eo_typeof (eo.FunType.arg1 x1)) (eo.SmtTerm sm.Type) ($eo_requires ($eo_typeof (eo.FunType.arg2 x1)) (eo.SmtTerm sm.Type) (eo.SmtTerm sm.Type)))
  (ite (= x1 (eo.SmtTerm sm.BoolType))
    (eo.SmtTerm sm.Type)
  (ite (= x1 (eo.SmtTerm sm.True))
    (eo.SmtTerm sm.BoolType)
  (ite (= x1 (eo.SmtTerm sm.False))
    (eo.SmtTerm sm.BoolType)
  (ite (= x1 (eo.SmtTerm sm.Int))
    (eo.SmtTerm sm.Type)
  (ite (= x1 (eo.SmtTerm sm.Real))
    (eo.SmtTerm sm.Type)
  (ite (= x1 (eo.SmtTerm sm.Char))
    (eo.SmtTerm sm.Type)
  (ite (= x1 (eo.SmtTerm sm.Seq))
    ($eo_FunType (eo.SmtTerm sm.Type) (eo.SmtTerm sm.Type))
  (ite (= x1 (eo.SmtTerm sm.not))
    ($eo_FunType (eo.SmtTerm sm.BoolType) (eo.SmtTerm sm.BoolType))
  (ite (= x1 (eo.SmtTerm sm.and))
    ($eo_FunType (eo.SmtTerm sm.BoolType) ($eo_FunType (eo.SmtTerm sm.BoolType) (eo.SmtTerm sm.BoolType)))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Apply) (eo.SmtTerm.arg1 x1)) (= (sm.Apply.arg1 (eo.SmtTerm.arg1 x1)) sm.=))
    ($eo_typeof_= ($eo_typeof (eo.SmtTerm (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)))))
  (ite (= x1 (eo.SmtTerm sm.BitVec))
    ($eo_FunType (eo.SmtTerm sm.Int) (eo.SmtTerm sm.Type))
  (ite ((_ is eo.Apply) x1)
    ($eo_typeof_apply ($eo_typeof (eo.Apply.arg1 x1)) ($eo_typeof (eo.Apply.arg2 x1)))
    eo.Stuck))))))))))))))))

; program: $eo_dt_constructors
(assert (! (forall ((x1 eo.Term))
  (= ($eo_dt_constructors x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eo_requires (eo.SmtTerm sm.True) (eo.SmtTerm sm.False) (eo.SmtTerm sm.True))
    eo.Stuck)))) :named sm.axiom.$eo_dt_constructors))

; program: $eo_dt_selectors
(assert (! (forall ((x1 eo.Term))
  (= ($eo_dt_selectors x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eo_requires (eo.SmtTerm sm.True) (eo.SmtTerm sm.False) (eo.SmtTerm sm.True))
    eo.Stuck)))) :named sm.axiom.$eo_dt_selectors))

; program: $eo_typeof
(assert (! (forall ((x1 eo.Term))
  (= ($eo_typeof x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Apply) (eo.SmtTerm.arg1 x1)) ((_ is sm.Apply) (sm.Apply.arg1 (eo.SmtTerm.arg1 x1))) (= (sm.Apply.arg1 (sm.Apply.arg1 (eo.SmtTerm.arg1 x1))) sm.$eo_Var))
    (eo.SmtTerm (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)))
  (ite true
    ($eo_ite ($eo_ite ($eo_ite ($eo_and ($eo_is_ok x1) (eo.SmtTerm sm.True)) ($eo_eq (eo.SmtTerm sm.True) x1) (eo.SmtTerm sm.False)) (eo.SmtTerm sm.True) ($eo_ite ($eo_and ($eo_is_ok x1) (eo.SmtTerm sm.True)) ($eo_eq (eo.SmtTerm sm.False) x1) (eo.SmtTerm sm.False))) (eo.SmtTerm sm.BoolType) ($eo_ite ($eo_ite ($eo_and ($eo_is_ok ($eo_to_z x1)) ($eo_is_ok x1)) ($eo_eq x1 ($eo_to_z x1)) (eo.SmtTerm sm.False)) (eo.SmtTerm sm.Int) ($eo_ite ($eo_ite ($eo_and ($eo_is_ok ($eo_to_q x1)) ($eo_is_ok x1)) ($eo_eq x1 ($eo_to_q x1)) (eo.SmtTerm sm.False)) (eo.SmtTerm sm.Real) ($eo_ite ($eo_ite ($eo_and ($eo_is_ok ($eo_to_str x1)) ($eo_is_ok x1)) ($eo_eq x1 ($eo_to_str x1)) (eo.SmtTerm sm.False)) (eo.SmtTerm (sm.Apply sm.Seq sm.Char)) ($eo_ite ($eo_ite ($eo_and ($eo_is_ok ($eo_to_bin ($eo_len x1) x1)) ($eo_is_ok x1)) ($eo_eq x1 ($eo_to_bin ($eo_len x1) x1)) (eo.SmtTerm sm.False)) (eo.SmtTerm sm.$eo_undef_type) ($eo_typeof_main x1))))))
    eo.Stuck))))) :named sm.axiom.$eo_typeof))

; program: $eorx_symm
(define-fun $eorx_symm ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (= x2 (eo.SmtTerm sm.BoolType))
    ($mk_symm x1)
    eo.Stuck)))

; program: $eor_symm
(define-fun $eor_symm ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eorx_symm x1 ($eo_typeof x1))
    eo.Stuck)))

; program: $eovc_symm
(define-fun $eovc_symm ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eo_requires ($eo_model_sat x1) (eo.SmtTerm sm.True) ($eo_requires ($eo_model_sat ($eor_symm x1)) (eo.SmtTerm sm.False) (eo.SmtTerm sm.True)))
    eo.Stuck)))

; program: $eo_const_predicate
(define-fun $eo_const_predicate ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck) (= x3 eo.Stuck))
    eo.Stuck
  (ite true
    ($eo_requires (eo.SmtTerm sm.True) (eo.SmtTerm sm.False) (eo.SmtTerm sm.True))
    eo.Stuck)))

; program: $eo_model_eval
(define-fun $eo_model_eval ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eo_requires (eo.SmtTerm sm.True) (eo.SmtTerm sm.False) (eo.SmtTerm sm.True))
    eo.Stuck)))

; fwd-decl: $smt_typeof
(declare-fun $smt_typeof (eo.Term) eo.Term)

; program: $smt_type_enum
(declare-fun $smt_type_enum (sm.Term eo.Term) sm.Term)
(assert (! (forall ((x1 sm.Term) (x2 eo.Term))
  (= ($smt_type_enum x1 x2)
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (= x1 (eo.SmtTerm sm.Int))
    ($eo_ite ($eo_eq ($eo_zmod x2 (sm.Numeral 2)) (sm.Numeral 0)) ($eo_zdiv x2 (sm.Numeral 2)) ($eo_neg ($eo_zdiv x2 (sm.Numeral 2))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Apply) (eo.SmtTerm.arg1 x1)) (= (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)) sm.Char) (= (sm.Apply.arg1 (eo.SmtTerm.arg1 x1)) sm.Seq))
    ($eo_ite ($eo_eq x2 (sm.Numeral 0)) (sm.String "") ($eo_concat ($eo_to_str ($eo_zmod x2 (sm.Numeral 196608))) ($smt_type_enum (eo.SmtTerm (sm.Apply sm.Seq sm.Char)) ($eo_zdiv x2 (eo.SmtTerm 196608)))))
    eo.Stuck))))) :named sm.axiom.$smt_type_enum))

; program: $smt_type_enum_contains_rec
(declare-fun $smt_type_enum_contains_rec (eo.Term eo.Term eo.Term) eo.Term)
(assert (! (forall ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term))
  (= ($smt_type_enum_contains_rec x1 x2 x3)
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck) (= x3 eo.Stuck))
    eo.Stuck
  (ite true
    ($eo_ite ($eo_is_ok ($smt_type_enum x1 x3)) ($eo_ite ($eo_eq ($smt_type_enum x1 x3) x2) (eo.SmtTerm sm.True) ($smt_type_enum_contains_rec x1 x3 ($eo_add x3 (eo.SmtTerm 1)))) (eo.SmtTerm sm.False))
    eo.Stuck)))) :named sm.axiom.$smt_type_enum_contains_rec))

; fwd-decl: $smt_is_value
(declare-fun $smt_is_value (eo.Term eo.Term) eo.Term)

; program: $smt_map_is_value
(define-fun $smt_map_is_value ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) ((_ is eo.Apply) (eo.Apply.arg1 (eo.Apply.arg1 x1))) (= (eo.Apply.arg1 (eo.Apply.arg1 (eo.Apply.arg1 x1))) eo.@Map_nil))
    ($smt_is_value (eo.Apply.arg2 (eo.Apply.arg1 x1)) (eo.Apply.arg2 x1))
    eo.Stuck)))

; program: $smt_dt_is_value
(declare-fun $smt_dt_is_value (eo.Term) eo.Term)
(assert (! (forall ((x1 eo.Term))
  (= ($smt_dt_is_value x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite ((_ is eo.Apply) x1)
    ($eo_ite ($smt_is_value ($smt_typeof (eo.Apply.arg2 x1)) (eo.Apply.arg2 x1)) ($smt_dt_is_value (eo.Apply.arg1 x1)) (eo.SmtTerm sm.False))
  (ite true
    ($eo_is_ok ($eo_dt_selectors x1))
    eo.Stuck))))) :named sm.axiom.$smt_dt_is_value))

; program: $smt_is_value
(assert (! (forall ((x1 eo.Term) (x2 eo.Term))
  (= ($smt_is_value x1 x2)
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (= x1 (eo.SmtTerm sm.$smt_unknown_type))
    (eo.SmtTerm sm.False)
  (ite (and (= x1 (eo.SmtTerm sm.BoolType)) (= x2 (eo.SmtTerm sm.True)))
    (eo.SmtTerm sm.True)
  (ite (and (= x1 (eo.SmtTerm sm.BoolType)) (= x2 (eo.SmtTerm sm.False)))
    (eo.SmtTerm sm.True)
  (ite (and (= x1 (eo.SmtTerm sm.Int)) ((_ is eo.SmtTerm) x2) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x2)))
    (eo.SmtTerm sm.True)
  (ite (and (= x1 (eo.SmtTerm sm.Real)) ((_ is eo.SmtTerm) x2) ((_ is sm.Rational) (eo.SmtTerm.arg1 x2)))
    (eo.SmtTerm sm.True)
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Apply) (eo.SmtTerm.arg1 x1)) (= (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)) sm.Char) (= (sm.Apply.arg1 (eo.SmtTerm.arg1 x1)) sm.Seq) ((_ is eo.SmtTerm) x2) ((_ is sm.String) (eo.SmtTerm.arg1 x2)))
    (eo.SmtTerm sm.True)
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) (= (eo.Apply.arg1 (eo.Apply.arg1 x1)) eo.@Map))
    ($smt_map_is_value x2)
  (ite true
    ($eo_ite ($eo_is_ok ($eo_dt_constructors x1)) ($smt_dt_is_value x2) ($smt_type_enum_contains_rec x1 x2 (eo.SmtTerm 0)))
    eo.Stuck))))))))))) :named sm.axiom.$smt_is_value))

; fwd-decl: $smt_model_eval
(declare-fun $smt_model_eval (eo.Term) eo.Term)

; fwd-decl: $smt_model_lookup
(declare-fun $smt_model_lookup (eo.Term eo.Term eo.Term) eo.Term)

; program: $smt_model_eval
(assert (! (forall ((x1 eo.Term))
  (= ($smt_model_eval x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (= x1 (eo.SmtTerm sm.True))
    (eo.SmtTerm sm.True)
  (ite (= x1 (eo.SmtTerm sm.False))
    (eo.SmtTerm sm.False)
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Apply) (eo.SmtTerm.arg1 x1)) (= (sm.Apply.arg1 (eo.SmtTerm.arg1 x1)) sm.not))
    ($eo_mk_bool (not ($smt_from_eo_bool ($smt_model_eval (eo.SmtTerm (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)))))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Apply) (eo.SmtTerm.arg1 x1)) ((_ is sm.Apply) (sm.Apply.arg1 (eo.SmtTerm.arg1 x1))) (= (sm.Apply.arg1 (sm.Apply.arg1 (eo.SmtTerm.arg1 x1))) sm.and))
    ($eo_mk_bool (and ($smt_from_eo_bool ($smt_model_eval (eo.SmtTerm (sm.Apply.arg2 (sm.Apply.arg1 (eo.SmtTerm.arg1 x1)))))) ($smt_from_eo_bool ($smt_model_eval (eo.SmtTerm (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)))))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Apply) (eo.SmtTerm.arg1 x1)) ((_ is sm.Apply) (sm.Apply.arg1 (eo.SmtTerm.arg1 x1))) (= (sm.Apply.arg1 (sm.Apply.arg1 (eo.SmtTerm.arg1 x1))) sm.=))
    ($eo_ite ($eo_and ($smt_is_value ($smt_typeof (eo.SmtTerm (sm.Apply.arg2 (sm.Apply.arg1 (eo.SmtTerm.arg1 x1))))) ($smt_model_eval (eo.SmtTerm (sm.Apply.arg2 (sm.Apply.arg1 (eo.SmtTerm.arg1 x1)))))) ($smt_is_value ($smt_typeof (eo.SmtTerm (sm.Apply.arg2 (sm.Apply.arg1 (eo.SmtTerm.arg1 x1))))) ($smt_model_eval (eo.SmtTerm (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)))))) ($eo_mk_bool (= ($smt_model_eval (eo.SmtTerm (sm.Apply.arg2 (sm.Apply.arg1 (eo.SmtTerm.arg1 x1))))) ($smt_model_eval (eo.SmtTerm (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)))))) (eo.SmtTerm (sm.Apply (sm.Apply sm.= (sm.Apply.arg2 (sm.Apply.arg1 (eo.SmtTerm.arg1 x1)))) (sm.Apply.arg2 (eo.SmtTerm.arg1 x1)))))
  (ite ((_ is (eo.SmtTerm sm.Const)) x1)
    ($eo_ite ($smt_model_eval ($eo_ite ($eo_eq ((eo.SmtTerm sm.Const).arg1 x1) (eo.SmtTerm 0)) (eo.SmtTerm sm.True) (ite (= ($eo_const_predicate ((eo.SmtTerm sm.Const).arg1 x1) ((eo.SmtTerm sm.Const).arg2 x1) ((eo.SmtTerm sm.Const).arg3 x1)) eo.Stuck) (eo.SmtTerm sm.True) ($eo_const_predicate ((eo.SmtTerm sm.Const).arg1 x1) ((eo.SmtTerm sm.Const).arg2 x1) ((eo.SmtTerm sm.Const).arg3 x1))))) ($smt_model_lookup ((eo.SmtTerm sm.Const).arg1 x1) ((eo.SmtTerm sm.Const).arg2 x1) ((eo.SmtTerm sm.Const).arg3 x1)) ((eo.SmtTerm sm.Const) ((eo.SmtTerm sm.Const).arg1 x1) ((eo.SmtTerm sm.Const).arg2 x1) ((eo.SmtTerm sm.Const).arg3 x1)))
  (ite ((_ is eo.Apply) x1)
    (ite (= ($eo_model_eval (($smt_model_eval (eo.Apply.arg1 x1)) ($smt_model_eval (eo.Apply.arg2 x1)))) eo.Stuck) (($smt_model_eval (eo.Apply.arg1 x1)) ($smt_model_eval (eo.Apply.arg2 x1))) ($eo_model_eval (($smt_model_eval (eo.Apply.arg1 x1)) ($smt_model_eval (eo.Apply.arg2 x1)))))
  (ite true
    (ite (= ($eo_model_eval x1) eo.Stuck) x1 ($eo_model_eval x1))
    eo.Stuck))))))))))) :named sm.axiom.$smt_model_eval))

; program: $eo_model_sat
(assert (! (forall ((x1 eo.Term))
  (= ($eo_model_sat x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($smt_model_eval x1)
    eo.Stuck)))) :named sm.axiom.$eo_model_sat))

; program: $smt_typeof
(assert (! (forall ((x1 eo.Term))
  (= ($smt_typeof x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite ((_ is (eo.SmtTerm sm.$smt_FunType)) x1)
    ($eo_requires ($smt_typeof ((eo.SmtTerm sm.$smt_FunType).arg1 x1)) (eo.SmtTerm sm.Type) ($eo_requires ($smt_typeof ((eo.SmtTerm sm.$smt_FunType).arg2 x1)) (eo.SmtTerm sm.Type) (eo.SmtTerm sm.Type)))
  (ite (= x1 (eo.SmtTerm sm.$smt_unknown_type))
    (eo.SmtTerm sm.Type)
  (ite ((_ is (eo.SmtTerm sm.Const)) x1)
    ((eo.SmtTerm sm.Const).arg3 x1)
  (ite true
    (ite (= ($eo_typeof x1) eo.Stuck) (eo.SmtTerm sm.$smt_unknown_type) ($eo_typeof x1))
    eo.Stuck))))))) :named sm.axiom.$smt_typeof))



;;; The verification condition

;;;; final verification condition for $eovc_symm
(assert (! (exists ((x1 sm.Term))
  (= ($eovc_symm (eo.SmtTerm x1)) sm.True)) :named sm.conjecture.$eovc_symm))


(check-sat)
