(set-logic UFDTSNIRA)

; tsm.Type:
;   The final embedding of atomic SMT-LIB types that are relevant to the VC.
; sm.Term:
;   The final embedding of atomic SMT-LIB terms that are relevant to the VC.
; eo.Term:
;   The final embedding of Eunoia terms that are relevant to the VC.
;   SMT-LIB terms, types and values are embedded in this datatype. This
;   datatype contains a superset of the Herbrand universe of all types being
;   considered.
;   We require a mutually recursive datatype, since these are
;   inter-dependent.
(declare-datatypes ((tsm.Type 0) (sm.Term 0) (eo.Term 0) (vsm.Value 0) (msm.Map 0) (ssm.Seq 0))
  (
  (
  ; user-decl: Int
  (tsm.Int)
  ; user-decl: Real
  (tsm.Real)
  ; user-decl: BitVec
  (tsm.BitVec)
  ; user-decl: Char
  (tsm.Char)
  ; user-decl: Seq
  (tsm.Seq)
  ; smt-cons: Bool
  (tsm.Bool)

  )
  (
  ; smt-cons: Boolean
  (sm.Boolean (sm.Boolean.arg1 Bool))
  ; smt-cons: Numeral
  (sm.Numeral (sm.Numeral.arg1 Int))
  ; smt-cons: Rational
  (sm.Rational (sm.Rational.arg1 Real))
  ; smt-cons: String
  (sm.String (sm.String.arg1 String))
  ; smt-cons: Binary
  (sm.Binary (sm.Binary.arg1 Int) (sm.Binary.arg2 Int))
  ; user-decl: not
  (sm.not)
  ; user-decl: and
  (sm.and)
  ; user-decl: =
  (sm.=)

  )
  (
  ; user-decl: $eo_List
  (eo.$eo_List)
  ; user-decl: $eo_List_nil
  (eo.$eo_List_nil)
  ; user-decl: $eo_List_cons
  (eo.$eo_List_cons)
  ; smt-cons: Type
  (eo.Type)
  ; smt-cons: Stuck
  (eo.Stuck)
  ; smt-cons: Apply
  (eo.Apply (eo.Apply.arg1 eo.Term) (eo.Apply.arg2 eo.Term))
  ; smt-cons: FunType
  (eo.FunType)
  ; smt-cons: SmtTerm
  (eo.SmtTerm (eo.SmtTerm.arg1 sm.Term))
  ; smt-cons: SmtType
  (eo.SmtType (eo.SmtType.arg1 tsm.Type))
  ; smt-cons: Var
  (eo.Var (eo.Var.arg1 String) (eo.Var.arg2 eo.Term))

  )
  (
  ; smt-cons: Map
  (vsm.Map (vsm.Map.arg1 msm.Map))
  ; smt-cons: Term
  (vsm.Term (vsm.Term.arg1 sm.Term))
  ; smt-cons: Apply
  (vsm.Apply (vsm.Apply.arg1 vsm.Value) (vsm.Apply.arg2 vsm.Value))
  ; smt-cons: NotValue
  (vsm.NotValue)

  )
  (
  ; (msm.cons i e M) maps i -> e, as well as mappings in M
  (msm.cons (msm.cons.arg1 vsm.Value) (msm.cons.arg2 vsm.Value) (msm.cons.arg3 msm.Map))
  ; (msm.default e) maps all remaining elements in the sort to e
  (msm.default (msm.default.arg1 vsm.Value))
  )
  (
  ; (ssm.cons i s) is a sequence
  (ssm.cons (ssm.cons.arg1 vsm.Value) (ssm.cons.arg2 ssm.Seq))
  ; the empty sequence
  (ssm.empty)
  )
  )
)

;;; Relevant definitions

(define-fun $eo_Numeral () eo.Term (eo.SmtType tsm.Int))
(define-fun $eo_String () eo.Term (eo.Apply (eo.SmtType tsm.Seq) (eo.SmtType tsm.Char)))
; fwd-decl: $eo_typeof
(declare-fun $eo_typeof (eo.Term) eo.Term)

; fwd-decl: $eo_dt_selectors
(declare-fun $eo_dt_selectors (eo.Term) eo.Term)

; program: $eo_fail_prog
(define-fun $eo_fail_prog ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (= x1 (eo.SmtTerm (sm.Boolean true)))
    (eo.SmtTerm (sm.Boolean true))
    eo.Stuck)))

(define-fun $eo_fail () eo.Term ($eo_fail_prog (eo.SmtTerm (sm.Boolean false))))
; program: $eo_requires_eq
(define-fun $eo_requires_eq ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck) (= x3 eo.Stuck))
    eo.Stuck
  (ite (= x2 x1)
    x3
    eo.Stuck)))

(define-fun $eo_Type () eo.Term eo.Type)
(define-fun $eo_stuck () eo.Term eo.Stuck)
; program: $eo_apply
(define-fun $eo_apply ((x1 eo.Term) (x2 eo.Term)) eo.Term
    (eo.Apply x1 x2)
)

(define-fun $eo_fun_type () eo.Term eo.FunType)
; program: $eo_smt_term
(define-fun $eo_smt_term ((x1 sm.Term)) eo.Term
    (eo.SmtTerm x1)
)

; program: $eo_smt_type
(define-fun $eo_smt_type ((x1 tsm.Type)) eo.Term
    (eo.SmtType x1)
)

; program: $eo_Var
(define-fun $eo_Var ((x1 String) (x2 eo.Term)) eo.Term
    (eo.Var x1 x2)
)

; program: $smtx_pow2
(declare-fun $smtx_pow2 (Int) Int)
(assert (! (forall ((x1 Int))
  (! (= ($smtx_pow2 x1)
    (ite (<= x1 0) 1 (* 2 ($smtx_pow2 (- x1 1))))
) :pattern (($smtx_pow2 x1)))) :named sm.axiom.$smtx_pow2))

; program: $eo_bool
(define-fun $eo_bool ((x1 Bool)) eo.Term
    (eo.SmtTerm (sm.Boolean x1))
)

; program: $eo_numeral
(define-fun $eo_numeral ((x1 Int)) eo.Term
    (eo.SmtTerm (sm.Numeral x1))
)

; program: $eo_rational
(define-fun $eo_rational ((x1 Real)) eo.Term
    (eo.SmtTerm (sm.Rational x1))
)

; program: $eo_string
(define-fun $eo_string ((x1 String)) eo.Term
    (eo.SmtTerm (sm.String x1))
)

; program: $eo_binary
(define-fun $eo_binary ((x1 Int) (x2 Int)) eo.Term
    (eo.SmtTerm (sm.Binary x1 x2))
)

; program: $eo_mk_apply
(define-fun $eo_mk_apply ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite true
    (eo.Apply x1 x2)
    eo.Stuck)))

; program: $eo_len
(define-fun $eo_len ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.String) (eo.SmtTerm.arg1 x1)))
    (eo.SmtTerm (sm.Numeral (str.len (sm.String.arg1 (eo.SmtTerm.arg1 x1)))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Binary) (eo.SmtTerm.arg1 x1)))
    (eo.SmtTerm (sm.Numeral (sm.Binary.arg1 (eo.SmtTerm.arg1 x1))))
    eo.Stuck))))

; fwd-decl: $smtx_hash
(declare-fun $smtx_hash (eo.Term) Int)

; fwd-decl: $eo_reverse_hash
(declare-fun $eo_reverse_hash (Int) eo.Term)

; fwd-decl: $smtx_value_hash
(declare-fun $smtx_value_hash (vsm.Value) Int)

; fwd-decl: $smtx_reverse_value_hash
(declare-fun $smtx_reverse_value_hash (Int) vsm.Value)

; fwd-decl: $eo_typeof_main
(declare-fun $eo_typeof_main (eo.Term) eo.Term)

; fwd-decl: $eo_lit_type_Numeral
(declare-fun $eo_lit_type_Numeral (eo.Term) eo.Term)

; fwd-decl: $eo_lit_type_Rational
(declare-fun $eo_lit_type_Rational (eo.Term) eo.Term)

; fwd-decl: $eo_lit_type_Binary
(declare-fun $eo_lit_type_Binary (eo.Term) eo.Term)

; fwd-decl: $eo_lit_type_String
(declare-fun $eo_lit_type_String (eo.Term) eo.Term)

; program: $eo_typeof
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_typeof x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Boolean) (eo.SmtTerm.arg1 x1)))
    (eo.SmtType tsm.Bool)
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Numeral) (eo.SmtTerm.arg1 x1)))
    ($eo_lit_type_Numeral (eo.SmtTerm (sm.Numeral (sm.Numeral.arg1 (eo.SmtTerm.arg1 x1)))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Rational) (eo.SmtTerm.arg1 x1)))
    ($eo_lit_type_Rational (eo.SmtTerm (sm.Rational (sm.Rational.arg1 (eo.SmtTerm.arg1 x1)))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.String) (eo.SmtTerm.arg1 x1)))
    ($eo_lit_type_String (eo.SmtTerm (sm.String (sm.String.arg1 (eo.SmtTerm.arg1 x1)))))
  (ite (and ((_ is eo.SmtTerm) x1) ((_ is sm.Binary) (eo.SmtTerm.arg1 x1)))
    ($eo_lit_type_Binary (eo.SmtTerm (sm.Binary (sm.Binary.arg1 (eo.SmtTerm.arg1 x1)) (sm.Binary.arg2 (eo.SmtTerm.arg1 x1)))))
  (ite ((_ is eo.Var) x1)
    (eo.Var.arg2 x1)
  (ite true
    ($eo_typeof_main x1)
    eo.Stuck))))))))) :pattern (($eo_typeof x1)))) :named sm.axiom.$eo_typeof))

; program: $mk_symm
(define-fun $mk_symm ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) ((_ is eo.SmtTerm) (eo.Apply.arg1 (eo.Apply.arg1 x1))) (= (eo.SmtTerm.arg1 (eo.Apply.arg1 (eo.Apply.arg1 x1))) sm.=))
    (eo.Apply (eo.Apply (eo.SmtTerm sm.=) (eo.Apply.arg2 x1)) (eo.Apply.arg2 (eo.Apply.arg1 x1)))
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg2 x1)) ((_ is eo.Apply) (eo.Apply.arg1 (eo.Apply.arg2 x1))) ((_ is eo.SmtTerm) (eo.Apply.arg1 (eo.Apply.arg1 (eo.Apply.arg2 x1)))) (= (eo.SmtTerm.arg1 (eo.Apply.arg1 (eo.Apply.arg1 (eo.Apply.arg2 x1)))) sm.=) ((_ is eo.SmtTerm) (eo.Apply.arg1 x1)) (= (eo.SmtTerm.arg1 (eo.Apply.arg1 x1)) sm.not))
    (eo.Apply (eo.Apply (eo.SmtTerm sm.=) (eo.Apply.arg2 (eo.Apply.arg2 x1))) (eo.Apply.arg2 (eo.Apply.arg1 (eo.Apply.arg2 x1))))
    eo.Stuck))))

; program: $eo_typeof_apply
(define-fun $eo_typeof_apply ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) ((_ is eo.FunType) (eo.Apply.arg1 (eo.Apply.arg1 x1))) (= x2 (eo.Apply.arg2 (eo.Apply.arg1 x1))))
    (eo.Apply.arg2 x1)
    eo.Stuck)))

; program: $eo_typeof_=
(define-fun $eo_typeof_= ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    (eo.Apply (eo.Apply eo.FunType x1) (eo.SmtType tsm.Bool))
    eo.Stuck)))

; program: $eo_typeof_fun_type
(define-fun $eo_typeof_fun_type ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (and (= x1 eo.Type) (= x2 eo.Type))
    eo.Type
    eo.Stuck)))

; program: $eo_typeof_main
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_typeof_main x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (= x1 eo.Type)
    eo.Type
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) ((_ is eo.FunType) (eo.Apply.arg1 (eo.Apply.arg1 x1))))
    ($eo_typeof_fun_type ($eo_typeof (eo.Apply.arg2 (eo.Apply.arg1 x1))) ($eo_typeof (eo.Apply.arg2 x1)))
  (ite (= x1 (eo.SmtType tsm.Bool))
    eo.Type
  (ite (= x1 (eo.SmtTerm (sm.Boolean true)))
    (eo.SmtType tsm.Bool)
  (ite (= x1 (eo.SmtTerm (sm.Boolean false)))
    (eo.SmtType tsm.Bool)
  (ite (= x1 eo.$eo_List)
    eo.Type
  (ite (= x1 eo.$eo_List_nil)
    eo.$eo_List
  (ite (and ((_ is eo.Apply) x1) (= (eo.Apply.arg1 x1) eo.$eo_List_cons))
    (eo.Apply (eo.Apply eo.FunType eo.$eo_List) eo.$eo_List)
  (ite (and ((_ is eo.SmtType) x1) (= (eo.SmtType.arg1 x1) tsm.Int))
    eo.Type
  (ite (and ((_ is eo.SmtType) x1) (= (eo.SmtType.arg1 x1) tsm.Real))
    eo.Type
  (ite (and ((_ is eo.SmtType) x1) (= (eo.SmtType.arg1 x1) tsm.BitVec))
    (eo.Apply (eo.Apply eo.FunType (eo.SmtType tsm.Int)) eo.Type)
  (ite (and ((_ is eo.SmtType) x1) (= (eo.SmtType.arg1 x1) tsm.Char))
    eo.Type
  (ite (and ((_ is eo.SmtType) x1) (= (eo.SmtType.arg1 x1) tsm.Seq))
    (eo.Apply (eo.Apply eo.FunType eo.Type) eo.Type)
  (ite (and ((_ is eo.SmtTerm) x1) (= (eo.SmtTerm.arg1 x1) sm.not))
    (eo.Apply (eo.Apply eo.FunType (eo.SmtType tsm.Bool)) (eo.SmtType tsm.Bool))
  (ite (and ((_ is eo.SmtTerm) x1) (= (eo.SmtTerm.arg1 x1) sm.and))
    (eo.Apply (eo.Apply eo.FunType (eo.SmtType tsm.Bool)) (eo.Apply (eo.Apply eo.FunType (eo.SmtType tsm.Bool)) (eo.SmtType tsm.Bool)))
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.SmtTerm) (eo.Apply.arg1 x1)) (= (eo.SmtTerm.arg1 (eo.Apply.arg1 x1)) sm.=))
    ($eo_typeof_= ($eo_typeof (eo.Apply.arg2 x1)))
  (ite ((_ is eo.Apply) x1)
    ($eo_typeof_apply ($eo_typeof (eo.Apply.arg1 x1)) ($eo_typeof (eo.Apply.arg2 x1)))
    eo.Stuck))))))))))))))))))) :pattern (($eo_typeof_main x1)))) :named sm.axiom.$eo_typeof_main))

; program: $eo_lit_type_Numeral
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_lit_type_Numeral x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    (eo.SmtType tsm.Int)
    eo.Stuck))) :pattern (($eo_lit_type_Numeral x1)))) :named sm.axiom.$eo_lit_type_Numeral))

; program: $eo_lit_type_Rational
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_lit_type_Rational x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    (eo.SmtType tsm.Real)
    eo.Stuck))) :pattern (($eo_lit_type_Rational x1)))) :named sm.axiom.$eo_lit_type_Rational))

; program: $eo_lit_type_Binary
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_lit_type_Binary x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eo_mk_apply (eo.SmtType tsm.BitVec) ($eo_len x1))
    eo.Stuck))) :pattern (($eo_lit_type_Binary x1)))) :named sm.axiom.$eo_lit_type_Binary))

; program: $eo_lit_type_String
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_lit_type_String x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    (eo.Apply (eo.SmtType tsm.Seq) (eo.SmtType tsm.Char))
    eo.Stuck))) :pattern (($eo_lit_type_String x1)))) :named sm.axiom.$eo_lit_type_String))

; program: $eo_dt_selectors
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_dt_selectors x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eo_fail_prog (eo.SmtTerm (sm.Boolean false)))
    eo.Stuck))) :pattern (($eo_dt_selectors x1)))) :named sm.axiom.$eo_dt_selectors))

; fwd-decl: $eo_model_sat
(declare-fun $eo_model_sat (eo.Term) eo.Term)

; fwd-decl: $eo_model_unsat
(declare-fun $eo_model_unsat (eo.Term) eo.Term)

; fwd-decl: $eo_model_is_input
(declare-fun $eo_model_is_input (eo.Term) eo.Term)

; program: $smtx_msm_lookup
(declare-fun $smtx_msm_lookup (msm.Map vsm.Value) vsm.Value)
(assert (! (forall ((x1 msm.Map) (x2 vsm.Value))
  (! (= ($smtx_msm_lookup x1 x2)
  (ite (and ((_ is msm.cons) x1) (= x2 (msm.cons.arg1 x1)))
    (msm.cons.arg2 x1)
  (ite ((_ is msm.cons) x1)
    ($smtx_msm_lookup (msm.cons.arg3 x1) x2)
    (msm.default.arg1 x1)
))) :pattern (($smtx_msm_lookup x1 x2)))) :named sm.axiom.$smtx_msm_lookup))

; program: $smtx_is_atomic_term_value
(define-fun $smtx_is_atomic_term_value ((x1 sm.Term)) Bool
  (ite ((_ is sm.Boolean) x1)
    true
  (ite ((_ is sm.Numeral) x1)
    true
  (ite ((_ is sm.Rational) x1)
    true
  (ite ((_ is sm.String) x1)
    true
  (ite ((_ is sm.Binary) x1)
    (and (<= 0 (sm.Binary.arg1 x1)) (= (sm.Binary (sm.Binary.arg1 x1) (sm.Binary.arg2 x1)) (sm.Binary (sm.Binary.arg1 x1) (mod (sm.Binary.arg2 x1) ($smtx_pow2 (sm.Binary.arg1 x1))))))
    false
))))))

; fwd-decl: $smtx_model_eval
(declare-fun $smtx_model_eval (eo.Term) vsm.Value)

; program: $smtx_model_eval_apply
(define-fun $smtx_model_eval_apply ((x1 vsm.Value) (x2 vsm.Value)) vsm.Value
  (ite ((_ is vsm.Apply) x1)
    (vsm.Apply (vsm.Apply (vsm.Apply.arg1 x1) (vsm.Apply.arg2 x1)) x2)
  (ite ((_ is vsm.Map) x1)
    ($smtx_msm_lookup (vsm.Map.arg1 x1) x2)
    vsm.NotValue
)))

; program: $smtx_model_eval_=
(define-fun $smtx_model_eval_= ((x1 vsm.Value) (x2 vsm.Value)) vsm.Value
  (ite (= x1 vsm.NotValue)
    vsm.NotValue
  (ite (= x2 vsm.NotValue)
    vsm.NotValue
    (vsm.Term (sm.Boolean (= x1 x2)))
)))

; program: $smtx_model_eval_not
(define-fun $smtx_model_eval_not ((x1 vsm.Value)) vsm.Value
  (ite (and ((_ is vsm.Term) x1) ((_ is sm.Boolean) (vsm.Term.arg1 x1)))
    (vsm.Term (sm.Boolean (not (sm.Boolean.arg1 (vsm.Term.arg1 x1)))))
    vsm.NotValue
))

; program: $smtx_model_eval_and
(define-fun $smtx_model_eval_and ((x1 vsm.Value) (x2 vsm.Value)) vsm.Value
  (ite (and ((_ is vsm.Term) x1) ((_ is sm.Boolean) (vsm.Term.arg1 x1)) ((_ is vsm.Term) x2) ((_ is sm.Boolean) (vsm.Term.arg1 x2)))
    (vsm.Term (sm.Boolean (and (sm.Boolean.arg1 (vsm.Term.arg1 x1)) (sm.Boolean.arg1 (vsm.Term.arg1 x2)))))
    vsm.NotValue
))

; program: $smtx_model_eval
(assert (! (forall ((x1 eo.Term))
  (! (= ($smtx_model_eval x1)
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.SmtTerm) (eo.Apply.arg1 x1)) (= (eo.SmtTerm.arg1 (eo.Apply.arg1 x1)) sm.not))
    ($smtx_model_eval_not ($smtx_model_eval (eo.Apply.arg2 x1)))
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) ((_ is eo.SmtTerm) (eo.Apply.arg1 (eo.Apply.arg1 x1))) (= (eo.SmtTerm.arg1 (eo.Apply.arg1 (eo.Apply.arg1 x1))) sm.and))
    ($smtx_model_eval_and ($smtx_model_eval (eo.Apply.arg2 (eo.Apply.arg1 x1))) ($smtx_model_eval (eo.Apply.arg2 x1)))
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) ((_ is eo.SmtTerm) (eo.Apply.arg1 (eo.Apply.arg1 x1))) (= (eo.SmtTerm.arg1 (eo.Apply.arg1 (eo.Apply.arg1 x1))) sm.=))
    ($smtx_model_eval_= ($smtx_model_eval (eo.Apply.arg2 (eo.Apply.arg1 x1))) ($smtx_model_eval (eo.Apply.arg2 x1)))
  (ite ((_ is eo.Apply) x1)
    ($smtx_model_eval_apply ($smtx_model_eval (eo.Apply.arg1 x1)) ($smtx_model_eval (eo.Apply.arg2 x1)))
    (ite ($smtx_is_atomic_term_value (eo.SmtTerm.arg1 x1)) (vsm.Term (eo.SmtTerm.arg1 x1)) (ite (not (= ($eo_dt_selectors x1) eo.Stuck)) (vsm.Apply (vsm.Term (eo.SmtTerm.arg1 x1)) vsm.NotValue) vsm.NotValue))
))))) :pattern (($smtx_model_eval x1)))) :named sm.axiom.$smtx_model_eval))

; program: $smtx_is_list
(declare-fun $smtx_is_list (eo.Term) Bool)
(assert (! (forall ((x1 eo.Term))
  (! (= ($smtx_is_list x1)
  (ite (= x1 eo.$eo_List_nil)
    true
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) (= (eo.Apply.arg1 (eo.Apply.arg1 x1)) eo.$eo_List_cons))
    ($smtx_is_list (eo.Apply.arg2 x1))
    false
))) :pattern (($smtx_is_list x1)))) :named sm.axiom.$smtx_is_list))

; program: $smtx_is_input
(declare-fun $smtx_is_input (eo.Term) Bool)
(assert (! (forall ((x1 eo.Term))
  (! (= ($smtx_is_input x1)
  (ite ((_ is eo.SmtTerm) x1)
    true
  (ite ((_ is eo.SmtType) x1)
    true
  (ite ((_ is eo.Var) x1)
    true
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) (= (eo.Apply.arg1 (eo.Apply.arg1 x1)) eo.$eo_List_cons))
    ($smtx_is_list (eo.Apply.arg2 x1))
  (ite ((_ is eo.Apply) x1)
    (and ($smtx_is_input (eo.Apply.arg1 x1)) ($smtx_is_input (eo.Apply.arg2 x1)))
    false
)))))) :pattern (($smtx_is_input x1)))) :named sm.axiom.$smtx_is_input))

; program: $eo_model_sat
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_model_sat x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    (ite (= ($smtx_model_eval x1) (vsm.Term (sm.Boolean true))) (eo.SmtTerm (sm.Boolean true)) (eo.SmtTerm (sm.Boolean false)))
    eo.Stuck))) :pattern (($eo_model_sat x1)))) :named sm.axiom.$eo_model_sat))

; program: $eo_model_unsat
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_model_unsat x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    (ite (= ($smtx_model_eval x1) (vsm.Term (sm.Boolean false))) (eo.SmtTerm (sm.Boolean true)) (eo.SmtTerm (sm.Boolean false)))
    eo.Stuck))) :pattern (($eo_model_unsat x1)))) :named sm.axiom.$eo_model_unsat))

; program: $eo_model_is_input
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_model_is_input x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    (eo.SmtTerm (sm.Boolean ($smtx_is_input x1)))
    eo.Stuck))) :pattern (($eo_model_is_input x1)))) :named sm.axiom.$eo_model_is_input))

; program: $eor_symm
(define-fun $eor_symm ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eo_requires_eq ($eo_typeof ($mk_symm x1)) (eo.SmtType tsm.Bool) ($mk_symm x1))
    eo.Stuck)))

; program: $eovc_symm
(define-fun $eovc_symm ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eo_requires_eq ($eo_model_is_input ($eor_symm x1)) (eo.SmtTerm (sm.Boolean true)) ($eo_requires_eq ($eo_typeof x1) (eo.SmtType tsm.Bool) ($eo_requires_eq ($eo_model_sat x1) (eo.SmtTerm (sm.Boolean true)) ($eo_requires_eq ($eo_model_unsat ($eor_symm x1)) (eo.SmtTerm (sm.Boolean true)) (eo.SmtTerm (sm.Boolean true))))))
    eo.Stuck)))



;;; Meta-level properties of models

; axiom for hash
; note: this implies that $smtx_hash is injective, which implies $eo_hash is injective.
(assert (! (forall ((x eo.Term))
    (! (= ($eo_reverse_hash ($smtx_hash x)) x) :pattern (($smtx_hash x)))) :named eo.hash_injective))
(assert (! (forall ((x vsm.Value))
    (! (= ($smtx_reverse_value_hash ($smtx_value_hash x)) x) :pattern (($smtx_value_hash x)))) :named smtx.hash_injective))


;;; The verification condition

;;;; final verification condition for $eovc_symm
(synth-fun arg_F () eo.Term
  ((G_Start eo.Term) (G_eo.Term eo.Term) (G_Bool Bool) (G_Int Int) (G_RegLan RegLan) (G_Int_C Int) (G_Real Real) (G_String String) (T_SmtType eo.Term) (T_Type eo.Term) (T_Fun eo.Term) (T_Int eo.Term) (T_$eo_List eo.Term) (T_SmtTerm eo.Term) (T_Bool eo.Term) (T_Real eo.Term) (T_Seq eo.Term) (T_BitVec eo.Term)) (
  (G_Start eo.Term (T_Bool))
  (G_eo.Term eo.Term (eo.Type eo.FunType (eo.Var G_String G_eo.Term) T_Type T_Bool T_Fun T_SmtTerm T_SmtType T_Int T_Real T_BitVec T_Seq T_$eo_List T_SmtType T_Type T_Fun T_Int T_$eo_List T_SmtTerm T_Bool T_Real T_Seq T_BitVec ))
  (G_Bool Bool (true false))
  (G_Int Int (0 (- G_Int_C) G_Int_C))
  (G_RegLan RegLan (re.all re.none (str.to_re G_String) (re.union G_RegLan G_RegLan)))
  (G_Int_C Int (1 (+ G_Int_C 1)))
  (G_Real Real (0.0 (/ G_Int_C G_Int_C) (- (/ G_Int_C G_Int_C))))
  (G_String String ("" (str.++ G_String "A") (str.++ G_String "B")))
  (T_SmtType eo.Term (T_Type ))
  (T_Type eo.Term ((eo.SmtType tsm.Int) (eo.SmtType tsm.Real) (eo.Apply (eo.SmtType tsm.BitVec) T_Int) (eo.SmtType tsm.Char) (eo.Apply (eo.SmtType tsm.Seq) T_Type) eo.$eo_List (eo.SmtType tsm.Bool) ))
  (T_Fun eo.Term ((eo.SmtType tsm.BitVec) (eo.SmtType tsm.Seq) eo.$eo_List_cons (eo.SmtTerm sm.not) (eo.SmtTerm sm.and) (eo.SmtTerm sm.=) ))
  (T_Int eo.Term ((eo.SmtTerm (sm.Numeral G_Int)) ))
  (T_$eo_List eo.Term (eo.$eo_List_nil (eo.Apply (eo.Apply eo.$eo_List_cons G_eo.Term) T_$eo_List) ))
  (T_SmtTerm eo.Term (T_Bool T_Int T_Real T_Seq T_BitVec ))
  (T_Bool eo.Term ((eo.SmtTerm (sm.Boolean G_Bool)) (eo.Apply (eo.SmtTerm sm.not) T_Bool) (eo.Apply (eo.Apply (eo.SmtTerm sm.and) T_Bool) T_Bool) (eo.Apply (eo.Apply (eo.SmtTerm sm.=) T_SmtTerm) T_SmtTerm) ))
  (T_Real eo.Term ((eo.SmtTerm (sm.Rational G_Real)) ))
  (T_Seq eo.Term ((eo.SmtTerm (sm.String G_String)) ))
  (T_BitVec eo.Term ((eo.SmtTerm (sm.Binary G_Int G_Int)) ))
)
)
(constraint (= ($eovc_symm arg_F) (eo.SmtTerm (sm.Boolean true))))
(check-synth)

