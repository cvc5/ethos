(set-logic ALL)

(define-sort Rat () Real)
(define-fun iff ((x Bool) (y Bool)) Bool (= x y))
; Helpers to avoid mixed arithmetic
(define-fun mk_rational ((x Int) (y Int)) Real (/ (to_real x) (to_real y)))
(define-fun zeq ((x Int) (y Int)) Bool (= x y))
(define-fun zleq ((x Int) (y Int)) Bool (<= x y))
(define-fun zlt ((x Int) (y Int)) Bool (< x y))
(define-fun zplus ((x Int) (y Int)) Int (+ x y))
(define-fun zmult ((x Int) (y Int)) Int (* x y))
(define-fun zneg ((x Int)) Int (- x))
(define-fun qeq ((x Real) (y Real)) Bool (= x y))
(define-fun qleq ((x Real) (y Real)) Bool (<= x y))
(define-fun qlt ((x Real) (y Real)) Bool (< x y))
(define-fun qplus ((x Real) (y Real)) Real (+ x y))
(define-fun qmult ((x Real) (y Real)) Real (* x y))
(define-fun qneg ((x Real)) Real (- x))
(define-fun streq ((x String) (y String)) Bool (= x y))

; tsm.Type:
;   The final embedding of atomic SMT-LIB types that are relevant to the VC.
; sm.Term:
;   The final embedding of atomic SMT-LIB terms that are relevant to the VC.
; eo.Term:
;   The final embedding of Eunoia terms that are relevant to the VC.
;   SMT-LIB terms, types and values are embedded in this datatype. This
;   datatype contains a superset of the Herbrand universe of all types being
;   considered.
;   We require a mutually recursive datatype, since these are
;   inter-dependent.
(declare-datatypes
  ((eo.Term 0) (vsm.Value 0) (msm.Map 0) (ssm.Seq 0) (sm.Term 0) (tsm.Type 0) (dt.Datatype 0) (dtc.DatatypeCons 0))
  (
  (
  ; user-decl: $eo_Proof
  (eo.$eo_Proof)
  ; user-decl: $eo_pf
  (eo.$eo_pf (eo.$eo_pf.arg1 eo.Term))
  ; user-decl: Int
  (eo.Int)
  ; user-decl: Real
  (eo.Real)
  ; user-decl: BitVec
  (eo.BitVec)
  ; user-decl: Char
  (eo.Char)
  ; user-decl: Seq
  (eo.Seq)
  ; user-decl: $eo_List
  (eo.$eo_List)
  ; user-decl: $eo_List_nil
  (eo.$eo_List_nil)
  ; user-decl: $eo_List_cons
  (eo.$eo_List_cons)
  ; smt-cons: Bool
  (eo.Bool)
  ; smt-cons: Boolean
  (eo.Boolean (eo.Boolean.arg1 Bool))
  ; smt-cons: Numeral
  (eo.Numeral (eo.Numeral.arg1 Int))
  ; smt-cons: Rational
  (eo.Rational (eo.Rational.arg1 Rat))
  ; smt-cons: String
  (eo.String (eo.String.arg1 String))
  ; smt-cons: Binary
  (eo.Binary (eo.Binary.arg1 Int) (eo.Binary.arg2 Int))
  ; smt-cons: Type
  (eo.Type)
  ; smt-cons: Stuck
  (eo.Stuck)
  ; smt-cons: Apply
  (eo.Apply (eo.Apply.arg1 eo.Term) (eo.Apply.arg2 eo.Term))
  ; smt-cons: FunType
  (eo.FunType)
  ; smt-cons: Var
  (eo.Var (eo.Var.arg1 String) (eo.Var.arg2 eo.Term))
  ; smt-cons: Datatype
  (eo.Datatype (eo.Datatype.arg1 String) (eo.Datatype.arg2 dt.Datatype))
  ; smt-cons: DtCons
  (eo.DtCons (eo.DtCons.arg1 String) (eo.DtCons.arg2 dt.Datatype) (eo.DtCons.arg3 Int))
  ; smt-cons: DtSel
  (eo.DtSel (eo.DtSel.arg1 String) (eo.DtSel.arg2 dt.Datatype) (eo.DtSel.arg3 Int) (eo.DtSel.arg4 Int))
  ; user-decl: not
  (eo.not)
  ; user-decl: and
  (eo.and)
  ; user-decl: =
  (eo.=)

  )
  (
  ; smt-cons: Map
  (vsm.Map (vsm.Map.arg1 msm.Map))
  ; smt-cons: Term
  (vsm.Term (vsm.Term.arg1 eo.Term))
  ; smt-cons: Apply
  (vsm.Apply (vsm.Apply.arg1 vsm.Value) (vsm.Apply.arg2 vsm.Value))
  ; smt-cons: NotValue
  (vsm.NotValue)

  )
  (
  ; smt-cons: cons
  (msm.cons (msm.cons.arg1 vsm.Value) (msm.cons.arg2 vsm.Value) (msm.cons.arg3 msm.Map))
  ; smt-cons: default
  (msm.default (msm.default.arg1 vsm.Value))

  )
  (
  (ssm.None)

  )
  (
  (sm.None)

  )
  (
  (tsm.None)

  )
  (
  (dt.null)
  (dt.sum (dt.sum.arg1 dtc.DatatypeCons) (dt.sum.arg2 dt.Datatype))
  )
  (
  (dtc.unit)
  (dtc.cons (dtc.cons.arg1 tsm.Type) (dtc.cons.arg2 dtc.DatatypeCons))
  )
  )
)

(define-fun teq ((x eo.Term) (y eo.Term)) Bool (= x y))
(define-fun Teq ((x tsm.Type) (y tsm.Type)) Bool (= x y))
(define-fun veq ((x vsm.Value) (y vsm.Value)) Bool (= x y))

; forward declarations
(declare-fun texists (String tsm.Type sm.Term) vsm.Value)
(declare-fun tforall (String tsm.Type sm.Term) vsm.Value)
(declare-fun tchoice (String tsm.Type sm.Term) vsm.Value)
(declare-fun tlambda (String tsm.Type sm.Term) vsm.Value)
  
;;; Relevant definitions

; program: $eo_proven
(define-fun $eo_proven ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite ((_ is eo.$eo_pf) x1)
    (eo.$eo_pf.arg1 x1)
    eo.Stuck)))

; fwd-decl: $eo_typeof
(declare-fun $eo_typeof (eo.Term) eo.Term)

; program: $smtx_pow2
(declare-fun $smtx_pow2 (Int) Int)
(assert (! (forall ((x1 Int))
  (! (= ($smtx_pow2 x1)
    (ite (zleq x1 0) 1 (zmult 2 ($smtx_pow2 (zplus x1 (zneg 1)))))
) :pattern (($smtx_pow2 x1)))) :named sm.axiom.$smtx_pow2))

(define-fun $eo_Bool () eo.Term eo.Bool)
; program: $eo_bool
(define-fun $eo_bool ((x1 Bool)) eo.Term
    (eo.Boolean x1)
)

; program: $eo_numeral
(define-fun $eo_numeral ((x1 Int)) eo.Term
    (eo.Numeral x1)
)

; program: $eo_rational
(define-fun $eo_rational ((x1 Rat)) eo.Term
    (eo.Rational x1)
)

; program: $eo_string
(define-fun $eo_string ((x1 String)) eo.Term
    (eo.String x1)
)

; program: $eo_binary
(define-fun $eo_binary ((x1 Int) (x2 Int)) eo.Term
    (eo.Binary x1 x2)
)

(define-fun $eo_Type () eo.Term eo.Type)
(define-fun $eo_stuck () eo.Term eo.Stuck)
; program: $eo_apply
(define-fun $eo_apply ((x1 eo.Term) (x2 eo.Term)) eo.Term
    (eo.Apply x1 x2)
)

(define-fun $eo_fun_type () eo.Term eo.FunType)
; program: $eo_Var
(define-fun $eo_Var ((x1 String) (x2 eo.Term)) eo.Term
    (eo.Var x1 x2)
)

; program: $eo_Datatype
(define-fun $eo_Datatype ((x1 String) (x2 dt.Datatype)) eo.Term
    (eo.Datatype x1 x2)
)

; program: $eo_DtCons
(define-fun $eo_DtCons ((x1 String) (x2 dt.Datatype) (x3 Int)) eo.Term
    (eo.DtCons x1 x2 x3)
)

; program: $eo_DtSel
(define-fun $eo_DtSel ((x1 String) (x2 dt.Datatype) (x3 Int) (x4 Int)) eo.Term
    (eo.DtSel x1 x2 x3 x4)
)

; program: $eo_mk_apply
(define-fun $eo_mk_apply ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite true
    (eo.Apply x1 x2)
    eo.Stuck)))

; program: $eo_binary_mod_w
(define-fun $eo_binary_mod_w ((x1 Int) (x2 Int)) eo.Term
    (eo.Binary x1 (mod x2 ($smtx_pow2 x1)))
)

; program: $eo_requires
(define-fun $eo_requires ((x1 eo.Term) (x2 eo.Term) (x3 eo.Term)) eo.Term
    (ite (teq x1 x2) (ite (not (teq x1 eo.Stuck)) x3 eo.Stuck) eo.Stuck)
)

; program: $eo_len
(define-fun $eo_len ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite ((_ is eo.String) x1)
    (eo.Numeral (str.len (eo.String.arg1 x1)))
  (ite ((_ is eo.Binary) x1)
    (eo.Numeral (eo.Binary.arg1 x1))
    eo.Stuck))))

; fwd-decl: $smtx_hash
(declare-fun $smtx_hash (eo.Term) Int)

; fwd-decl: $eo_reverse_hash
(declare-fun $eo_reverse_hash (Int) eo.Term)

; fwd-decl: $eo_typeof_main
(declare-fun $eo_typeof_main (eo.Term) eo.Term)

; fwd-decl: $eo_lit_type_Numeral
(declare-fun $eo_lit_type_Numeral (eo.Term) eo.Term)

; fwd-decl: $eo_lit_type_Rational
(declare-fun $eo_lit_type_Rational (eo.Term) eo.Term)

; fwd-decl: $eo_lit_type_Binary
(declare-fun $eo_lit_type_Binary (eo.Term) eo.Term)

; fwd-decl: $eo_lit_type_String
(declare-fun $eo_lit_type_String (eo.Term) eo.Term)

; program: $eo_typeof
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_typeof x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite ((_ is eo.Boolean) x1)
    eo.Bool
  (ite ((_ is eo.Numeral) x1)
    ($eo_lit_type_Numeral (eo.Numeral (eo.Numeral.arg1 x1)))
  (ite ((_ is eo.Rational) x1)
    ($eo_lit_type_Rational (eo.Rational (eo.Rational.arg1 x1)))
  (ite ((_ is eo.String) x1)
    ($eo_lit_type_String (eo.String (eo.String.arg1 x1)))
  (ite ((_ is eo.Binary) x1)
    ($eo_lit_type_Binary (eo.Binary (eo.Binary.arg1 x1) (eo.Binary.arg2 x1)))
  (ite ((_ is eo.Var) x1)
    (eo.Var.arg2 x1)
  (ite ((_ is eo.Datatype) x1)
    eo.Type
  (ite true
    ($eo_typeof_main x1)
    eo.Stuck)))))))))) :pattern (($eo_typeof x1)))) :named sm.axiom.$eo_typeof))

; fwd-decl: $eo_dt_selectors_main
(declare-fun $eo_dt_selectors_main (eo.Term) eo.Term)

; program: $eo_datatype_cons_selectors_rec
(declare-fun $eo_datatype_cons_selectors_rec (String dt.Datatype Int dt.Datatype Int Int) eo.Term)
(assert (! (forall ((x1 String) (x2 dt.Datatype) (x3 Int) (x4 dt.Datatype) (x5 Int) (x6 Int))
  (! (= ($eo_datatype_cons_selectors_rec x1 x2 x3 x4 x5 x6)
  (ite false
    eo.Stuck
  (ite (and ((_ is dt.sum) x4) (= (dt.sum.arg1 x4) dtc.unit) (= x5 0))
    eo.$eo_List_nil
  (ite (and ((_ is dt.sum) x4) ((_ is dtc.cons) (dt.sum.arg1 x4)) (= x5 0))
    ($eo_mk_apply (eo.Apply eo.$eo_List_cons (eo.DtSel x1 x2 x3 x6)) ($eo_datatype_cons_selectors_rec x1 x2 x3 (dt.sum.arg2 x4) 0 (zplus x6 1)))
  (ite ((_ is dt.sum) x4)
    ($eo_datatype_cons_selectors_rec x1 x2 x3 (dt.sum.arg2 x4) (zplus x5 (zneg 1)) x6)
    eo.Stuck))))) :pattern (($eo_datatype_cons_selectors_rec x1 x2 x3 x4 x5 x6)))) :named sm.axiom.$eo_datatype_cons_selectors_rec))

; program: $eo_dt_selectors
(define-fun $eo_dt_selectors ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite ((_ is eo.DtCons) x1)
    ($eo_datatype_cons_selectors_rec (eo.DtCons.arg1 x1) (eo.DtCons.arg2 x1) (eo.DtCons.arg3 x1) (eo.DtCons.arg2 x1) (eo.DtCons.arg3 x1) 0)
  (ite true
    ($eo_dt_selectors_main x1)
    eo.Stuck))))

; program: $mk_symm
(define-fun $mk_symm ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) (= (eo.Apply.arg1 (eo.Apply.arg1 x1)) eo.=))
    (eo.Apply (eo.Apply eo.= (eo.Apply.arg2 x1)) (eo.Apply.arg2 (eo.Apply.arg1 x1)))
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg2 x1)) ((_ is eo.Apply) (eo.Apply.arg1 (eo.Apply.arg2 x1))) (= (eo.Apply.arg1 (eo.Apply.arg1 (eo.Apply.arg2 x1))) eo.=) (= (eo.Apply.arg1 x1) eo.not))
    (eo.Apply eo.not (eo.Apply (eo.Apply eo.= (eo.Apply.arg2 (eo.Apply.arg2 x1))) (eo.Apply.arg2 (eo.Apply.arg1 (eo.Apply.arg2 x1)))))
    eo.Stuck))))

; program: $eo_prog_symm
(define-fun $eo_prog_symm ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite ((_ is eo.$eo_pf) x1)
    ($mk_symm (eo.$eo_pf.arg1 x1))
    eo.Stuck)))

; program: $eo_typeof_apply
(define-fun $eo_typeof_apply ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) ((_ is eo.FunType) (eo.Apply.arg1 (eo.Apply.arg1 x1))))
    ($eo_requires (eo.Apply.arg2 (eo.Apply.arg1 x1)) x2 (eo.Apply.arg2 x1))
    eo.Stuck)))

; program: $eo_typeof_=
(define-fun $eo_typeof_= ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    (eo.Apply (eo.Apply eo.FunType x1) eo.Bool)
    eo.Stuck)))

; program: $eo_typeof_fun_type
(define-fun $eo_typeof_fun_type ((x1 eo.Term) (x2 eo.Term)) eo.Term
  (ite (or (= x1 eo.Stuck) (= x2 eo.Stuck))
    eo.Stuck
  (ite (and (= x1 eo.Type) (= x2 eo.Type))
    eo.Type
    eo.Stuck)))

; program: $eo_typeof_main
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_typeof_main x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite (= x1 eo.Type)
    eo.Type
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) ((_ is eo.FunType) (eo.Apply.arg1 (eo.Apply.arg1 x1))))
    ($eo_typeof_fun_type ($eo_typeof (eo.Apply.arg2 (eo.Apply.arg1 x1))) ($eo_typeof (eo.Apply.arg2 x1)))
  (ite (= x1 eo.Bool)
    eo.Type
  (ite (= x1 (eo.Boolean true))
    eo.Bool
  (ite (= x1 (eo.Boolean false))
    eo.Bool
  (ite (= x1 eo.$eo_List)
    eo.Type
  (ite (= x1 eo.$eo_List_nil)
    eo.$eo_List
  (ite (and ((_ is eo.Apply) x1) (= (eo.Apply.arg1 x1) eo.$eo_List_cons))
    (eo.Apply (eo.Apply eo.FunType eo.$eo_List) eo.$eo_List)
  (ite (= x1 eo.Int)
    eo.Type
  (ite (= x1 eo.Real)
    eo.Type
  (ite (= x1 eo.BitVec)
    (eo.Apply (eo.Apply eo.FunType eo.Int) eo.Type)
  (ite (= x1 eo.Char)
    eo.Type
  (ite (= x1 eo.Seq)
    (eo.Apply (eo.Apply eo.FunType eo.Type) eo.Type)
  (ite (= x1 eo.not)
    (eo.Apply (eo.Apply eo.FunType eo.Bool) eo.Bool)
  (ite (= x1 eo.and)
    (eo.Apply (eo.Apply eo.FunType eo.Bool) (eo.Apply (eo.Apply eo.FunType eo.Bool) eo.Bool))
  (ite (and ((_ is eo.Apply) x1) (= (eo.Apply.arg1 x1) eo.=))
    ($eo_typeof_= ($eo_typeof (eo.Apply.arg2 x1)))
  (ite ((_ is eo.Apply) x1)
    ($eo_typeof_apply ($eo_typeof (eo.Apply.arg1 x1)) ($eo_typeof (eo.Apply.arg2 x1)))
    eo.Stuck))))))))))))))))))) :pattern (($eo_typeof_main x1)))) :named sm.axiom.$eo_typeof_main))

; program: $eo_lit_type_Numeral
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_lit_type_Numeral x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    eo.Int
    eo.Stuck))) :pattern (($eo_lit_type_Numeral x1)))) :named sm.axiom.$eo_lit_type_Numeral))

; program: $eo_lit_type_Rational
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_lit_type_Rational x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    eo.Real
    eo.Stuck))) :pattern (($eo_lit_type_Rational x1)))) :named sm.axiom.$eo_lit_type_Rational))

; program: $eo_lit_type_Binary
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_lit_type_Binary x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eo_mk_apply eo.BitVec ($eo_len x1))
    eo.Stuck))) :pattern (($eo_lit_type_Binary x1)))) :named sm.axiom.$eo_lit_type_Binary))

; program: $eo_lit_type_String
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_lit_type_String x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    (eo.Apply eo.Seq eo.Char)
    eo.Stuck))) :pattern (($eo_lit_type_String x1)))) :named sm.axiom.$eo_lit_type_String))

; program: $eo_dt_selectors_main
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_dt_selectors_main x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
    eo.Stuck)) :pattern (($eo_dt_selectors_main x1)))) :named sm.axiom.$eo_dt_selectors_main))

; fwd-decl: $eo_model_sat
(declare-fun $eo_model_sat (eo.Term) eo.Term)

; fwd-decl: $eo_model_unsat
(declare-fun $eo_model_unsat (eo.Term) eo.Term)

; program: $mk_vsm_bool
(define-fun $mk_vsm_bool ((x1 Bool)) vsm.Value
    (vsm.Term (eo.Boolean x1))
)

; fwd-decl: $smtx_value_hash
(declare-fun $smtx_value_hash (vsm.Value) Int)

; fwd-decl: $smtx_reverse_value_hash
(declare-fun $smtx_reverse_value_hash (Int) vsm.Value)

; program: $smtx_msm_lookup
(declare-fun $smtx_msm_lookup (msm.Map vsm.Value) vsm.Value)
(assert (! (forall ((x1 msm.Map) (x2 vsm.Value))
  (! (= ($smtx_msm_lookup x1 x2)
  (ite (and ((_ is msm.cons) x1) (= x2 (msm.cons.arg1 x1)))
    (msm.cons.arg2 x1)
  (ite ((_ is msm.cons) x1)
    ($smtx_msm_lookup (msm.cons.arg3 x1) x2)
    (msm.default.arg1 x1)
))) :pattern (($smtx_msm_lookup x1 x2)))) :named sm.axiom.$smtx_msm_lookup))

; program: $smtx_is_atomic_term_value
(define-fun $smtx_is_atomic_term_value ((x1 eo.Term)) Bool
  (ite ((_ is eo.Boolean) x1)
    true
  (ite ((_ is eo.Numeral) x1)
    true
  (ite ((_ is eo.Rational) x1)
    true
  (ite ((_ is eo.String) x1)
    true
  (ite ((_ is eo.Binary) x1)
    (and (<= 0 (eo.Binary.arg1 x1)) (teq (eo.Binary (eo.Binary.arg1 x1) (eo.Binary.arg2 x1)) (eo.Binary (eo.Binary.arg1 x1) (mod (eo.Binary.arg2 x1) ($smtx_pow2 (eo.Binary.arg1 x1))))))
    false
))))))

; fwd-decl: $smtx_model_eval
(declare-fun $smtx_model_eval (eo.Term) vsm.Value)

; program: $smtx_model_eval_apply
(define-fun $smtx_model_eval_apply ((x1 vsm.Value) (x2 vsm.Value)) vsm.Value
  (ite ((_ is vsm.Apply) x1)
    (vsm.Apply (vsm.Apply (vsm.Apply.arg1 x1) (vsm.Apply.arg2 x1)) x2)
  (ite ((_ is vsm.Map) x1)
    ($smtx_msm_lookup (vsm.Map.arg1 x1) x2)
    vsm.NotValue
)))

; program: $smtx_model_eval_=
(define-fun $smtx_model_eval_= ((x1 vsm.Value) (x2 vsm.Value)) vsm.Value
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.Boolean) (vsm.Term.arg1 x1)) ((_ is vsm.Term) x2) ((_ is eo.Boolean) (vsm.Term.arg1 x2)))
    (vsm.Term (eo.Boolean (teq (eo.Boolean (eo.Boolean.arg1 (vsm.Term.arg1 x1))) (eo.Boolean (eo.Boolean.arg1 (vsm.Term.arg1 x2))))))
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.Boolean) (vsm.Term.arg1 x1)))
    vsm.NotValue
  (ite (and ((_ is vsm.Term) x2) ((_ is eo.Boolean) (vsm.Term.arg1 x2)))
    vsm.NotValue
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.Numeral) (vsm.Term.arg1 x1)) ((_ is vsm.Term) x2) ((_ is eo.Numeral) (vsm.Term.arg1 x2)))
    (vsm.Term (eo.Boolean (teq (eo.Numeral (eo.Numeral.arg1 (vsm.Term.arg1 x1))) (eo.Numeral (eo.Numeral.arg1 (vsm.Term.arg1 x2))))))
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.Numeral) (vsm.Term.arg1 x1)))
    vsm.NotValue
  (ite (and ((_ is vsm.Term) x2) ((_ is eo.Numeral) (vsm.Term.arg1 x2)))
    vsm.NotValue
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.Rational) (vsm.Term.arg1 x1)) ((_ is vsm.Term) x2) ((_ is eo.Rational) (vsm.Term.arg1 x2)))
    (vsm.Term (eo.Boolean (teq (eo.Rational (eo.Rational.arg1 (vsm.Term.arg1 x1))) (eo.Rational (eo.Rational.arg1 (vsm.Term.arg1 x2))))))
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.Rational) (vsm.Term.arg1 x1)))
    vsm.NotValue
  (ite (and ((_ is vsm.Term) x2) ((_ is eo.Rational) (vsm.Term.arg1 x2)))
    vsm.NotValue
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.String) (vsm.Term.arg1 x1)) ((_ is vsm.Term) x2) ((_ is eo.String) (vsm.Term.arg1 x2)))
    (vsm.Term (eo.Boolean (teq (eo.String (eo.String.arg1 (vsm.Term.arg1 x1))) (eo.String (eo.String.arg1 (vsm.Term.arg1 x2))))))
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.String) (vsm.Term.arg1 x1)))
    vsm.NotValue
  (ite (and ((_ is vsm.Term) x2) ((_ is eo.String) (vsm.Term.arg1 x2)))
    vsm.NotValue
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.Binary) (vsm.Term.arg1 x1)) ((_ is vsm.Term) x2) ((_ is eo.Binary) (vsm.Term.arg1 x2)))
    (ite (zeq (eo.Binary.arg1 (vsm.Term.arg1 x1)) (eo.Binary.arg1 (vsm.Term.arg1 x2))) (vsm.Term (eo.Boolean (teq (eo.Binary (eo.Binary.arg1 (vsm.Term.arg1 x1)) (eo.Binary.arg2 (vsm.Term.arg1 x1))) (eo.Binary (eo.Binary.arg1 (vsm.Term.arg1 x2)) (eo.Binary.arg2 (vsm.Term.arg1 x2)))))) vsm.NotValue)
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.Binary) (vsm.Term.arg1 x1)))
    vsm.NotValue
  (ite (and ((_ is vsm.Term) x2) ((_ is eo.Binary) (vsm.Term.arg1 x2)))
    vsm.NotValue
  (ite (= x1 vsm.NotValue)
    vsm.NotValue
  (ite (= x2 vsm.NotValue)
    vsm.NotValue
    (vsm.Term (eo.Boolean (veq x1 x2)))
))))))))))))))))))

; fwd-decl: $smtx_typeof_value
(declare-fun $smtx_typeof_value (vsm.Value) tsm.Type)

; fwd-decl: $smtx_substitute
(declare-fun $smtx_substitute (String tsm.Type vsm.Value sm.Term) eo.Term)

; program: $smtx_model_eval_not
(define-fun $smtx_model_eval_not ((x1 vsm.Value)) vsm.Value
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.Boolean) (vsm.Term.arg1 x1)))
    (vsm.Term (eo.Boolean (not (eo.Boolean.arg1 (vsm.Term.arg1 x1)))))
    vsm.NotValue
))

; program: $smtx_model_eval_and
(define-fun $smtx_model_eval_and ((x1 vsm.Value) (x2 vsm.Value)) vsm.Value
  (ite (and ((_ is vsm.Term) x1) ((_ is eo.Boolean) (vsm.Term.arg1 x1)) ((_ is vsm.Term) x2) ((_ is eo.Boolean) (vsm.Term.arg1 x2)))
    (vsm.Term (eo.Boolean (and (eo.Boolean.arg1 (vsm.Term.arg1 x1)) (eo.Boolean.arg1 (vsm.Term.arg1 x2)))))
    vsm.NotValue
))

; program: $smtx_model_eval
(assert (! (forall ((x1 eo.Term))
  (! (= ($smtx_model_eval x1)
  (ite (and ((_ is eo.Apply) x1) (= (eo.Apply.arg1 x1) eo.not))
    ($smtx_model_eval_not ($smtx_model_eval (eo.Apply.arg2 x1)))
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) (= (eo.Apply.arg1 (eo.Apply.arg1 x1)) eo.and))
    ($smtx_model_eval_and ($smtx_model_eval (eo.Apply.arg2 (eo.Apply.arg1 x1))) ($smtx_model_eval (eo.Apply.arg2 x1)))
  (ite (and ((_ is eo.Apply) x1) ((_ is eo.Apply) (eo.Apply.arg1 x1)) (= (eo.Apply.arg1 (eo.Apply.arg1 x1)) eo.=))
    ($smtx_model_eval_= ($smtx_model_eval (eo.Apply.arg2 (eo.Apply.arg1 x1))) ($smtx_model_eval (eo.Apply.arg2 x1)))
  (ite ((_ is eo.Apply) x1)
    ($smtx_model_eval_apply ($smtx_model_eval (eo.Apply.arg1 x1)) ($smtx_model_eval (eo.Apply.arg2 x1)))
    (ite ($smtx_is_atomic_term_value x1) (vsm.Term x1) (ite (not (teq ($eo_dt_selectors x1) eo.Stuck)) (vsm.Apply (vsm.Term x1) vsm.NotValue) vsm.NotValue))
))))) :pattern (($smtx_model_eval x1)))) :named sm.axiom.$smtx_model_eval))

; program: $eo_model_sat
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_model_sat x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    (ite (veq ($smtx_model_eval x1) (vsm.Term (eo.Boolean true))) (eo.Boolean true) (eo.Boolean false))
    eo.Stuck))) :pattern (($eo_model_sat x1)))) :named sm.axiom.$eo_model_sat))

; program: $eo_model_unsat
(assert (! (forall ((x1 eo.Term))
  (! (= ($eo_model_unsat x1)
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    (ite (veq ($smtx_model_eval x1) (vsm.Term (eo.Boolean false))) (eo.Boolean true) (eo.Boolean false))
    eo.Stuck))) :pattern (($eo_model_unsat x1)))) :named sm.axiom.$eo_model_unsat))

; program: $mk_sm_const
(define-fun $mk_sm_const ((x1 vsm.Value) (x2 tsm.Type)) vsm.Value
    x1
)

; program: $eovc_symm
(define-fun $eovc_symm ((x1 eo.Term)) eo.Term
  (ite (= x1 eo.Stuck)
    eo.Stuck
  (ite true
    ($eo_requires ($eo_typeof x1) eo.Bool ($eo_requires ($eo_model_sat x1) (eo.Boolean true) ($eo_requires ($eo_typeof ($eo_prog_symm (eo.$eo_pf x1))) eo.Bool ($eo_requires ($eo_model_unsat ($eo_prog_symm (eo.$eo_pf x1))) (eo.Boolean true) (eo.Boolean true)))))
    eo.Stuck)))



;;; Meta-level properties of models

; axiom for hash
; note: this implies that $smtx_hash is injective, which implies $eo_hash is injective.
(assert (! (forall ((x eo.Term))
    (! (= ($eo_reverse_hash ($smtx_hash x)) x) :pattern (($smtx_hash x)))) :named eo.hash_injective))
(assert (! (forall ((x vsm.Value))
    (! (= ($smtx_reverse_value_hash ($smtx_value_hash x)) x) :pattern (($smtx_value_hash x)))) :named smtx.hash_injective))

; true iff there exists a value of type T that when substituted into F
; is evaluated as tgt. Note that we do not check the type of T here,
; instead $smtx_substitute will generate terms ($sm_Const v T), which
; only evaluate to v if it is of type T.
(define-fun texists_total ((s String) (T tsm.Type) (F sm.Term) (tgt vsm.Value)) Bool
  (exists ((v vsm.Value))
    (= ($smtx_model_eval ($smtx_substitute s T ($mk_sm_const v T) F)) tgt)))

; true iff all values of type T when substituted into F are evaluated as tgt.
(define-fun tforall_total ((s String) (T tsm.Type) (F sm.Term) (tgt vsm.Value)) Bool
  (forall ((v vsm.Value))
    (= ($smtx_model_eval ($smtx_substitute s T ($mk_sm_const v T) F)) tgt)))

; exists
(assert (forall ((s String) (T tsm.Type) (F sm.Term))
  (= (texists s T F)
     (ite (texists_total s T F ($mk_vsm_bool true)) ($mk_vsm_bool true)
     (ite (tforall_total s T F ($mk_vsm_bool false)) ($mk_vsm_bool false)
       vsm.NotValue)))))
  
; forall
(assert (forall ((s String) (T tsm.Type) (F sm.Term))
  (= (tforall s T F)
     (ite (texists_total s T F ($mk_vsm_bool false)) ($mk_vsm_bool false)
     (ite (tforall_total s T F ($mk_vsm_bool true)) ($mk_vsm_bool true)
       vsm.NotValue)))))

; choice
; If there exists a value making the existential true, we can assume
; that substituting with choice also makes it true.
(assert (forall ((s String) (T tsm.Type) (F sm.Term) (v vsm.Value))
  (=> (texists_total s T F ($mk_vsm_bool true))
      (= ($smtx_model_eval ($smtx_substitute s T ($mk_sm_const (tchoice s T F) T) F))
         ($mk_vsm_bool true)))))

;;; The verification condition

;;;; final verification condition for $eovc_symm
(synth-fun arg_F () eo.Term
  ((G_Start eo.Term) (G_eo.Term eo.Term) (G_Bool Bool) (G_Int Int) (G_RegLan RegLan) (G_Int_C Int) (G_Rat Rat) (G_String String) (T_Type eo.Term) (T_$eo_Proof eo.Term) (T_SmtType eo.Term) (T_Fun eo.Term) (T_Int eo.Term) (T_$eo_List eo.Term) (T_SmtTerm eo.Term) (T_Bool eo.Term) (T_Real eo.Term) (T_Seq eo.Term) (T_BitVec eo.Term)) (
  (G_Start eo.Term (T_Bool))
  (G_eo.Term eo.Term (eo.Type eo.FunType (eo.Var G_String G_eo.Term) T_Type T_Bool T_Fun T_SmtTerm T_SmtType T_$eo_Proof T_Int T_Real T_BitVec T_Seq T_$eo_List T_Type T_$eo_Proof T_SmtType T_Fun T_Int T_$eo_List T_SmtTerm T_Bool T_Real T_Seq T_BitVec ))
  (G_Bool Bool (true false))
  (G_Int Int (0 (- G_Int_C) G_Int_C))
  (G_RegLan RegLan (re.all re.none (str.to_re G_String) (re.union G_RegLan G_RegLan)))
  (G_Int_C Int (1 (+ G_Int_C 1)))
  (G_Rat Rat (0.0 (/ G_Int_C G_Int_C) (- (/ G_Int_C G_Int_C))))
  (G_String String ("" (str.++ G_String "A") (str.++ G_String "B")))
  (T_Type eo.Term (eo.$eo_Proof eo.Int eo.Real (eo.Apply eo.BitVec T_Int) eo.Char (eo.Apply eo.Seq T_Type) eo.$eo_List eo.Bool ))
  (T_$eo_Proof eo.Term ((eo.$eo_pf G_eo.Term) ))
  (T_SmtType eo.Term (T_Type ))
  (T_Fun eo.Term (eo.BitVec eo.Seq eo.$eo_List_cons eo.not eo.and eo.= ))
  (T_Int eo.Term ((eo.Numeral G_Int) ))
  (T_$eo_List eo.Term (eo.$eo_List_nil (eo.Apply (eo.Apply eo.$eo_List_cons G_eo.Term) T_$eo_List) ))
  (T_SmtTerm eo.Term (T_Bool T_Int T_Real T_Seq T_BitVec ))
  (T_Bool eo.Term ((eo.Boolean G_Bool) (eo.Apply eo.not T_Bool) (eo.Apply (eo.Apply eo.and T_Bool) T_Bool) (eo.Apply (eo.Apply eo.= T_SmtTerm) T_SmtTerm) ))
  (T_Real eo.Term ((eo.Rational G_Rat) ))
  (T_Seq eo.Term ((eo.String G_String) ))
  (T_BitVec eo.Term ((eo.Binary G_Int G_Int) ))
)
)
(constraint (= ($eovc_symm arg_F) (eo.Boolean true)))
(check-synth)

