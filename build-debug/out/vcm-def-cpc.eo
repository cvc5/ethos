; trim-defs: $eovc_symm
; #trim-defs: 42
(declare-const $eo_Proof Type)
(declare-parameterized-const $eo_pf ((F Bool :opaque)) $eo_Proof)
(program $eo_proven ((F Bool))
  :signature ($eo_Proof) Bool
  (
  (($eo_proven ($eo_pf F)) F)
  )
)
(declare-const Int Type)
(declare-consts <numeral> Int)
(define $eo_Numeral () Int)
(declare-const Real Type)
(declare-consts <rational> Real)
(define $eo_Rational () Real)
(declare-const BitVec (-> Int Type))
(declare-consts <binary> (BitVec (eo::len eo::self)))
(define $eo_Binary () (BitVec 1))
(declare-const Char Type)
(declare-const Seq (-> Type Type))
(declare-consts <string> (Seq Char))
(define $eo_String () (Seq Char))
(declare-const $eo_List Type)
(declare-const $eo_List_nil $eo_List)
(declare-parameterized-const $eo_List_cons ((T Type :implicit))
  (-> T $eo_List $eo_List))
(program $eo_typeof ((T Type)) :signature (T) Type)
; This file defines the semantics of Eunoia operators that require calling
; SMT-LIB like computations.

; Embedding into SMT operators, which defines $smt_builtin_*, $smt_apply_* etc.
; This file defines a deep embedding of SMT-LIB into Eunoia.
; It has the following uses:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin
;    Eunoia functions, e.g. $eo_add.
; 2. It is used to define the end signature for defining the model semantics of
;    SMT-LIB.

; The type of $smt_apply_* terms.
; If a term has this type, we know it is an SMT-LIB type,
; but we don't know which one from ordinary type checking.
(declare-const $smt_BuiltinType Type)

;;; Deep embedding of SMT-LIB operator applications into Eunoia

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_type_0
  (($smt_id Type :implicit) (op $smt_id :opaque))
  Type)
(declare-parameterized-const $smt_type_1
  (($smt_id Type :implicit) (W1 Type :implicit) (op $smt_id :opaque) (x1 W1 :opaque))
  Type)
(declare-parameterized-const $smt_type_2
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque))
  Type)
(declare-parameterized-const $smt_apply_0
  (($smt_id Type :implicit) (op $smt_id :opaque))
  $smt_BuiltinType)
(declare-parameterized-const $smt_apply_1
  (($smt_id Type :implicit) (W1 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_2
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_3
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_4
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit)
   (W3 Type :implicit) (W4 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_5
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit)
   (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque) (x5 W5 :opaque)) $smt_BuiltinType)

(define $smt_builtin_Bool () ($smt_type_0 "Bool"))
(define $smt_builtin_Int () ($smt_type_0 "Int"))
(define $smt_builtin_Real () ($smt_type_0 "Real"))
; Assumes Rat is defined as Real.
(define $smt_builtin_Rat () ($smt_type_0 "Rat"))
(define $smt_builtin_String () ($smt_type_0 "String"))
(define $smt_builtin_RegLan () ($smt_type_0 "RegLan"))
(define $smt_builtin_true () ($smt_apply_0 "true"))
(define $smt_builtin_false () ($smt_apply_0 "false"))
(define $smt_builtin_ite ((W Type :implicit) (b $smt_builtin_Bool) (x1 W) (x2 W)) ($smt_apply_3 "ite" b x1 x2))
(define $smt_builtin_z_zero () ($smt_apply_0 "0"))
(define $smt_builtin_z_one () ($smt_apply_0 "1"))
(define $smt_builtin_z_two () ($smt_apply_0 "2"))
(define $smt_builtin_z_max_code () ($smt_apply_0 "196608"))
(define $smt_builtin_z_max_width () ($smt_apply_0 "4294967296"))
;(define $smt_builtin_q_zero () ($smt_apply_0 "0/1"))
(define $smt_builtin_q_zero () ($smt_apply_2 "mk_rational" $smt_builtin_z_zero $smt_builtin_z_one))
(define $smt_builtin_str_empty () ($smt_apply_0 """"""))
(define $smt_builtin_str_tuple_name () ($smt_apply_0 """@Tuple"""))
(define $smt_builtin_str_vname () ($smt_apply_0 """@x"""))
(define $smt_builtin_str_= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "streq" x1 x2))
(define $smt_builtin_not ((b $smt_builtin_Bool)) ($smt_apply_1 "not" b))
(define $smt_builtin_and ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "and" b1 b2))
(define $smt_builtin_or ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "or" b1 b2))
(define $smt_builtin_xor ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "xor" b1 b2))
(define $smt_builtin_iff ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "iff" b1 b2))
; Integer operators
; These assume zeq, zleq, zlt, zplus, zmult, zneg are defined as =, <=, <, +, *, -
(define $smt_builtin_z_= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zeq" x1 x2))
(define $smt_builtin_z_<= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zleq" x1 x2))
(define $smt_builtin_z_< ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zlt" x1 x2))
(define $smt_builtin_z_+ ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zplus" x1 x2))
(define $smt_builtin_z_* ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zmult" x1 x2))
(define $smt_builtin_z_neg ((W Type :implicit) (x1 W)) ($smt_apply_1 "zneg" x1))
(define $smt_builtin_z_- ((W Type :implicit) (x1 W) (x2 W)) ($smt_builtin_z_+ x1 ($smt_builtin_z_neg x2)))
(define $smt_builtin_z_pow2 ((W Type :implicit) (x1 W)) ($smt_apply_1 "int.pow2" x1))
; Real operators
; These assume qleq, qlt, qplus, qmult, qneg are defined as <=, <, +, *, -
(define $smt_builtin_q_= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qeq" x1 x2))
(define $smt_builtin_q_<= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qleq" x1 x2))
(define $smt_builtin_q_< ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qlt" x1 x2))
(define $smt_builtin_q_+ ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qplus" x1 x2))
(define $smt_builtin_q_* ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qmult" x1 x2))
(define $smt_builtin_q_neg ((W Type :implicit) (x1 W)) ($smt_apply_1 "qneg" x1))
(define $smt_builtin_q_- ((W Type :implicit) (x1 W) (x2 W)) ($smt_builtin_q_+ x1 ($smt_builtin_q_neg x2)))
; other arithmetic
(define $smt_builtin_div ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "div" x1 x2))
(define $smt_builtin_mod ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "mod" x1 x2))
(define $smt_builtin_z_neg_one () ($smt_builtin_z_neg $smt_builtin_z_one))
(define $smt_builtin_z_inc ((W Type :implicit) (x1 W)) ($smt_builtin_z_+ x1 $smt_builtin_z_one))
(define $smt_builtin_z_dec ((W Type :implicit) (x1 W)) ($smt_builtin_z_+ x1 $smt_builtin_z_neg_one))

; macro for applying (+ t1 t2 t3), which is (+ t1 (+ t2 t3))
(define $smt_apply_nary_3
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit)
   (op $smt_id) (x1 W1) (x2 W2) (x3 W3))
  ($smt_apply_2 op x1 ($smt_apply_2 op x2 x3)))

;;; Defining parametric bitvector operators

; The operators in this section are needed to reason about the parametric
; operations on the Eunoia binary literal type.

; program: $smtx_pow2
; return: >
;   The integer value of 2 raised to the i^th power.
; note: We expect i to be non-negative.
(program $smtx_pow2 ((i $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_pow2 i) ($smt_builtin_z_pow2 i))
;    ($smt_builtin_ite ($smt_builtin_z_<= i $smt_builtin_z_zero)
;      $smt_builtin_z_one
;      ($smt_builtin_z_* $smt_builtin_z_two
;        ($smtx_pow2 ($smt_builtin_z_dec i)))))
  )
)

; program: $smtx_bit
; return: >
;   true iff the i^th bit of a binary with integer value x is set. Note this
;   method is agnostic to bitwidth.
(program $smtx_bit ((x $smt_builtin_Int) (i $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Bool
  (
  (($smtx_bit x i)
    ($smt_builtin_z_=
      $smt_builtin_z_one
      ($smt_builtin_mod ($smt_builtin_div x ($smtx_pow2 i)) $smt_builtin_z_two)))
  )
)

; program: $smtx_msb
; return: >
;   true iff the most significant bit of the binary of width w and value n is
;   set.
(program $smtx_msb ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Bool
  (
  (($smtx_msb w n) ($smtx_bit n ($smt_builtin_z_dec w)))
  )
)

; program: $smtx_binary_and_rec
; note: Helper for $smtx_binary_and below.
(program $smtx_binary_and_rec ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_and_rec w n1 n2)
      ($smt_builtin_z_+
        ($smt_builtin_ite ($smt_builtin_z_= w $smt_builtin_z_zero)
          $smt_builtin_z_zero
          ($smtx_binary_and_rec ($smt_builtin_z_dec w) n1 n2))
        ($smt_builtin_z_* ($smtx_pow2 w)
            ($smt_builtin_ite ($smt_builtin_and ($smtx_bit n1 w) ($smtx_bit n2 w)) 
              $smt_builtin_z_one 
              $smt_builtin_z_zero))))
  )
)

; program: $smtx_binary_and
; return: >
;   The integer value of the binary value obtained by taking the bitwise and of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This value will be
;   taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w, 0 <= w.
(define $smtx_binary_and
  ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  ($smt_builtin_ite ($smt_builtin_z_= w $smt_builtin_z_zero)
    $smt_builtin_z_zero
    ($smtx_binary_and_rec ($smt_builtin_z_dec w) n1 n2)))

; program: $smtx_binary_or
; return: >
;   The integer value of the binary value obtained by taking the bitwise or of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This is equal to
;   n1+n2-($smtx_binary_and w n1 n2). This value will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w, 0 <= w.
(program $smtx_binary_or ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_or w n1 n2)
    ($smt_builtin_z_+ n1 ($smt_builtin_z_- n2 ($smtx_binary_and w n1 n2))))
  )
)

; program: $smtx_binary_xor
; return: >
;   The integer value of the binary value obtained by taking the bitwise xor of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This is equal to
;   n1+n2-(2*($smtx_binary_and w n1 n2)). This value will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w, 0 <= w.
(program $smtx_binary_xor ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_xor w n1 n2)
    ($smt_builtin_z_+ n1 ($smt_builtin_z_- n2 ($smt_builtin_z_* $smt_builtin_z_two ($smtx_binary_and w n1 n2)))))
  )
)

; program: $smtx_binary_not
; return: >
;   The integer value of the binary value obtained by taking bitwise not of
;   the binary literal ($eo_binary w n). This is equal to 2^w-(1+n). This value
;   will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n < 2^w, 0 <= w.
(program $smtx_binary_not ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_not w n)
    ($smt_builtin_z_- ($smtx_pow2 w) ($smt_builtin_z_inc n)))
  )
)

; program: $smtx_binary_max
; return: >
;   The integer value of the maximum unsigned binary value of width w. This is
;   equal to 2^w-1.
(program $smtx_binary_max ((w $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_max w) ($smt_builtin_z_dec ($smtx_pow2 w)))
  )
)

; program: $smtx_binary_uts
; return: >
;   The conversion of n from unsigned to signed integer, which is
;   2*(n mod 2^w-1) - n.
(program $smtx_binary_uts ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_uts w n) 
    ($smt_builtin_z_-
      ($smt_builtin_z_* $smt_builtin_z_two
        ($smt_builtin_mod n ($smtx_pow2 ($smt_builtin_z_dec w))))
      n))
  )
)

; program: $smtx_binary_concat
; return: >
;   The integer value of the binary value obtained by concatenating binary
;   literals ($eo_binary w1 n1) and ($eo_binary w2 n2). This is equal to
;   n1*2^w2 + n2. Note the return value does not depend on w1. This value will
;   be taken modulo 2^(w1+w2).
; note: >
;   Assumes that 0 <= n1 < 2^w1, 0 <= n2 < 2^w2, 0 <= w1, 0 <= w2.
(program $smtx_binary_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_concat w1 n1 w2 n2)
    ($smt_builtin_z_+ ($smt_builtin_z_* n1 ($smtx_pow2 w2)) n2))
  )
)

; program: $smtx_binary_extract
; return: >
;   The integer value of the binary value obtained by extracting bits x1
;   through x2 (inclusive) of binary literal ($eo_binary w n). This is equal
;   to (div n 2^x1). This value will be taken modulo 2^(1+x2-x1).
; note: >
;   Assumes that 0 <= n < 2^w, 0 <= x1 <= x2 < w.
(program $smtx_binary_extract
  ((w $smt_builtin_Int) (n $smt_builtin_Int) (x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_extract w n x1 x2) ($smt_builtin_div n ($smtx_pow2 x2)))
  )
)

;;; Terms, types, datatypes

; An SMT term.
(declare-const $smt_Term Type)

; An SMT type.
(declare-const $smt_Type Type)

; A datatype constructor
(declare-const $smt_DatatypeCons Type)

; A datatype
(declare-const $smt_Datatype Type)

; utilities

; Assumes that Teq is defined to be equality over $smt_Type
(define $smt_builtin_Teq ((x1 $smt_Type) (x2 $smt_Type)) ($smt_apply_2 "Teq" x1 x2))


;;; Constructors for SMT-LIB datatypes and datatype constructors

; A constructor having no arguments
(declare-const $emb_dtc.unit $smt_DatatypeCons)
(define $dtc_unit () $emb_dtc.unit)

; A constructor having at least one argument
; It takes the type of that argument and a constructor specifying the remaining
; arguments.
(declare-parameterized-const $emb_dtc.cons
  ((T $smt_Type :opaque) (c $smt_DatatypeCons :opaque))
  $smt_DatatypeCons)
(define $dtc_cons ((T $smt_DatatypeCons) (c $smt_DatatypeCons))
  ($emb_dtc.cons T c))

; A datatype having no constructors
(declare-const $emb_dt.null $smt_Datatype)
(define $dt_null () $emb_dt.null)
  
; A datatype having at least one constructor
(declare-parameterized-const $emb_dt.sum
  ((c $smt_DatatypeCons :opaque) (d $smt_Datatype :opaque))
  $smt_Datatype)
(define $dt_sum ((c $smt_DatatypeCons) (d $smt_Datatype))
  ($emb_dt.sum c d))


; In this signature, we heavily use references to the Datatypes corresponding
; to the final deep embeddings of Eunoia terms (eo.Term).
; Opaque arguments of a symbol X will be an argument of the constructor eo.X.
; We introduce datatype constructors for this datatype ($emb_X).
; It is important that we mark their arguments as :opaque, as this
; correctly models the pattern matching in the smt-meta later.
; Note that these datatypes will be renamed and replaced by their definitions
; which is hardcoded into smt_meta.smt2.

;;; Final deep embedding datatypes

; Now, we introduce placeholders for the final deep embedding.

; A Eunoia term.
; This will be replaced by the datatype eo.Term in the final encoding.
(declare-const $eo_Term Type)

; Assumes that teq is defined to be equality over eo.Term
(define $smt_builtin_teq ((x1 $eo_Term) (x2 $eo_Term)) ($smt_apply_2 "teq" x1 x2))

;;; Eunoia datatype constructors

; The Boolean type
(declare-const $emb_Bool $eo_Term)
(define $eo_Bool () $emb_Bool)

; the literal types
(declare-parameterized-const $emb_Boolean
  ((b $smt_builtin_Bool :opaque)) $eo_Term)
(define $eo_bool ((x $smt_builtin_Bool))
  ($emb_Boolean x))

(declare-parameterized-const $emb_Numeral
  ((n $smt_builtin_Int :opaque)) $eo_Term)
(define $eo_numeral ((x $smt_builtin_Int))
  ($emb_Numeral x))

(declare-parameterized-const $emb_Rational
  ((r $smt_builtin_Rat :opaque)) $eo_Term)
(define $eo_rational ((x $smt_builtin_Rat))
  ($emb_Rational x))

(declare-parameterized-const $emb_String
  ((s $smt_builtin_String :opaque)) $eo_Term)
(define $eo_string ((x $smt_builtin_String))
  ($emb_String x))

(declare-parameterized-const $emb_Binary
  ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $eo_Term)
; define: $eo_binary
; note: >
;   This should be used in pattern matching only, where it is assume that
;   it will match "legal" binary values only.
(define $eo_binary ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($emb_Binary w v))

; The type of types
(declare-const $emb_Type $eo_Term)
(define $eo_Type () $emb_Type)

; The Eunoia representation of "stuckness".
(declare-const $emb_Stuck $eo_Term)
(define $eo_stuck () $emb_Stuck)

; An application of a Eunoia term
(declare-parameterized-const $emb_Apply
  ((f $eo_Term :opaque) (a $eo_Term :opaque))
  $eo_Term)
(define $eo_apply ((x $eo_Term) (y $eo_Term)) ($emb_Apply x y))

; Function type, which Eunoia function type reduces to
(declare-parameterized-const $emb_FunType () $eo_Term)
(define $eo_fun_type () $emb_FunType)

; Represents a Eunoia variable in the final deep embedding.
(declare-parameterized-const $emb_Var
  ((s $smt_builtin_String :opaque) (T $eo_Term :opaque))
  $eo_Term)
(define $eo_Var ((s $smt_builtin_String) (T $eo_Term))
  ($emb_Var s T))

(declare-parameterized-const $emb_Datatype 
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque))
  $eo_Term)
(define $eo_Datatype ((s $smt_builtin_String) (d $smt_Datatype))
  ($emb_Datatype s d))

; the ci^th constructor of datatype T.
(declare-parameterized-const $emb_DtCons
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque)
   (ci $smt_builtin_Int :opaque))
  $eo_Term)
(define $eo_DtCons 
  ((s $smt_builtin_String) (d $smt_Datatype) (ci $smt_builtin_Int))
  ($emb_DtCons s d ci))

; the selector of the ai^th argument of the ci^th constructor of datatype T.
(declare-parameterized-const $emb_DtSel
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque)
   (ci $smt_builtin_Int :opaque) (ai $smt_builtin_Int :opaque))
  $eo_Term)
(define $eo_DtSel 
  ((s $smt_builtin_String) (d $smt_Datatype) (ci $smt_builtin_Int)
   (ai $smt_builtin_Int))
  ($emb_DtSel s d ci ai))
  
; (temporary) uninterpreted constants
(declare-parameterized-const $emb_UConst
  ((n $smt_builtin_Int :opaque) (T $eo_Term :opaque))
  $eo_Term)
(define $eo_UConst
  ((n $smt_builtin_Int :opaque) (T $eo_Term :opaque))
  ($emb_UConst n T))
  
;;; Utilities

; return: The embedding of (-> T1 T2).
; note: Since the Eunoia function type is an atomic term, this becomes a
;       curried apply.
(define $eo_mk_fun_type ((T1 $eo_Term) (T2 $eo_Term))
  ($eo_apply ($eo_apply $eo_fun_type T1) T2))

; note: This definition is only used if we are not eagerly flattening evaluation
; This ensures that stuckness "propagates" through ordinary constant applications.
(program $eo_mk_apply ((x1 $eo_Term) (x2 $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_mk_apply x1 x2) ($eo_apply x1 x2))
  )
)

;;; Defining parametric bitvector operators

; The operators in this section are needed to reason about the parametric
; operations on the Eunoia binary literal type.

; define: $eo_empty_binary
(define $eo_empty_binary ()
  ($eo_binary $smt_builtin_z_zero $smt_builtin_z_zero))

; note: Assumes 0 <= w, makes n legal. We cannot handle errors with
;       w here since we cannot return stuckness.
(define $eo_binary_mod_w ((w $smt_builtin_Int) (n $smt_builtin_Int))
  ($eo_binary w ($smt_builtin_mod n ($smtx_pow2 w))))

; program: $eo_mk_binary
; return: >
;   A "legal" binary value ($eo_mk_binary w n1), where 0 <= n1 < 2^w, n1 is
;   congruent mod 2^w to n if w is positive, or stuck otherwise.
; note: >
;   All binaries considered by Eunoia should run through this method to ensure
;   they are legal. We alternatively use ($eo_binary_mod_w w n) if
;   we are sure that w is legal but not n.
(program $eo_mk_binary ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $eo_Term
  (
  (($eo_mk_binary w n)
    ($smt_builtin_ite ($smt_builtin_z_<= $smt_builtin_z_zero w)
      ($eo_binary_mod_w w n)  ; ensure that n is legal
      $eo_stuck))
  )
)

;;;;;; Eunoia builtin

(program $eo_typeof () :signature ($eo_Term) $eo_Term)

; We are now ready to define the builtins of Eunoia.
; We define all the Eunoia builtins here that are best to
; define in terms of SMT-LIB operators.

;;; Is okay

; Returns SMT-LIB builtin true/false if x is stuck
(define $smt_builtin_is_ok ((x $eo_Term))
  ($smt_builtin_not ($smt_builtin_teq x $eo_stuck)))

; program: $eo_is_ok
; implements: eo::is_ok
(define $eo_is_ok ((x $eo_Term))
  ($eo_bool ($smt_builtin_is_ok x)))

; program: $eo_ite
; implements: eo::ite
; note: This definition is only used if we are not eagerly flattening evaluation
(define $eo_ite ((x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term))
  ($smt_builtin_ite ($smt_builtin_teq x1 true)
    x2
  ($smt_builtin_ite ($smt_builtin_teq x1 false)
    x3
    $eo_stuck)))

; program: $eo_requires
; implements: eo::requires
; note: This definition is only used if we are not eagerly flattening evaluation
(define $eo_requires ((x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term))
  ($smt_builtin_ite ($smt_builtin_teq x1 x2)
    ($smt_builtin_ite ($smt_builtin_is_ok x1) x3 $eo_stuck)
    $eo_stuck))

;;; Boolean operators

; program: $eo_not
; implements: eo::not
(program $eo_not ((T Type) (b $smt_builtin_Bool) (w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature (T) T
  (
  (($eo_not ($eo_bool b))     ($eo_bool ($smt_builtin_not b)))
  (($eo_not ($eo_binary w n)) ($eo_binary_mod_w w ($smtx_binary_not w n)))
  )
)

; program: $eo_and
; implements: eo::and
(program $eo_and
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)
   (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_and ($eo_bool b1) ($eo_bool b2))
     ($eo_bool ($smt_builtin_and b1 b2)))
  (($eo_and ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
      ($eo_binary_mod_w w1 ($smtx_binary_and w1 n1 n2))))
  )
)

; program: $eo_or
; implements: eo::or
(program $eo_or
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)
   (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_or ($eo_bool b1) ($eo_bool b2))
     ($eo_bool ($smt_builtin_or b1 b2)))
  (($eo_or ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
     ($eo_binary_mod_w w1 ($smtx_binary_or w1 n1 n2))))
  )
)

; program: $eo_xor
; implements: eo::xor
(program $eo_xor
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)
   (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_xor ($eo_bool b1) ($eo_bool b2))
     ($eo_bool ($smt_apply_2 "xor" b1 b2)))
  (($eo_xor ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
     ($eo_binary_mod_w w1 ($smtx_binary_or w1 n1 n2))))
  )
)

;;; Arithmetic operators

; program: $eo_add
; implements: eo::add
(program $eo_add
  ((T Type) (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (r1 $smt_builtin_Rat) (r2 $smt_builtin_Rat))
  :signature (T T) T
  (
  (($eo_add ($eo_numeral n1) ($eo_numeral n2))
    ($eo_numeral ($smt_builtin_z_+ n1 n2)))
  (($eo_add ($eo_rational r1) ($eo_rational r2))
    ($eo_rational ($smt_builtin_q_+ r1 r2)))
  (($eo_add ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
      ($eo_binary_mod_w w1 ($smt_builtin_z_+ n1 n2))))  ; don't need to recheck bitwidth
  )
)

(program $eo_mul
  ((T Type) (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (r1 $smt_builtin_Rat) (r2 $smt_builtin_Rat))
  :signature (T T) T
  (
  (($eo_mul ($eo_numeral n1) ($eo_numeral n2))
    ($eo_numeral ($smt_builtin_z_* n1 n2)))
  (($eo_mul ($eo_rational r1) ($eo_rational r2))
    ($eo_rational ($smt_builtin_q_* r1 r2)))
  (($eo_mul ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
      ($eo_binary_mod_w w1 ($smt_builtin_z_* n1 n2))))
  )
)

(program $eo_qdiv
  ((T Type) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int)
   (r1 $smt_builtin_Rat) (r2 $smt_builtin_Rat))
  :signature (T T) $eo_Term
  (
  (($eo_qdiv ($eo_numeral n1) ($eo_numeral n2))
    (eo::define ((rn1 ($smt_apply_1 "to_real" n1)))
    (eo::define ((rn2 ($smt_apply_1 "to_real" n2)))
    ($smt_builtin_ite ($smt_builtin_z_= $smt_builtin_z_zero n2)
      $eo_stuck
      ($eo_rational ($smt_apply_2 "/" rn1 rn2))))))
  (($eo_qdiv ($eo_rational r1) ($eo_rational r2))
    ($smt_builtin_ite ($smt_builtin_q_= $smt_builtin_q_zero r2)
      $eo_stuck
      ($eo_rational ($smt_apply_2 "/" r1 r2))))
  )
)


(program $eo_zdiv
  ((T Type) (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_zdiv ($eo_numeral n1) ($eo_numeral n2))
    ($smt_builtin_ite ($smt_builtin_z_= $smt_builtin_z_zero n2)
      $eo_stuck
      ($eo_numeral ($smt_builtin_div n1 n2))))
  (($eo_zdiv ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
      ($smt_builtin_ite ($smt_builtin_z_= $smt_builtin_z_zero n2)
        ($eo_binary w1 ($smtx_binary_max w1))
        ($eo_binary_mod_w w1 ($smt_builtin_div n1 n2)))))
  )
)

(program $eo_zmod
  ((T Type) (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_zmod ($eo_numeral n1) ($eo_numeral n2))
    ($smt_builtin_ite ($smt_builtin_z_= $smt_builtin_z_zero n2)
      $eo_stuck
      ($eo_numeral ($smt_builtin_mod n1 n2))))
  (($eo_zmod ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
      ($smt_builtin_ite ($smt_builtin_z_= $smt_builtin_z_zero n2)
        ($eo_binary w1 n1)
        ($eo_binary_mod_w w1 ($smt_builtin_mod n1 n2)))))
  )
)

(program $eo_is_neg ((T Type) (n1 $smt_builtin_Int) (r1 $smt_builtin_Rat))
  :signature (T) Bool
  (
  (($eo_is_neg ($eo_numeral n1))
    ($eo_bool ($smt_builtin_z_< n1 $smt_builtin_z_zero)))
  (($eo_is_neg ($eo_rational r1))
    ($eo_bool ($smt_builtin_q_< r1 $smt_builtin_q_zero)))
  )
)

; program: $eo_neg
; implements: eo::neg
(program $eo_neg ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (r1 $smt_builtin_Rat))
  :signature (T) T
  (
  (($eo_neg ($eo_numeral n1))
    ($eo_numeral ($smt_builtin_z_neg n1)))
  (($eo_neg ($eo_rational r1))
    ($eo_rational ($smt_builtin_q_neg r1)))
  (($eo_neg ($eo_binary w n1))
    ($eo_binary_mod_w w ($smt_builtin_z_neg n1)))
  )
)


;;; String operators

; program: $eo_len
; implements: eo::len
(program $eo_len ((T Type) (s1 $smt_builtin_String) (w $smt_builtin_Int) (n1 $smt_builtin_Int))
  :signature (T) $eo_Term
  (
  (($eo_len ($eo_string s1))
    ($eo_numeral ($smt_apply_1 "str.len" s1)))
  (($eo_len ($eo_binary w n1))
    ($eo_numeral w))
  )
)

; program: $eo_concat
; implements: eo::concat
(program $eo_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int)
   (s1 $smt_builtin_String) (s2 $smt_builtin_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_concat ($eo_string s1) ($eo_string s2))
     ($eo_string ($smt_apply_2 "str.++" s1 s2)))
  (($eo_concat ($eo_binary w1 n1) ($eo_binary w2 n2))
     ($eo_mk_binary ($smt_builtin_z_+ w1 w2) ($smtx_binary_concat w1 n1 w2 n2)))
  )
)

; program: $eo_extract
; implements: eo::extract
(program $eo_extract
  ((s1 $smt_builtin_String) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (n3 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($eo_extract ($eo_string s1) ($eo_numeral n2) ($eo_numeral n3))
     ($eo_string ($smt_apply_3 "str.substr" s1 n2 ($smt_builtin_z_inc ($smt_builtin_z_- n3 n2)))))
  (($eo_extract ($eo_binary w n1) ($eo_numeral n2) ($eo_numeral n3))
    (eo::define ((nw ($smt_builtin_z_- n3 n2)))
    ($smt_builtin_ite ($smt_builtin_or ($smt_builtin_z_< n2 $smt_builtin_z_zero) ($smt_builtin_z_< nw $smt_builtin_z_zero))
      $eo_empty_binary
      ($eo_mk_binary
        ($smt_builtin_z_inc nw)
        ($smtx_binary_extract w n1 n2 n3)))))
  )
)

; program: $eo_find
; implements: eo::find
(program $eo_find ((s1 $smt_builtin_String) (s2 $smt_builtin_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_find ($eo_string s1) ($eo_string s2))
     ($eo_numeral ($smt_apply_3 "str.indexof" s1 s2 $smt_builtin_z_zero)))
  )
)

;;; Conversion operators

; program: $eo_to_z
; implements: eo::to_z
(program $eo_to_z ((n1 $smt_builtin_Int) (r1 $smt_builtin_Rat) (s1 $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_z ($eo_numeral n1))   ($eo_numeral n1))
  (($eo_to_z ($eo_rational r1))  ($eo_numeral ($smt_apply_1 "to_int" r1)))
  (($eo_to_z ($eo_string s1))
    ($smt_builtin_ite
      ($smt_builtin_z_= $smt_builtin_z_one ($smt_apply_1 "str.len" s1))
      ($eo_numeral ($smt_apply_1 "str.to_code" s1))
      $eo_stuck))
  (($eo_to_z ($eo_binary w n1))     ($eo_numeral n1))
  )
)

; program: $eo_to_q
; implements: eo::to_q
(program $eo_to_q ((n1 $smt_builtin_Int) (r1 $smt_builtin_Rat) (s1 $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_q ($eo_numeral n1))   ($eo_rational ($smt_apply_1 "to_real" n1)))
  (($eo_to_q ($eo_rational r1))  ($eo_rational r1))
  )
)

; program: $eo_to_bin
; implements: eo::to_bin
(program $eo_to_bin ((w $smt_builtin_Int) (w1 $smt_builtin_Int) (n1 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_to_bin ($eo_numeral w) ($eo_numeral n1))
    ; the upper bound is enforced here
    ($smt_builtin_ite ($smt_builtin_z_<= w $smt_builtin_z_max_width)
      ($eo_mk_binary w n1)
      $eo_stuck))
  (($eo_to_bin ($eo_numeral w) ($eo_binary w1 n1))
    ; the upper bound is enforced here
    ($smt_builtin_ite ($smt_builtin_z_<= w $smt_builtin_z_max_width)
      ($eo_mk_binary w n1)
      $eo_stuck))
  )
)

; program: $eo_to_str
; implements: eo::to_str
(program $eo_to_str ((n1 $smt_builtin_Int) (s1 $smt_builtin_String))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_str ($eo_numeral n1))
    ($smt_builtin_ite
      ($smt_builtin_and ($smt_builtin_z_<= $smt_builtin_z_zero n1) ($smt_builtin_z_< n1 $smt_builtin_z_max_code))
      ($eo_string ($smt_apply_1 "str.from_code" n1))
      $eo_stuck))
  (($eo_to_str ($eo_string s1)) ($eo_string s1))
  ; TODO: technically others here
  )
)

;;; Testers

;;; $eo_is_eq

;;; $eo_eq

; program: $eo_eq
; implements: eo::eq
(program $eo_eq ((t $eo_Term) (s $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_eq t s) ($eo_bool ($smt_builtin_teq s t)))
  )
)

; Returns true if t and s are equivalent values (ground and fully evaluated).
; define: $eo_is_eq
; implements: eo::is_eq
(define $eo_is_eq ((t $eo_Term) (s $eo_Term))
  ($eo_bool ($smt_apply_nary_3 "and"
    ($smt_builtin_is_ok t)
    ($smt_builtin_is_ok s)
    ($smt_builtin_teq s t))))

;;; $eo_is_bool

; Returns true if x is a Boolean literal.
(program $eo_is_bool_internal ((x $eo_Term) (b $smt_builtin_Bool))
  :signature ($eo_Term) Bool
  (
  (($eo_is_bool_internal ($eo_bool b))  true)
  (($eo_is_bool_internal x)                false)
  )
)

; Returns true if x is a Boolean literal.
; define: $eo_is_bool
; implements: eo::is_bool
(define $eo_is_bool ((t $eo_Term))
  ($eo_bool ($smt_builtin_and ($smt_builtin_is_ok t)
    ($smt_builtin_teq ($eo_is_bool_internal t) true))))

;;; $eo_is_z

; Returns true if x is a numeral literal.
(program $eo_is_z_internal ((x $eo_Term) (n $smt_builtin_Int))
  :signature ($eo_Term) Bool
  (
  (($eo_is_z_internal ($eo_numeral n))  true)
  (($eo_is_z_internal x)                false)
  )
)

; Returns true if x is a numeral literal.
; define: $eo_is_z
; implements: eo::is_z
(define $eo_is_z ((t $eo_Term))
  ($eo_bool ($smt_builtin_and ($smt_builtin_is_ok t)
    ($smt_builtin_teq ($eo_is_z_internal t) true))))

;;; $eo_is_q

; Returns true if x is a rational literal.
(program $eo_is_q_internal ((x $eo_Term) (r $smt_builtin_Rat))
  :signature ($eo_Term) Bool
  (
  (($eo_is_q_internal ($eo_rational r))  true)
  (($eo_is_q_internal x)                 false)
  )
)

; Returns true if x is a rational literal.
; define: $eo_is_q
; implements: eo::is_q
(define $eo_is_q ((t $eo_Term))
  ($eo_bool ($smt_builtin_and ($smt_builtin_is_ok t)
    ($smt_builtin_teq ($eo_is_q_internal t) true))))


;;; $eo_is_bin

; Returns true if x is a binary literal.
(program $eo_is_bin_internal ((x $eo_Term) (w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($eo_Term) Bool
  (
  (($eo_is_bin_internal ($eo_binary w n))  true)
  (($eo_is_bin_internal x)                 false)
  )
)

; Returns true if x is a binary literal.
; define: $eo_is_bin
; implements: eo::is_bin
(define $eo_is_bin ((t $eo_Term))
  ($eo_bool ($smt_builtin_and ($smt_builtin_is_ok t)
    ($smt_builtin_teq ($eo_is_bin_internal t) true))))

;;; $eo_is_str

; Returns true if x is a string literal.
(program $eo_is_str_internal ((x $eo_Term) (s $smt_builtin_String))
  :signature ($eo_Term) Bool
  (
  (($eo_is_str_internal ($eo_string s)) true)
  (($eo_is_str_internal x)                 false)
  )
)

; Returns true if x is a string literal.
; define: $eo_is_str
; implements: eo::is_str
(define $eo_is_str ((t $eo_Term))
  ($eo_bool ($smt_builtin_and ($smt_builtin_is_ok t)
    ($smt_builtin_teq ($eo_is_str_internal t) true))))

;;; Derived arithmetic

; final-decl: $smtx_hash
; note: this is defined axiomatically in the final smt2 encoding.
(program $smtx_hash ((T Type)) :signature (T) $smt_builtin_Int)

; program: $eo_hash
; implements: eo::hash
; note: this invokes the underconstrained function above as an oracle.
(program $eo_hash ((T Type) (t T))
  :signature (T) $eo_Term
  (
  (($eo_hash t) ($eo_numeral ($smtx_hash t)))
  )
)

; final-decl: $eo_reverse_hash
; note: this is the inverse of $smtx_hash, which will be defined axiomatically.
(program $eo_reverse_hash () :signature ($smt_builtin_Int) $eo_Term)

; The SMT-LIB comparison of two Eunoia or SMT-LIB terms.
(define $smtx_cmp ((T Type :implicit) (a T) (b T))
  ($smt_builtin_z_<= ($smtx_hash a) ($smtx_hash b)))


;;; $eo_gt

; Compare arithmetic greater than. Assumes x and y are values.
; Returns true if x > y.
; define: $eo_gt
; implements: eo::gt
(define $eo_gt ((x $eo_Term) (y $eo_Term))
  ($eo_is_neg ($eo_add ($eo_neg x) y)))


;;; $eo_cmp

; An arbitrary deterministic comparison of terms. Returns true if a > b based
; on this ordering.
; define: $eo_cmp
; implements: eo::cmp
(define $eo_cmp ((a $eo_Term) (b $eo_Term))
  ($eo_is_neg ($eo_add ($eo_hash b) ($eo_neg ($eo_hash a)))))

;;; since eo_typeof depends on literal predicates, typeof is only now ready.

; program: $eo_var
; implements: eo::var
(program $eo_var ((s $smt_builtin_String) (T $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_var ($eo_string s) T)
    ; we use the hash of the type T to identify the variable
    ($eo_requires ($eo_typeof T) Type ($eo_Var s T)))
  )
)

; program: $eo_nameof
; implements: eo::nameof
(program $eo_nameof ((s $smt_builtin_String) (T $eo_Term))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_nameof ($eo_Var s T)) ($eo_string s))
  )
)

; Returns true if x is a variable.
; define: $eo_is_var
; implements: eo::is_var
(define $eo_is_var ((x $eo_Term))
  ($eo_is_eq ($eo_var ($eo_nameof x) ($eo_typeof x)) x))

; fwd-decl: $eo_typeof_main
; note: This method returns the type for all user defined terms.
(program $eo_typeof_main () :signature ($eo_Term) $eo_Term)

; forward declarations for literal type rules
(program $eo_lit_type_Numeral ((T Type)) :signature (T) Type)
(program $eo_lit_type_Rational ((T Type)) :signature (T) Type)
(program $eo_lit_type_Binary ((T Type)) :signature (T) Type)
(program $eo_lit_type_String ((T Type)) :signature (T) Type)


;
;(program $smtx_is_cons_type
;  ()
;  :signature (Type $smt_Datatype $smt_builtin_Int Type) $smt_builtin_Bool
;  (
;  (($smtx_is_cons_type T ($dt_sum $dtc_unit d) $smt_builtin_z_zero U1)
;    ($smt_builtin_teq T U1))
;  (($smtx_is_cons_type T ($dt_sum ($dtc_cons S c) d) $smt_builtin_z_zero (-> U1 U2))
;    ($smt_builtin_ite ($smt_builtin_Teq ($eo_to_smt_type U1) S)
;      ($smtx_is_cons_type T ($dt_sum c d) $smt_builtin_z_zero U2)
;      $smt_builtin_false))
;  (($smtx_is_cons_type T ($dt_sum c d) n U1)
;    ($smtx_is_cons_type T d ($smt_builtin_z_dec n) U1))
;  )
;)

; program: $eo_typeof
; implements: eo::typeof
(program $eo_typeof
  ((t $eo_Term) (T $eo_Term) (b $smt_builtin_Bool) (n $smt_builtin_Int) (r $smt_builtin_Rat)
   (s $smt_builtin_String) (w $smt_builtin_Int) (d $smt_Datatype))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_typeof ($eo_bool b))                 Bool)
  (($eo_typeof ($eo_numeral n))              ($eo_lit_type_Numeral ($eo_numeral n)))
  (($eo_typeof ($eo_rational r))             ($eo_lit_type_Rational ($eo_rational r)))
  (($eo_typeof ($eo_string s))               ($eo_lit_type_String ($eo_string s)))
  (($eo_typeof ($eo_binary w n))             ($eo_lit_type_Binary ($eo_binary w n)))
  (($eo_typeof ($eo_Var s T))                T)
  (($eo_typeof ($eo_Datatype s d))           Type)
  ;(($eo_typeof ($eo_DtCons s d n))
  ;  ($eo_requires ($eo_is_cons_type ($eo_Datatype s d) ($smtx_dt_substitute s d d) n T) true T))
  ;(($eo_typeof ($eo_DtSel s d n m))
  ;  ($eo_requires ($eo_is_sel_type ($eo_Datatype s d) ($smtx_dt_substitute s d d) n m T) true T))
  ; otherwise, invoke the routine for user types from the signature.
  (($eo_typeof t)                            ($eo_typeof_main t))
  )
)

; fwd-decl: $eo_dt_constructors_main
; note: This method returns the constructors for all user defined terms.
(program $eo_dt_constructors_main () :signature ($eo_Term) $eo_Term)

(program $eo_datatype_constructors_rec
  ((s $smt_builtin_String) (d $smt_Datatype) (c $smt_DatatypeCons)
   (d2 $smt_Datatype) (ci $smt_builtin_Int))
  :signature ($smt_builtin_String $smt_Datatype $smt_Datatype $smt_builtin_Int) $eo_List
  (
  (($eo_datatype_constructors_rec s d $dt_null ci) $eo_List_nil)
  (($eo_datatype_constructors_rec s d ($dt_sum c d2) ci)
    ($eo_List_cons ($eo_DtCons s d ci)
      ($eo_datatype_constructors_rec s d d2 ($smt_builtin_z_inc ci))))
  )
)

; program: $eo_dt_constructors
; implements: eo::dt_constructors
(program $eo_dt_constructors
  ((s $smt_builtin_String) (d $smt_Datatype) (T $eo_Term))
  :signature ($eo_Term) $eo_Term
  (
  ; a user-defined datatype
  (($eo_dt_constructors ($eo_Datatype s d)) 
    ($eo_datatype_constructors_rec s d d $smt_builtin_z_zero))
  ; otherwise, a datatype declared in the signature
  (($eo_dt_constructors T) ($eo_dt_constructors_main T))
  )
)

; fwd-decl: $eo_dt_selectors_main
; note: This method returns the constructors for all user defined terms.
(program $eo_dt_selectors_main () :signature ($eo_Term) $eo_Term)

(program $eo_datatype_cons_selectors_rec
  ((s $smt_builtin_String) (d $smt_Datatype) (n $smt_builtin_Int)
   (U $smt_Type) (c $smt_DatatypeCons) (d2 $smt_Datatype)
   (ci $smt_builtin_Int) (ai $smt_builtin_Int))
  :signature ($smt_builtin_String $smt_Datatype $smt_builtin_Int $smt_Datatype $smt_builtin_Int $smt_builtin_Int) $eo_List
  (
  (($eo_datatype_cons_selectors_rec s d n ($dt_sum $dtc_unit d2) $smt_builtin_z_zero ai)
     $eo_List_nil)
  (($eo_datatype_cons_selectors_rec s d n ($dt_sum ($dtc_cons U c) d2) $smt_builtin_z_zero ai)
    ($eo_List_cons ($eo_DtSel s d n ai)
      ($eo_datatype_cons_selectors_rec s d n d2 $smt_builtin_z_zero ($smt_builtin_z_inc ai))))
  (($eo_datatype_cons_selectors_rec s d n ($dt_sum c d2) ci ai)
    ($eo_datatype_cons_selectors_rec s d n d2 ($smt_builtin_z_dec ci) ai))
  )
)

; program: $eo_dt_selectors
; implements: eo::dt_selectors
(program $eo_dt_selectors 
  ((s $smt_builtin_String) (d $smt_Datatype) (n $smt_builtin_Int) (t $eo_Term))
  :signature ($eo_Term) $eo_Term
  (
  ; a constructor of a user-defined datatype
  (($eo_dt_selectors ($eo_DtCons s d n))
    ($eo_datatype_cons_selectors_rec s d n d n $smt_builtin_z_zero))
  ; otherwise, a datatype constructor declared in the signature
  (($eo_dt_selectors t) ($eo_dt_selectors_main t))
  )
)
(declare-const not (-> Bool Bool))
(declare-const and (-> Bool (-> Bool Bool)))
(declare-parameterized-const = ((A Type :implicit) ($eo_x_1 A) ($eo_x_2 A)) Bool)
(program $mk_symm ((T Type) (t2 T) (t1 T))
  :signature (Bool) Bool
  (
  (($mk_symm (_ (= t1) t2)) (_ (= t2) t1))
  (($mk_symm (not (_ (= t1) t2))) (not (_ (= t2) t1)))
  )
)
(program $eo_prog_symm ((F Bool))
  :signature ($eo_Proof) Bool
  (
  (($eo_prog_symm ($eo_pf F)) ($mk_symm F))
  )
)
(program $eo_typeof_apply ((T Type) (U Type) (V Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_apply (-> T U) V) (eo::requires T V U))
  )
)
(program $eo_typeof_= ((A Type))
  :signature (Type) Type
  (
  (($eo_typeof_= A) (-> A Bool))
  )
)
(program $eo_typeof_fun_type ()
  :signature (Type Type) Type
  (
  (($eo_typeof_fun_type Type Type) Type)
  )
)
(program $eo_typeof_main
  (($eo_T Type) ($eo_U Type) ($eo_V Type) ($eo_W Type) 
   ($eo_f (-> $eo_U $eo_V $eo_T)) ($eo_x $eo_U) ($eo_t $eo_T)
   ($eo_W1 Type) ($eo_x1 $eo_W1)
   ($eo_W2 Type) ($eo_x2 $eo_W2)
   ($eo_W3 Type) ($eo_x3 $eo_W3)
   ($eo_W4 Type) ($eo_x4 $eo_W4)) 
  :signature ($eo_T) Type
  (
  (($eo_typeof_main Type)                   Type)
  (($eo_typeof_main (-> $eo_T $eo_U))
    
    ($eo_typeof_fun_type ($eo_typeof $eo_T) ($eo_typeof $eo_U)))
  (($eo_typeof_main Bool)                   Type)
  (($eo_typeof_main true)                   Bool)
  (($eo_typeof_main false)                  Bool)
  
  (($eo_typeof_main $eo_List)               Type)
  (($eo_typeof_main $eo_List_nil)           $eo_List)
  (($eo_typeof_main ($eo_List_cons $eo_x1)) (-> $eo_List $eo_List))
  
  (($eo_typeof_main Int) Type)
  
  (($eo_typeof_main Real) Type)
  
  (($eo_typeof_main BitVec) (-> Int Type))
  
  (($eo_typeof_main Char) Type)
  
  (($eo_typeof_main Seq) (-> Type Type))
  
  (($eo_typeof_main not) (-> Bool Bool))
  
  (($eo_typeof_main and) (-> Bool (-> Bool Bool)))
  
  (($eo_typeof_main (= $eo_x1)) ($eo_typeof_= ($eo_typeof $eo_x1)))

  (($eo_typeof_main ($eo_f $eo_x))          ($eo_typeof_apply ($eo_typeof $eo_f) ($eo_typeof $eo_x)))
  )
)
(program $eo_lit_type_Numeral ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_Numeral t) Int)
  )
)
(program $eo_lit_type_Rational ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_Rational t) Real)
  )
)
(program $eo_lit_type_Binary ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_Binary t) (BitVec (eo::len t)))
  )
)
(program $eo_lit_type_String ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_String t) (Seq Char))
  )
)
(program $eo_dt_constructors_main
  ((T Type))
  :signature (Type) $eo_List
  (

  )
)
(program $eo_dt_selectors_main ((T Type) (t T))
  :signature (T) $eo_List
  (

  )
)
(program $eo_model_sat () :signature (Bool) Bool)
(program $eo_model_unsat () :signature (Bool) Bool)
; This file defines SMT-LIB model semantics in Eunoia.
; The programs in this file operate on datatypes that correspond to
; a deep embedding of SMT-LIB values.
; In particular, we use the following types:
; 1. $smt_Value, the type of SMT-LIB values.
; 2. Further types defining specific SMT-LIB values, e.g. $smt_Map.

;;;;;; SMT terms

; An SMT-LIB value.
(declare-const $smt_Value Type)

; utilities
; Assumes that veq is defined to be equality over $smt_Value
(define $smt_builtin_veq ((x1 $smt_Value) (x2 $smt_Value)) ($smt_apply_2 "veq" x1 x2))

;;;;;; SMT term constructors

(declare-const $emb_sm.None $smt_Term)
(define $sm_none () $emb_sm.None)

; the literal types
(declare-parameterized-const $emb_sm.Boolean
  ((b $smt_builtin_Bool :opaque)) $smt_Term)
(define $sm_bool ((b $smt_builtin_Bool)) ($emb_sm.Boolean b))

(declare-parameterized-const $emb_sm.Numeral
  ((n $smt_builtin_Int :opaque)) $smt_Term)
(define $sm_numeral ((n $smt_builtin_Int)) ($emb_sm.Numeral n))
; helpers
(define $sm_z_zero () ($sm_numeral $smt_builtin_z_zero))
(define $sm_z_one () ($sm_numeral $smt_builtin_z_one))

(declare-parameterized-const $emb_sm.Rational
  ((r $smt_builtin_Rat :opaque)) $smt_Term)
(define $sm_rational ((r $smt_builtin_Rat)) ($emb_sm.Rational r))
; helpers
(define $sm_q_zero () ($sm_rational $smt_builtin_q_zero))

(declare-parameterized-const $emb_sm.String
  ((s $smt_builtin_String :opaque)) $smt_Term)
(define $sm_string ((s $smt_builtin_String)) ($emb_sm.String s))
; helpers
(define $sm_string_empty () ($emb_sm.String $smt_builtin_str_empty))
(define $sm_string_c0 () ($emb_sm.String ($smt_apply_0 """0""")))
(define $sm_string_c9 () ($emb_sm.String ($smt_apply_0 """9""")))

(declare-parameterized-const $emb_sm.Binary
  ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $smt_Term)
(define $sm_binary ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($emb_sm.Binary w v))
; helpers
(define $sm_binary_bit_false () ($sm_binary $smt_builtin_z_one $smt_builtin_z_zero))
(define $sm_binary_bit_true () ($sm_binary $smt_builtin_z_one $smt_builtin_z_one))

; An application of a Eunoia term
(declare-parameterized-const $emb_sm.Apply
  ((f $smt_Term :opaque) (a $smt_Term :opaque))
  $smt_Term)
(define $sm_apply ((x $smt_Term) (y $smt_Term)) ($emb_sm.Apply x y))

; Represents a SMT-LIB variable in the final deep embedding.
(declare-parameterized-const $emb_sm.Var
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque))
  $smt_Term)
(define $sm_Var ((s $smt_builtin_String) (T $smt_Type)) ($emb_sm.Var s T))

; exists
; this takes the variable to quantify over, which should then be applied
; to a formula, similarly for the other quantifiers
(declare-parameterized-const $emb_sm.exists
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque)) $smt_Term)
(define $sm_exists ((s $smt_builtin_String) (T $smt_Type)) ($emb_sm.exists s T))

; forall
(declare-parameterized-const $emb_sm.forall
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque)) $smt_Term)
(define $sm_forall ((s $smt_builtin_String) (T $smt_Type)) ($emb_sm.forall s T))
  
; lambda
(declare-parameterized-const $emb_sm.lambda
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque)) $smt_Term)
(define $sm_lambda ((s $smt_builtin_String) (T $smt_Type)) ($emb_sm.lambda s T))

; choice
(declare-parameterized-const $emb_sm.choice
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque)) $smt_Term)
(define $sm_choice ((s $smt_builtin_String) (T $smt_Type)) ($emb_sm.choice s T))

; the ci^th constructor of datatype ($tsm_Datatype s d).
(declare-parameterized-const $emb_sm.DtCons
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque)
   (ci $smt_builtin_Int :opaque)) 
  $smt_Term)
(define $sm_DtCons 
  ((s $smt_builtin_String) (d $smt_Datatype) (ci $smt_builtin_Int))
  ($emb_sm.DtCons s d ci))

; The selector of the ai^th argument of the ci^th constructor of datatype
; ($tsm_Datatype s d).
(declare-parameterized-const $emb_sm.DtSel
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque) 
   (ci $smt_builtin_Int :opaque) (ai $smt_builtin_Int :opaque))
  $smt_Term)
(define $sm_DtSel 
  ((s $smt_builtin_String) (d $smt_Datatype)
   (ci $smt_builtin_Int) (ai $smt_builtin_Int))
  ($emb_sm.DtSel s d ci ai))

; the tester of the ci^th constructor of datatype ($tsm_Datatype s d).
(declare-parameterized-const $emb_sm.DtTester
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque) (ci $smt_builtin_Int :opaque))
  $smt_Term)
(define $sm_DtTester ((s $smt_builtin_String) (d $smt_Datatype) (ci $smt_builtin_Int))
  ($emb_sm.DtTester s d ci))
  
; the updater of the ai^th argument of the ci^th constructor of datatype ($tsm_Datatype s d).
(declare-parameterized-const $emb_sm.DtUpdater
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque)
   (ci $smt_builtin_Int :opaque) (ai $smt_builtin_Int :opaque))
  $smt_Term)
(define $sm_DtUpdater
  ((s $smt_builtin_String) (d $smt_Datatype) (ci $smt_builtin_Int) (ai $smt_builtin_Int))
  ($emb_sm.DtUpdater s d ci ai))

; constants, which carry their value and type in the model
(declare-parameterized-const $emb_sm.Const
  ((v $smt_Value :opaque) (T $smt_Type :opaque)) $smt_Term)
(define $sm_Const
  ((v $smt_Value) (T $smt_Type)) ($emb_sm.Const v T))

; all other ordinary term definitions
(declare-parameterized-const $emb_sm.not ((x1 $smt_Term)) $smt_Term)
(define $sm_not ((x1 $smt_Term)) ($sm_apply $emb_sm.not x1))
(declare-parameterized-const $emb_sm.and ((x1 $smt_Term) (x2 $smt_Term)) $smt_Term)
(define $sm_and ((x1 $smt_Term) (x2 $smt_Term)) ($sm_apply ($sm_apply $emb_sm.and x1) x2))
(declare-parameterized-const $emb_sm.= ((x1 $smt_Term) (x2 $smt_Term)) $smt_Term)
(define $sm_= ((x1 $smt_Term) (x2 $smt_Term)) ($sm_apply ($sm_apply $emb_sm.= x1) x2))


;;;;;; SMT type constructors

(declare-const $emb_tsm.None $smt_Type)
(define $tsm_none () $emb_tsm.None)

; The Boolean type
(declare-const $emb_tsm.Bool $smt_Type)
(define $tsm_Bool () $emb_tsm.Bool)

; The Integer type
(declare-const $emb_tsm.Int $smt_Type)
(define $tsm_Int () $emb_tsm.Int)

; The Real type
(declare-const $emb_tsm.Real $smt_Type)
(define $tsm_Real () $emb_tsm.Real)

; The String type
(declare-const $emb_tsm.String $smt_Type)
(define $tsm_String () $emb_tsm.String)

; The RegLan type
(declare-const $emb_tsm.RegLan $smt_Type)
(define $tsm_RegLan () $emb_tsm.RegLan)

; The Bitvector type
(declare-parameterized-const $emb_tsm.BitVec ((w $smt_builtin_Int :opaque)) $smt_Type)
(define $tsm_BitVec ((w $smt_builtin_Int)) ($emb_tsm.BitVec w))

; The Map type
(declare-parameterized-const $emb_tsm.Map ((Ti $smt_Type :opaque) (Te $smt_Type :opaque)) $smt_Type)
(define $tsm_Map ((Ti $smt_Type) (Te $smt_Type)) ($emb_tsm.Map Ti Te))

; The type of partially applied datatype constructors
(declare-parameterized-const $emb_tsm.DtCons
  ((Ti $smt_Type :opaque) (Te $smt_Type :opaque))
  $smt_Type)
(define $tsm_DtCons ((Ti $smt_Type) (Te $smt_Type)) ($emb_tsm.DtCons Ti Te))

; The Sequence type
(declare-parameterized-const $emb_tsm.Seq ((T $smt_Type :opaque)) $smt_Type)
(define $tsm_Seq ((T $smt_Type)) ($emb_tsm.Seq T))

; A datatype is a type containing (1) its name, and (2) its structure.
; Its name can be understood as a binder under which ($tsm_TypeRef <name>) is
; a recursive reference to the (most recently bound) instance of a datatype
; with the given name.
; For example, the recursive datatype for a list of integers:
; (declare-datatype List ((cons (head Int) (tail List)) (nil)))
; Would have the following syntax:
; ($tsm_Datatype "List" d)
; Where d is the datatype spec:
; ($dt_sum
;   ($dtc_cons $tsm_Int ($dtc_cons ($tsm_TypeRef "List") $dtc_unit)) ; cons
;   ($dt_sum
;      $dtc_unit ; nil
;      $dt_null))
; Note that names of constructors and selectors are not represented in the AST.
; To express constructor terms, we give an index, such that cons/nil are terms:
;   ($sm_DtCons "List" d 0), ($sm_DtCons "List" d 1).
; The types of these constructors are:
;   ($sm_DtCons "List" d 0) : (-> $tsm_Int ($tsm_Datatype "List" d) ($tsm_Datatype "List" d))
;   ($sm_DtCons "List" d 1) : ($tsm_Datatype "List" d)
; The list (1,2) is the term:
; ($sm_apply 
;    ($sm_apply ($sm_DtCons "List" d 0) ($sm_numeral 1))
;    ($sm_apply
;       ($sm_apply ($sm_DtCons "List" d 0) ($sm_numeral 2)) 
;       ($sm_DtCons "List" d 1)))
; The selectors head/tail for this datatype give indices to the constructor
; and argument position they refer to:
;   ($sm_DtSel "List" d 0 0) ($sm_DtSel "List" d 0 1).
; Note this also permits mutual recursion, e.g. for SMT datatype:
; (declare-datatypes ((List 0) (Tree 0))
;   (((cons (head Tree) (tail List)) (nil))
;    ((node (children List)) (leaf))))
; this is represented as:
; (eo::define ((Tree
;    ($tsm_Datatype "Tree"
;      ($dt_sum 
;        ($dtc_cons ($tsm_TypeRef "List") $dtc_unit) ; node
;        ($dt_sum
;          $dtc_unit ; leaf
;          $dt_null)))))
;   ($tsm_Datatype "List"
;      ($dt_sum
;        ($dtc_cons Tree ($dtc_cons ($tsm_TypeRef "List") $dtc_unit)) ; cons
;        ($dt_sum 
;           $dtc_unit ; nil
;           $dt_null))))
(declare-parameterized-const $emb_tsm.Datatype 
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque)) $smt_Type)
(define $tsm_Datatype ((s $smt_builtin_String) (d $smt_Datatype))
  ($emb_tsm.Datatype s d))
  
(declare-parameterized-const $emb_tsm.TypeRef
  ((s $smt_builtin_String :opaque)) $smt_Type)
(define $tsm_TypeRef ((s $smt_builtin_String)) ($emb_tsm.TypeRef s))
; utilites

; all other ordinary type definitions
(declare-parameterized-const $emb_tsm.Char () $smt_Type)
(define $tsm_Char () $emb_tsm.Char)


;;;;;; SMT values

; The type used to define values for functions, arrays and sets in SMT-LIB.
(declare-const $smt_Map Type)

; The type used to define values for sequences in SMT-LIB.
(declare-const $smt_Seq Type)

;;; SMT value datatype constructors

; Denotes a failure case for values.
(declare-const $emb_vsm.NotValue $smt_Value)
(define $vsm_not_value () $emb_vsm.NotValue)

; the literal types
(declare-parameterized-const $emb_vsm.Boolean
  ((b $smt_builtin_Bool :opaque)) $smt_Value)
(define $vsm_bool ((b $smt_builtin_Bool)) ($emb_vsm.Boolean b))

(declare-parameterized-const $emb_vsm.Numeral
  ((n $smt_builtin_Int :opaque)) $smt_Value)
(define $vsm_numeral ((n $smt_builtin_Int)) ($emb_vsm.Numeral n))

(declare-parameterized-const $emb_vsm.Rational
  ((r $smt_builtin_Rat :opaque)) $smt_Value)
(define $vsm_rational ((r $smt_builtin_Rat)) ($emb_vsm.Rational r))

(declare-parameterized-const $emb_vsm.String
  ((s $smt_builtin_String :opaque)) $smt_Value)
(define $vsm_string ((s $smt_builtin_String)) ($emb_vsm.String s))

(declare-parameterized-const $emb_vsm.Binary
  ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $smt_Value)
(define $vsm_binary ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($emb_vsm.Binary w v))
; utilities
(define $vsm_binary_mod_w ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($emb_vsm.Binary w ($smt_builtin_mod v ($smtx_pow2 w))))
(define $vsm_mk_binary ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($smt_builtin_ite ($smt_builtin_z_<= $smt_builtin_z_zero w)
    ($vsm_binary_mod_w w v)
    $vsm_not_value))
  
; A value denoting a map.
(declare-parameterized-const $emb_vsm.Map ((m $smt_Map :opaque)) $smt_Value)
(define $vsm_map ((m $smt_Map)) ($emb_vsm.Map m))

; A value denoting a sequence.
(declare-parameterized-const $emb_vsm.Seq ((s $smt_Seq :opaque)) $smt_Value)
(define $vsm_seq ((s $smt_Seq)) ($emb_vsm.Seq s))

; A value denoting a regular language.
(declare-parameterized-const $emb_vsm.RegLan ((r $smt_builtin_RegLan :opaque)) $smt_Value)
(define $vsm_re ((r $smt_builtin_RegLan)) ($emb_vsm.RegLan r))

; A value denoting a lambda.
(declare-parameterized-const $emb_vsm.Lambda 
  ((s $smt_builtin_String :opaque) (T $smt_Type :opaque) (t $smt_Term :opaque)) $smt_Value)
(define $vsm_lambda 
  ((s $smt_builtin_String) (T $smt_Type) (t $smt_Term)) 
  ($emb_vsm.Lambda s T t))

; A constructor value
(declare-parameterized-const $emb_vsm.DtCons
  ((s $smt_builtin_String :opaque) (d $smt_Datatype :opaque) (ci $smt_builtin_Int :opaque))
  $smt_Value)
(define $vsm_DtCons ((s $smt_builtin_String) (d $smt_Datatype) (ci $smt_builtin_Int))
  ($emb_vsm.DtCons s d ci))
  
; Apply values (for Herbrand interpretations).
(declare-parameterized-const $emb_vsm.Apply
  ((f $smt_Value :opaque) (a $smt_Value :opaque))
  $smt_Value)
(define $vsm_apply ((f $smt_Value) (a $smt_Value))
  ($emb_vsm.Apply f a))
; utilities
(program $vsm_apply_head ((f $smt_Value) (a $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($vsm_apply_head ($vsm_apply f a)) ($vsm_apply_head f))
  (($vsm_apply_head a)                a)
  )
)
(program $vsm_apply_arg_nth ((f $smt_Value) (a $smt_Value) (n $smt_builtin_Int))
  :signature ($smt_Value $smt_builtin_Int) $smt_Value
  (
  (($vsm_apply_arg_nth ($vsm_apply f a) n)
    ($smt_builtin_ite ($smt_builtin_z_= n $smt_builtin_z_zero)
      a
      ($vsm_apply_arg_nth f ($smt_builtin_z_dec n))))
  (($vsm_apply_arg_nth a n) $vsm_not_value)
  )
)

;;; SMT map value datatype constructors

; Constructs a map value where i is mapped to e.
(declare-parameterized-const $emb_msm.cons
  ((i $smt_Value :opaque) (e $smt_Value :opaque) (m $smt_Map :opaque))
  $smt_Map)
(define $msm_cons ((i $smt_Value) (e $smt_Value) (m $smt_Map))
  ($emb_msm.cons i e m))

; Constructs a map value where all indices are mapped to e.
(declare-parameterized-const $emb_msm.default
  ((T $smt_Type :opaque) (e $smt_Value :opaque))
  $smt_Map)
(define $msm_default ((T $smt_Type) (e $smt_Value)) ($emb_msm.default T e))

;;; SMT sequence value datatype constructors

(declare-parameterized-const $emb_ssm.cons
  ((i $smt_Value :opaque) (s $smt_Seq :opaque))
  $smt_Seq)
(define $ssm_cons ((i $smt_Value) (s $smt_Seq)) ($emb_ssm.cons i s))

(declare-parameterized-const $emb_ssm.empty ((T $smt_Type :opaque)) $smt_Seq)
(define $ssm_empty ((T $smt_Type)) ($emb_ssm.empty T))

;;; Generic utilities

(define $vsm_true () ($vsm_bool $smt_builtin_true))
(define $vsm_false () ($vsm_bool $smt_builtin_false))

; define: $smtx_value_hash
; note: this is an arbitrary hash for SMT values, defined axiomatically.
(program $smtx_value_hash () :signature ($smt_Value) $smt_builtin_Int)
(program $smtx_reverse_value_hash () :signature ($smt_builtin_Int) $smt_Value)

; The SMT-LIB comparison of two SMT-LIB values.
(define $smtx_value_cmp ((a $smt_Value) (b $smt_Value))
  ($smt_builtin_z_<= ($smtx_value_hash a) ($smtx_value_hash b)))

; forward declaration
(program $smtx_typeof_value () :signature ($smt_Value) $smt_Type)

;;; Map utilities

; Get the default for the map
(program $smtx_msm_get_default
  ((T $smt_Type) (i $smt_Value) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Map) $smt_Value
  (
  (($smtx_msm_get_default ($msm_cons j e m))  ($smtx_msm_get_default m))
  (($smtx_msm_get_default ($msm_default T e)) e)
  )
)

; This program looks up the value of a term in a map.
; This is used for function evaluation.
(program $smtx_msm_lookup
  ((T $smt_Type) (i $smt_Value) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Map $smt_Value) $smt_Value
  (
  (($smtx_msm_lookup ($msm_cons j e m) i)  ($smt_builtin_ite ($smt_builtin_veq j i) e ($smtx_msm_lookup m i)))
  (($smtx_msm_lookup ($msm_default T e) i) e)
  )
)

; updates the map with a new entry, maintaining ordered-ness
(program $smtx_msm_update
  ((T $smt_Type) (i $smt_Value) (j $smt_Value) (e1 $smt_Value) (e2 $smt_Value) (m $smt_Map))
  :signature ($smt_Map $smt_Value $smt_Value) $smt_Map
  (
  ; we overwrite if same index
  (($smtx_msm_update ($msm_cons i e1 m) i e2) ($msm_cons i e2 m))
  ; otherwise, we check the hash to retain sortedness
  (($smtx_msm_update ($msm_cons j e1 m) i e2) ($smt_builtin_ite ($smtx_value_cmp j i)
                                                ($msm_cons i e2 ($msm_cons j e1 m))
                                                ($msm_cons j e1 ($smtx_msm_update m i e2))))
  ; we are redundant wrt the default value
  (($smtx_msm_update ($msm_default T e1) i e1)  ($msm_default T e1))
  ; ensures totality, we are a non-redundant update of the default map
  (($smtx_msm_update m i e2)                    ($msm_cons i e2 m))
  )
)

; Returns the first index of m1 that is mapped to a different value in m2.
; If no such value exists, return $vsm_not_value.
(program $smtx_msm_find_diff
  ((T $smt_Type) (i $smt_Value) (e $smt_Value) (m1 $smt_Map) (m2 $smt_Map))
  :signature ($smt_Map $smt_Map) $smt_Value
  (
  (($smtx_msm_find_diff ($msm_default T e) m2)  $vsm_not_value)
  (($smtx_msm_find_diff ($msm_cons i e m1) m2)
    ; Lookup the current index, if it different, return this index.
    ($smt_builtin_ite
      ($smt_builtin_veq ($smtx_msm_lookup m2 i) e)
      ($smtx_msm_find_diff m1 m2)
      i))
  )
)

; Returns the type of the map value or tsm_none
(program $smtx_typeof_map_value
  ((i $smt_Value) (e $smt_Value) (m $smt_Map) (T $smt_Type))
  :signature ($smt_Map) $smt_Type
  (
  (($smtx_typeof_map_value ($msm_cons i e m))
    (eo::define ((mT ($smtx_typeof_map_value m)))
    ($smt_builtin_ite ($smt_builtin_Teq ($tsm_Map ($smtx_typeof_value i) ($smtx_typeof_value e)) mT)
      mT
      $tsm_none)))
  (($smtx_typeof_map_value ($msm_default T e))  ($tsm_Map T ($smtx_typeof_value e)))
  )
)

(program $smtx_index_typeof_map ((T $smt_Type) (U $smt_Type))
  :signature ($smt_Type) $smt_Type
  (
  (($smtx_index_typeof_map ($tsm_Map T U)) T)
  (($smtx_index_typeof_map T) $tsm_none)
  )
)
(program $smtx_elem_typeof_map ((T $smt_Type) (U $smt_Type))
  :signature ($smt_Type) $smt_Type
  (
  (($smtx_elem_typeof_map ($tsm_Map T U)) U)
  (($smtx_elem_typeof_map T) $tsm_none)
  )
)


;;; Map as sets

; A set is a mapping to Bool.
; The empty set maps all to false.
;(define $tsm_Set ((T $smt_Type)) ($tsm_Map T $tsm_Bool))
(define $smtx_elem_typeof_set ((T $smt_Type)) ($smtx_index_typeof_map T))

(define $msm_empty_set ((T $smt_Type)) ($msm_default T $vsm_false))
; Inserting sets e to true.
(define $smtx_mss_mk_insert ((e $smt_Value) (m $smt_Map)) ($smtx_msm_update m e $vsm_true))
(define $smtx_mss_insert ((e $smt_Value) (m $smt_Map)) ($msm_cons e $vsm_true m))
(define $smtx_mss_member ((e $smt_Value) (m $smt_Map))
  ($smt_builtin_veq ($smtx_msm_lookup m e) $vsm_true))

; Helper for computing binary set operators.
; Takes a flag isInter and maps m1, m2, macc.
; If isInter is true, then we add to macc elements that are in both m1 and m2.
; If isInter is false, then we add to macc elements that are in the difference of m1 and m2.
(program $smtx_mss_op_internal
  ((T $smt_Type) (m1 $smt_Map) (m2 $smt_Map) (acc $smt_Map) (e $smt_Value) (isInter $smt_builtin_Bool))
  :signature ($smt_builtin_Bool $smt_Map $smt_Map $smt_Map) $smt_Map
  (
  (($smtx_mss_op_internal isInter ($msm_empty_set T) m2 acc) acc)
  (($smtx_mss_op_internal isInter ($smtx_mss_insert e m1) m2 acc)
    ($smtx_mss_op_internal isInter m1 m2
      ($smt_builtin_ite
        ($smt_builtin_iff ($smtx_mss_member e m2) isInter)
        ($smtx_mss_mk_insert e acc)
        acc)))
  )
)

;;; Utilities for Sequence values

(program $smtx_ssm_seq_nth
  ((v $smt_Value) (vs $smt_Seq) (n $smt_builtin_Int) (T $smt_Type))
  :signature ($smt_Seq $smt_builtin_Int) $smt_Value
  (
  (($smtx_ssm_seq_nth ($ssm_empty T) n)                       $vsm_not_value)
  (($smtx_ssm_seq_nth ($ssm_cons v vs) $smt_builtin_z_zero)   v)
  (($smtx_ssm_seq_nth ($ssm_cons v vs) n)
    ($smtx_ssm_seq_nth vs ($smt_builtin_z_dec n)))
  )
)

; Returns the type of the map value or tsm_none
(program $smtx_typeof_seq_value
  ((v $smt_Value) (vs $smt_Seq) (T $smt_Type))
  :signature ($smt_Seq) $smt_Type
  (
  (($smtx_typeof_seq_value ($ssm_cons v vs))
    (eo::define ((sT ($smtx_typeof_seq_value vs)))
    ($smt_builtin_ite ($smt_builtin_Teq ($tsm_Seq ($smtx_typeof_value v)) sT)
      sT
      $tsm_none)))
  (($smtx_typeof_seq_value ($ssm_empty T)) ($tsm_Seq T))
  )
)

;; datatypes

(program $smtx_dtc_concat
  ((U $smt_Type) (c1 $smt_DatatypeCons) (c2 $smt_DatatypeCons))
  :signature ($smt_DatatypeCons $smt_DatatypeCons) $smt_DatatypeCons
  (
  (($smtx_dtc_concat ($dtc_cons U c1) c2) ($dtc_cons U ($smtx_dtc_concat c1 c2)))
  (($smtx_dtc_concat $dtc_unit c2)        c2)
  )
)

; Replaces ($tsm_TypeRef s) by ($tsm_Datatype s d) in all arguments
; of a datatype constructor.
; Note that this assumes there is no nested recursion, i.e. occurrences of
; ($tsm_TypeRef s) that are beneath applications of other types.
(program $smtx_dtc_substitute
  ((s $smt_builtin_Int) (d $smt_Datatype) (T $smt_Type) (c $smt_DatatypeCons))
  :signature ($smt_builtin_String $smt_Datatype $smt_DatatypeCons) $smt_DatatypeCons
  (
  (($smtx_dtc_substitute s d ($dtc_cons T c))
    ($dtc_cons
      ; if it is a recursive reference to the type we are substituting, replace
      ($smt_builtin_ite ($smt_builtin_Teq T ($tsm_TypeRef s))
        ($tsm_Datatype s d)
        T)
      ($smtx_dtc_substitute s d c)))
  (($smtx_dtc_substitute s d $dtc_unit) $dtc_unit)
  )
)

; Substitutes ($tsm_TypeRef s) by ($tsm_Datatype s d) in all arguments
; of datatype constructors of a datatype.
; Note that this assumes there is no nested recursion, i.e. occurrences of
; ($tsm_TypeRef s) that are beneath applications of other types.
(program $smtx_dt_substitute
  ((s $smt_builtin_Int) (d $smt_Datatype) (c $smt_DatatypeCons) (d2 $smt_Datatype))
  :signature ($smt_builtin_String $smt_Datatype $smt_Datatype) $smt_Datatype
  (
  (($smtx_dt_substitute s d ($dt_sum c d2))
    ($dt_sum ($smtx_dtc_substitute s d c) ($smtx_dt_substitute s d d2)))
  (($smtx_dt_substitute s d $dt_null) $dt_null)
  )
)

(program $smtx_typeof_dt_cons_value_rec
  ((T $smt_Type) (U $smt_Type) (n $smt_builtin_Int) (c $smt_DatatypeCons) (d $smt_Datatype))
  :signature ($smt_Type $smt_Datatype $smt_builtin_Int) $smt_Type
  (
  (($smtx_typeof_dt_cons_value_rec T $dt_null $smt_builtin_z_zero) T)
  (($smtx_typeof_dt_cons_value_rec T ($dt_sum ($dtc_cons U c) d) $smt_builtin_z_zero)
    ($tsm_DtCons U ($smtx_typeof_dt_cons_value_rec T ($dt_sum c d) $smt_builtin_z_zero)))
  (($smtx_typeof_dt_cons_value_rec T ($dt_sum c d) n)
    ($smtx_typeof_dt_cons_value_rec T d ($smt_builtin_z_dec n)))
  (($smtx_typeof_dt_cons_value_rec T d n) $tsm_none)
  )
)

(define $smtx_typeof_dt_cons_value
  ((s $smt_builtin_String) (d $smt_Datatype) (n $smt_builtin_Int))
  ; substitute ($tsm_TypeRef s) to ($tsm_Datatype s d), which ensures the
  ; datatype we are processing is closed.
  ($smtx_typeof_dt_cons_value_rec ($tsm_Datatype s d) ($smtx_dt_substitute s d d) n))

; program: $smtx_typeof_apply_value
(program $smtx_typeof_apply_value ((T $smt_Type) (U $smt_Type) (V $smt_Type))
  :signature ($smt_Type $smt_Type) $smt_Type
  (
  ; can partially apply datatype constructors
  (($smtx_typeof_apply_value ($tsm_DtCons T U) V)
    ($smt_builtin_ite ($smt_builtin_Teq T V) U $tsm_none))
  (($smtx_typeof_apply_value T U) $tsm_none)
  )
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Type rules for values

; NOTE: $vsm_lambda is unhandled
(program $smtx_typeof_value
  ((v $smt_Value) (f $smt_Value) (d $smt_Datatype)
   (b $smt_builtin_Bool) (w $smt_builtin_Int) (n $smt_builtin_Int)
   (q $smt_builtin_Real) (s $smt_builtin_String) (r $smt_builtin_RegLan)
   (m $smt_Map) (ss $smt_Seq))
  :signature ($smt_Value) $smt_Type
  (
  (($smtx_typeof_value ($vsm_bool b))     $tsm_Bool)
  (($smtx_typeof_value ($vsm_numeral n))  $tsm_Int)
  (($smtx_typeof_value ($vsm_rational q)) $tsm_Real)
  (($smtx_typeof_value ($vsm_string s))   $tsm_String)
  (($smtx_typeof_value ($vsm_binary w n))
    ($smt_builtin_ite ($smt_builtin_z_<= $smt_builtin_z_zero w) 
      ($tsm_BitVec w)
      $tsm_none))
  (($smtx_typeof_value ($vsm_re r))       $tsm_RegLan)
  (($smtx_typeof_value ($vsm_map m))      ($smtx_typeof_map_value m))
  (($smtx_typeof_value ($vsm_seq ss))     ($smtx_typeof_seq_value ss))
  (($smtx_typeof_value ($vsm_DtCons s d n))
    ($smtx_typeof_dt_cons_value s d n))
  (($smtx_typeof_value ($vsm_apply f v))
    ($smtx_typeof_apply_value ($smtx_typeof_value f) ($smtx_typeof_value v)))
  (($smtx_typeof_value v)                 $tsm_none)
  )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Model semantics

; Forward declaration of the main method defined by this signature.
; We use this to define $eo_model_sat.
(program $smtx_model_eval () :signature ($smt_Term) $smt_Value)

;;; Core

; ITE branches to the appropriate child.
; return: The evaluation of an ite application.
(program $smtx_model_eval_ite
  ((t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_ite $vsm_true t2 t3)   t2)
  (($smtx_model_eval_ite $vsm_false t2 t3)  t3)
  (($smtx_model_eval_ite t1 t2 t3)          $vsm_not_value)
  )
)

; Equality insists on valueness and then reduces to an equality over datatypes
; in the deep embedding (vsm.Value), meaning it works for all types, including
; functions and uninterpreted sorts where values are not represented by terms.
; Note that the valueness predicate ensures this is sound. Moreover note that
; we do not invoke the type checker here. This means that if an ill-typed
; equality was given as input to this method, it would always evaluate to false.
; The caller of this method is responsible for ensuring that this behavior is
; either avoided or admissible.
; return: The evaluation of an equality application.
(program $smtx_model_eval_= ((t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_= t1 t2)
    (eo::define ((T1 ($smtx_typeof_value t1)))
    (eo::define ((T2 ($smtx_typeof_value t2)))
      ($smt_builtin_ite ($smt_builtin_Teq T1 T2)
        ($smt_builtin_ite ($smt_builtin_Teq T1 $tsm_none)
          $vsm_not_value
          ($vsm_bool ($smt_builtin_veq t1 t2)))
        $vsm_not_value))))
  )
)

;;; Functions, arrays

; Array select
(program $smtx_map_select
  ((v $smt_Value) (i $smt_Value) (m $smt_Map))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_select ($vsm_map m) i) ($smtx_msm_lookup m i))
  (($smtx_map_select v i)              $vsm_not_value)
  )
)

; Array store
(program $smtx_map_store
  ((v $smt_Value) (i $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_store ($vsm_map m) i e) ($vsm_map ($smtx_msm_update m i e)))
  (($smtx_map_store v i e)            $vsm_not_value)
  )
)

;;; Sets

; Empty set
(define $smtx_empty_set ((T $smt_Type)) ($vsm_map ($msm_empty_set T)))

; Set singleton
; return the singleton set whose type is T and contains e.
(define $smtx_set_singleton ((e $smt_Value))
  ($vsm_map ($smtx_mss_insert e ($msm_empty_set ($smtx_typeof_value e)))))

; Set intersection
; return the intersection of two set values.
(program $smtx_set_inter
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_inter ($vsm_map m1) ($vsm_map m2))
    ; m1 intersected m2 starting with empty set.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_true m1 m2 ($msm_empty_set ($smtx_index_typeof_map ($smtx_typeof_map_value m1))))))
  (($smtx_set_inter v1 v2)  $vsm_not_value)
  )
)

; Set minus
; return the set minus of two set values.
(program $smtx_set_minus
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_minus ($vsm_map m1) ($vsm_map m2))
    ; m1 minus m2 starting with empty set.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_false m1 m2 ($msm_empty_set ($smtx_index_typeof_map ($smtx_typeof_map_value m1))))))
  (($smtx_set_minus v1 v2)  $vsm_not_value)
  )
)

; Set union
; return the union of two set values.
(program $smtx_set_union
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_union ($vsm_map m1) ($vsm_map m2))
    ; m1 minus the empty set starting with m2.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_false m1 ($msm_empty_set ($smtx_index_typeof_map ($smtx_typeof_map_value m1))) m2)))
  (($smtx_set_union v1 v2)  $vsm_not_value)
  )
)

;;; Sequences

; Empty sequence
(define $smtx_empty_seq ((T $smt_Type)) ($vsm_seq ($ssm_empty T)))

; Sequence unit
(define $smtx_seq_unit ((e $smt_Value)) ($vsm_seq ($ssm_cons e ($ssm_empty ($smtx_typeof_value e)))))

; Sequence nth
(program $smtx_seq_nth
  ((s $smt_Seq) (n $smt_builtin_Int) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_seq_nth ($vsm_seq s) ($vsm_numeral n)) ($smtx_ssm_seq_nth s n))
  (($smtx_seq_nth v1 v2) $vsm_not_value)
  )
)
;;; Quantifiers

(program $smtx_is_var
  ((x $smt_Term) (s1 $smt_builtin_String) (T1 $smt_Type)
   (s2 $smt_builtin_String) (T2 $smt_Type))
  :signature ($smt_builtin_String $smt_Type $smt_Term) $smt_builtin_Bool
  (
  (($smtx_is_var s1 T1 ($sm_Var s2 T2)) 
    ($smt_builtin_and ($smt_builtin_str_= s1 s2) ($smt_builtin_Teq T1 T2)))
  (($smtx_is_var s1 T1 x) $smt_builtin_false)
  )
)

; (x, y) returns true iff y is a binder for x.
(program $smtx_is_binder_x 
  ((x $smt_Term) (s1 $smt_builtin_String) (T1 $smt_Type)
   (s2 $smt_builtin_String) (T2 $smt_Type))
  :signature ($smt_builtin_String $smt_Type $smt_Term) $smt_builtin_Bool
  (
  (($smtx_is_binder_x s1 T1 ($sm_exists s2 T2)) 
    ($smtx_is_var s1 T1 ($sm_Var s2 T2)))
  (($smtx_is_binder_x s1 T1 ($sm_forall s2 T2))
    ($smtx_is_var s1 T1 ($sm_Var s2 T2)))
  (($smtx_is_binder_x s1 T1 ($sm_lambda s2 T2))
    ($smtx_is_var s1 T1 ($sm_Var s2 T2)))
  (($smtx_is_binder_x s1 T1 ($sm_choice s2 T2))
    ($smtx_is_var s1 T1 ($sm_Var s2 T2)))
  (($smtx_is_binder_x s1 T1 x) $smt_builtin_false)
  )
)
  
; Substitution
; program: $smtx_substitute
; Used to define $smtx_eval_exists_rec.
; ($smtx_substitute s T u t) returns the term t where the
; variable ($sm_Var s T) is replaced by u.
(program $smtx_substitute
  ((s $smt_builtin_String) (T $smt_Type) (u $smt_Term)
   (f $smt_Term) (a $smt_Term) (z $smt_Term))
  :signature ($smt_builtin_String $smt_Type $smt_Term $smt_Term) $smt_Term
  (
  (($smtx_substitute s T u ($sm_apply f a))
    ($smt_builtin_ite ($smtx_is_binder_x s T f)
      ($sm_apply f a) ; avoid issues with shadowing
      ($sm_apply ($smtx_substitute s T u f) ($smtx_substitute s T u a))))
  (($smtx_substitute s T u z)
    ; if x is z, we are now the constant with the given interpretation
    ($smt_builtin_ite ($smtx_is_var s T z) u z))
  )
)

;;; Datatypes

(program $smtx_model_eval_dt_cons
  ((s $smt_builtin_String) (d $smt_Datatype) (n $smt_builtin_Int))
  :signature ($smt_builtin_String $smt_Datatype $smt_builtin_Int) $smt_Value
  (
  (($smtx_model_eval_dt_cons s d n)
    ; must ensure its type is not none, which implies it is a valid index
    ($smt_builtin_ite
      ($smt_builtin_Teq ($smtx_typeof_dt_cons_value s d n) $tsm_none)
      $vsm_not_value
      ($vsm_DtCons s d n)))
  )
)

(program $smtx_model_eval_dt_sel
  ((n $smt_builtin_Int) (m $smt_builtin_Int) (v1 $smt_Value)
   (s $smt_builtin_String) (d $smt_Datatype))
  :signature ($smt_builtin_String $smt_Datatype $smt_builtin_Int $smt_builtin_Int $smt_Value) $smt_Value
  (
  (($smtx_model_eval_dt_sel s d n m v1)
    ; must ensure its type is T
    ($smt_builtin_ite ($smt_builtin_Teq ($smtx_typeof_value v1) ($tsm_Datatype s d))
      ; check if the head of the apply term is ($vsm_DtCons s d n)
      ($smt_builtin_ite ($smt_builtin_veq ($vsm_apply_head v1) ($vsm_DtCons s d n))
        ($vsm_apply_arg_nth v1 m)
        ; wrongly applied selector
        $vsm_not_value)
      ; ill typed term
      $vsm_not_value))
  )
)

(program $smtx_model_eval_dt_tester
  ((s $smt_builtin_String) (d $smt_Datatype) (n $smt_builtin_Int) (v1 $smt_Value))
  :signature ($smt_builtin_String $smt_Datatype $smt_builtin_Int $smt_Value) $smt_Value
  (
  (($smtx_model_eval_dt_tester s d n v1)
    ; must ensure its type is correct
    ($smt_builtin_ite ($smt_builtin_Teq ($smtx_typeof_value v1) ($tsm_Datatype s d))
      ; check if the head of the apply term is ($vsm_DtCons s d n)
      ($vsm_bool ($smt_builtin_veq ($vsm_apply_head v1) ($vsm_DtCons s d n)))
      ; ill typed term
      $vsm_not_value))
  )
)

(program $smtx_model_eval_dt_updater
  ((s $smt_builtin_String) (d $smt_Datatype)
   (n $smt_builtin_Int) (m $smt_builtin_Int) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_builtin_String $smt_Datatype $smt_builtin_Int $smt_builtin_Int $smt_Value $smt_Value) $smt_Value
  (
  ; TODO
  (($smtx_model_eval_dt_updater s d n m v1 v2) $vsm_not_value)
  )
)

; apply 

; program: $smtx_model_eval_apply
; We call ($smtx_model_eval_apply value_f value_i) when
; evaluating (f i) whose values are value_f and value_i
; respectively. If value_f is a map value, then we extract
; the map and call the map lookup routine.
(program $smtx_model_eval_apply
  ((m $smt_Map) (i $smt_Value) (f $smt_Value) (v $smt_Value)
   (s $smt_builtin_String) (T $smt_Type) (t $smt_Term))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  ; If a Herbrand interpretation, apply it to the next value.
  (($smtx_model_eval_apply ($vsm_apply f v) i)  ($vsm_apply ($vsm_apply f v) i))
  ; The function evaluated to a map value, call the map lookup.
  (($smtx_model_eval_apply ($vsm_map m) i)      ($smtx_msm_lookup m i))
  ; Lambda case
  ;(($smtx_model_eval_apply ($vsm_lambda s T t) i)
    ; substitutes into body
    ;($smtx_model_eval ($smtx_substitute s T ($sm_Const i T) t)))
  ; The function did not evaluate to a map value, we fail.
  (($smtx_model_eval_apply v i)                 $vsm_not_value)
  )
)
;;; Other model evaluation functions

(program $smtx_model_eval_not
  ((x1 $smt_builtin_Bool) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_not ($vsm_bool x1)) ($vsm_bool ($smt_apply_1 "not" x1)))
  (($smtx_model_eval_not t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_and
  ((x1 $smt_builtin_Bool) (x2 $smt_builtin_Bool) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_and ($vsm_bool x1) ($vsm_bool x2)) ($vsm_bool ($smt_apply_2 "and" x1 x2)))
  (($smtx_model_eval_and t1 t2) $vsm_not_value)
  )
)


; An evaluator for all terms that we can reason about models.
; This is a recursive call.
; invariant: this must be a total function
; invariant: unless this method returns $vsm_not_value, it must be such that
;            it represents a unique SMT-LIB value, i.e. ($vsm_term t) is
;            forbidden unless t denotes a value.
(program $smtx_model_eval
  ((f $smt_Term) (v $smt_Value) (T $smt_Type) (d $smt_Datatype)
   (b $smt_builtin_Bool) (w $smt_builtin_Int) (n $smt_builtin_Int)
   (m $smt_builtin_Int) (r $smt_builtin_Real) (s $smt_builtin_String)
   ; generic parameters that may appear in terms to pattern match
   (x1 $smt_Term) (x2 $smt_Term) (x3 $smt_Term) (x4 $smt_Term) (x5 $smt_Term))
  :signature ($smt_Term) $smt_Value
  (

  (($smtx_model_eval ($sm_bool b))      ($vsm_bool b))
  (($smtx_model_eval ($sm_numeral n))   ($vsm_numeral n))
  (($smtx_model_eval ($sm_rational r))  ($vsm_rational r))
  (($smtx_model_eval ($sm_string s))    ($vsm_string s))
  (($smtx_model_eval ($sm_binary w n))
    ; must be legal width and value
    ($smt_builtin_ite 
      ($smt_builtin_and
        ($smt_builtin_z_<= $smt_builtin_z_zero w)
        ($smt_builtin_z_= n ($smt_builtin_mod n ($smtx_pow2 w))))
      ($vsm_binary w n)
      $vsm_not_value))
  ; evaluation of standard SMT symbols
  ; These calls will reference helper methods above, e.g. of the form
  ; $smtx_model_eval_*, or call builtin methods e.g. $smtx_eval_exists_rec.
  (($smtx_model_eval ($sm_not x1)) ($smtx_model_eval_not ($smtx_model_eval x1)))
  (($smtx_model_eval ($sm_and x1 x2)) ($smtx_model_eval_and ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval ($sm_= x1 x2)) ($smtx_model_eval_= ($smtx_model_eval x1) ($smtx_model_eval x2)))

  ; quantifiers
  (($smtx_model_eval ($sm_apply ($sm_exists s T) x1))
    ($smt_apply_3 "tforall" s T x1))
  (($smtx_model_eval ($sm_apply ($sm_forall s T) x1))
    ($smt_apply_3 "texists" s T x1))
  (($smtx_model_eval ($sm_apply ($sm_lambda s T) x1)) ($vsm_lambda s T x1))
  (($smtx_model_eval ($sm_apply ($sm_choice s T) x1))
    ($smt_apply_3 "tchoice" s T x1))
  ; datatypes
  (($smtx_model_eval ($sm_DtCons s d n)) ($smtx_model_eval_dt_cons s d n))
  (($smtx_model_eval ($sm_apply ($sm_DtSel s d n m) x1))
    ($smtx_model_eval_dt_sel s d n m ($smtx_model_eval x1)))
  (($smtx_model_eval ($sm_apply ($sm_DtTester s d n) x1))
    ($smtx_model_eval_dt_tester s d n ($smtx_model_eval x1)))
  (($smtx_model_eval ($sm_apply ($sm_apply ($sm_DtUpdater s d n m) x1) x2))
    ($smtx_model_eval_dt_updater s d n m ($smtx_model_eval x1) ($smtx_model_eval x2)))
  ; Apply case. We evaluate f and x1 separately and then call the
  ; $smtx_model_eval_apply above. We expect f to be an uninterpreted
  ; function whose model evaluation is an SMT-LIB map in this case.
  ; All interpreted f should be handled in the evaluation cases above.
  (($smtx_model_eval ($sm_apply f x1))
    ($smtx_model_eval_apply ($smtx_model_eval f) ($smtx_model_eval x1)))
  ; Constants, which carry their value. They additionally guard their value
  ; to ensure it has type T.
  (($smtx_model_eval ($sm_Const v T))
    ($smt_builtin_ite ($smt_builtin_Teq ($smtx_typeof_value v) T)
      v
      $vsm_not_value))
  (($smtx_model_eval x1)   $vsm_not_value)
  )
)


;;;;;;;;;;;;;;;;;;;;;;

; auxiliary definitions for defining $eo_to_smt / $eo_to_smt_type


; helper for CPC Tuple
; In $eo_to_smt_type, (Tuple x1 x2) returns
;   ($eo_to_smt_type_tuple ($eo_to_smt_type x1) ($eo_to_smt_type x2))
; and TupleUnit returns
;   ($tsm_Datatype $smt_builtin_str_tuple_name ($dt_sum $dtc_unit $dt_null)).
(program $eo_to_smt_type_tuple
  ((U $smt_Type) (T $smt_Type) (s $smt_builtin_String) (c $smt_DatatypeCons))
  :signature ($smt_Type $smt_Type) $smt_Type
  (
  (($eo_to_smt_type_tuple U ($tsm_Datatype $smt_builtin_str_tuple_name ($dt_sum c $dt_null)))
    ($tsm_Datatype $smt_builtin_str_tuple_name ($dt_sum ($dtc_cons U c) $dt_null)))
  (($eo_to_smt_type_tuple U T) $tsm_none)
  )
)


(program $eo_to_smt_type 
  ((T Type) (n1 $smt_builtin_Int) (s $smt_builtin_String) (d $smt_Datatype)
  (T1 Type) (T2 Type) (T3 Type) (T4 Type) (T5 Type)
  (x1 T1) (x2 T2) (x3 T3) (x4 T4) (x5 T5))
  :signature (Type) $smt_Type
  (
  (($eo_to_smt_type Bool)               $tsm_Bool)
  (($eo_to_smt_type ($eo_Datatype s d)) ($tsm_Datatype s d))
  (($eo_to_smt_type Int) $tsm_Int)
  (($eo_to_smt_type Real) $tsm_Real)
  (($eo_to_smt_type (BitVec ($eo_numeral n1))) ($tsm_BitVec n1))
  (($eo_to_smt_type Char) $tsm_Char)
  (($eo_to_smt_type (Seq x1)) ($tsm_Seq ($eo_to_smt_type x1)))

  (($eo_to_smt_type T)                  $tsm_none)
  )
)

; helper for CPC tuple constructor
; In eo_to_smt, (tuple x1 x2) returns
;   ($sm_apply ($smtx_tuple_app_extend x1 ($eo_to_smt_type ($eo_typeof x2))) ($eo_to_smt x2))
; and tuple.unit returns
;   ($sm_DtCons $smt_builtin_str_tuple_name ($dt_sum $dtc_unit $dt_null) $smt_builtin_z_zero).
; Given an application of (tuple a1 ... an), returns the same application
; but where now tuple is the instance of the tuple constructor that expects
; another argument of type T.
(program $smtx_tuple_app_extend
  ((t $smt_Term) (f $smt_Term) (a $smt_Term) (T $smt_Type) (s $smt_builtin_String) (c $smt_DatatypeCons))
  :signature ($smt_Term $smt_Type) $smt_Term
  (
  (($smtx_tuple_app_extend ($sm_apply f a) T)
    ($sm_apply ($smtx_tuple_app_extend f T) a))
  (($smtx_tuple_app_extend ($sm_DtCons $smt_builtin_str_tuple_name ($dt_sum c $dt_null) $smt_builtin_z_zero) T)
    ; extend the datatype with a new argument, we are still the first constructor
    ($sm_DtCons
      $smt_builtin_str_tuple_name
      ($dt_sum ($smtx_dtc_concat c ($dtc_cons T $dtc_unit)) $dt_null)
      $smt_builtin_z_zero))
  (($smtx_tuple_app_extend s T) $sm_none)
  )
)


; In eo_to_smt, (tuple.select x1 x2) returns
;   ($eo_to_smt_tuple_select ($eo_to_smt_type ($eo_typeof x2)) ($eo_to_smt x1) ($eo_to_smt x2))
(program $eo_to_smt_tuple_select
  ((T $smt_Type) (d $smt_Datatype) (n $smt_builtin_Int) (t $smt_Term))
  :signature ($smt_Type $smt_Term $smt_Term) $smt_Term
  (
  (($eo_to_smt_tuple_select ($tsm_Datatype $smt_builtin_str_tuple_name d) ($sm_numeral n) t)
    ($sm_apply ($sm_DtSel $smt_builtin_str_tuple_name d $smt_builtin_z_zero n) t))
  (($eo_to_smt_tuple_select T n t)                    $sm_none)
  )
)

; In eo_to_smt, (tuple.update x1 x2) returns
;   ($eo_to_smt_tuple_update
;     ($eo_to_smt_type ($eo_typeof x2)) ($eo_to_smt x1) ($eo_to_smt x2))
(program $eo_to_smt_tuple_update
  ((T $smt_Type) (d $smt_Datatype) (n $smt_builtin_Int) (t $smt_Term))
  :signature ($smt_Type $smt_Term $smt_Term) $smt_Term
  (
  (($eo_to_smt_tuple_update ($tsm_Datatype $smt_builtin_str_tuple_name d) ($sm_numeral n) t)
    ($sm_apply ($sm_DtUpdater $smt_builtin_str_tuple_name d $smt_builtin_z_zero n) t))
  (($eo_to_smt_tuple_update T n t)                    $sm_none)
  )
)

; In eo_to_smt, (is x1) returns ($eo_to_smt_tester ($eo_to_smt x1)).
(program $eo_to_smt_tester
  ((s $smt_builtin_String) (d $smt_Datatype) (n $smt_builtin_Int) (t $smt_Term))
  :signature ($smt_Term) $smt_Term
  (
  (($eo_to_smt_tester ($sm_DtCons s d n))  ($sm_DtTester s d n))
  (($eo_to_smt_tester t)                   $sm_none)
  )
)
; In eo_to_smt, (update x1) returns ($eo_to_smt_updater ($eo_to_smt x1)).
(program $eo_to_smt_updater
  ((s $smt_builtin_String) (d $smt_Datatype)
   (n $smt_builtin_Int) (m $smt_builtin_Int) (t $smt_Term))
  :signature ($smt_Term) $smt_Term
  (
  (($eo_to_smt_updater ($sm_DtSel s d n m))  ($sm_DtUpdater s d n m))
  (($eo_to_smt_updater t)                     $sm_none)
  )
)

; (update x1) returns
;   ($eo_to_smt_updater ($eo_to_smt x1))

(program $eo_to_smt 
  ((b $smt_builtin_Bool) (n $smt_builtin_Int) (m $smt_builtin_Int) (r $smt_builtin_Rat)
   (s $smt_builtin_String) (w $smt_builtin_Int) (d $smt_Datatype)
   (T Type) (U Type) (T1 Type) (T2 Type) (T3 Type) (T4 Type) (T5 Type)
   (f (-> U T)) (y U) (x1 T1) (x2 T2) (x3 T3) (x4 T4) (x5 T5))
  :signature (T) $smt_Term
  (
  (($eo_to_smt ($eo_bool b))        ($sm_bool b))
  (($eo_to_smt ($eo_numeral n))     ($sm_numeral n))
  (($eo_to_smt ($eo_rational r))    ($sm_rational r))
  (($eo_to_smt ($eo_string s))      ($sm_string s))
  (($eo_to_smt ($eo_binary w n))    ($sm_binary w n))
  (($eo_to_smt ($eo_Var s T))       ($sm_Var s ($eo_to_smt_type T)))
  (($eo_to_smt ($eo_DtCons s d n))  ($sm_DtCons s d n))
  (($eo_to_smt ($eo_DtSel s d n m)) ($sm_DtSel s d n m))
  (($eo_to_smt (not x1)) ($sm_not ($eo_to_smt x1)))
  (($eo_to_smt (and x1 x2)) ($sm_and ($eo_to_smt x1) ($eo_to_smt x2)))
  (($eo_to_smt (= x1 x2)) ($sm_= ($eo_to_smt x1) ($eo_to_smt x2)))

  ; TODO: maybe a datatype constructor or selector???
  (($eo_to_smt (f y))               ($sm_apply ($eo_to_smt f) ($eo_to_smt y)))
  (($eo_to_smt y)                   $sm_none)
  )
)

; program: $eo_model_sat
; note: F is satisfied by the model if F evaluates to the SMT-LIB value denoting true.
; We expect the input to this method to be a Eunoia term denoting an SMT-LIB formula
; (term of Boolean type).
(program $eo_model_sat ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_sat F) ($smt_builtin_ite ($smt_builtin_veq ($smtx_model_eval ($eo_to_smt F)) $vsm_true) true false))
  )
)
(program $eo_model_unsat ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_unsat F) ($smt_builtin_ite ($smt_builtin_veq ($smtx_model_eval ($eo_to_smt F)) $vsm_false) true false))
  )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_end

; ********** temporary delete once old model is deleted
(program $mk_vsm_bool ((b $smt_builtin_Bool))
  :signature ($smt_builtin_Bool) $smt_Value
  (
  (($mk_vsm_bool b) ($vsm_bool b))
  )
)
(program $mk_sm_const ((v $smt_Value) (T $smt_Type))
  :signature ($smt_Value $smt_Type) $smt_Term
  (
  (($mk_sm_const v T) ($sm_Const v T))
  )
)
(program $eovc_symm ((F Bool))
  :signature (Bool) Bool
  (
  (($eovc_symm F) (eo::define ((_v0 ($eo_prog_symm ($eo_pf F)))) (eo::requires ($eo_typeof F) Bool (eo::requires ($eo_model_sat F) true (eo::requires ($eo_typeof _v0) Bool (eo::requires ($eo_model_unsat _v0) true true))))))
  )
)
(echo "smt-meta $eovc_symm :deps $eo_proven $smtx_hash $eo_reverse_hash $smtx_value_hash $smtx_reverse_value_hash $eo_Bool $eo_Type $eo_fun_type $eo_apply $eo_mk_apply $smtx_typeof_value $smtx_substitute $mk_vsm_bool $mk_sm_const ")
