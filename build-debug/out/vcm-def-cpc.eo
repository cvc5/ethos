; trim-defs: $eovc_bool-eq-true
; #trim-defs: 40
(declare-const Int Type)
(declare-consts <numeral> Int)
(declare-const Real Type)
(declare-consts <rational> Real)
(declare-const Char Type)
(declare-const Seq (-> Type Type))
(declare-consts <string> (Seq Char))
(define $eo_Numeral () Int)
(define $eo_Rational () Real)
(define $eo_String () (Seq Char))
(define $eo_Binary () Type)
(program $eo_typeof ((T Type))
  :signature (T) Type)
(program $eo_fail_prog ()
  :signature (Bool) Bool
  (
  (($eo_fail_prog true) true)
  )
)
(define $eo_fail () ($eo_fail_prog false))
(program $eo_if_both ((b1 Bool) (b2 Bool))
  :signature (Bool Bool) Bool
  (
  (($eo_if_both true true)  true)
  (($eo_if_both b1 b2)      false)
  )
)
(program $eo_requires_eq ((T Type) (U Type) (x1 T) (x3 U))
  :signature (T T U) U
  (
  (($eo_requires_eq x1 x1 x3) x3)
  )
)
; This file defines a deep embedding of SMT-LIB into Eunoia.
; It is used for two purposes:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin Eunoia functions, e.g. $eo_add.
; 2. It is used to define the end signature for defining the model semantics of SMT-LIB.

; All of the functions in this file will be handled by smt_meta.

;;; declarations to define literal types

; The type of $smt_apply_* terms.
; If a term has this type, we know it is an SMT-LIB type,
; but we don't know which one from ordinary type checking.
(declare-const $smt_BuiltinType Type)

; The operator of $smt_apply_* terms
(define $smt_id () $eo_String)

; note: decimal and hexadecimal omitted for now.

;;; Deep embedding of SMT-LIB operator applications into Eunoia

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_type_0
  ((op $smt_id :opaque))
  Type)
(declare-parameterized-const $smt_type_1
  ((W1 Type :implicit) (op $smt_id :opaque) (x1 W1 :opaque))
  Type)
(declare-parameterized-const $smt_apply_0
  ((op $smt_id :opaque))
  $smt_BuiltinType)
(declare-parameterized-const $smt_apply_1
  ((W1 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_2
  ((W1 Type :implicit) (W2 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_3
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_4
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_5
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque) (x5 W5 :opaque)) $smt_BuiltinType)

; Handles the corner case of SMT-LIB equality, which we use for Eunoia terms as well.
(declare-parameterized-const $smt_apply_=
  ((W Type :implicit) (x1 W :opaque) (x2 W :opaque))
  $smt_BuiltinType)

; builtin types, which print as e.g. "sm.Int".
(declare-parameterized-const $smt_builtin_type_0
  ((op $smt_id :opaque))
  Type)
; NOTE: the fact that x1 is not opaque indicates that
; bitvectors print as (_ BitVec w) not (BitVec w).
(declare-parameterized-const $smt_builtin_type_1
  ((W1 Type :implicit) (op $smt_id :opaque) (x1 W1))
  Type)

(define $smt_builtin_Bool () ($smt_type_0 "Bool"))
(define $smt_builtin_Int () ($smt_type_0 "Int"))
(define $smt_builtin_Real () ($smt_type_0 "Real"))
(define $smt_builtin_String () ($smt_type_0 "String"))
(define $smt_builtin_true () ($smt_apply_0 "true"))
(define $smt_builtin_false () ($smt_apply_0 "false"))
(define $smt_builtin_= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_= x1 x2))
(define $smt_builtin_ite ((W Type :implicit) (b $smt_builtin_Bool) (x1 W) (x2 W)) ($smt_apply_3 "ite" b x1 x2))
(define $smt_builtin_z_zero () ($smt_apply_0 "0"))
(define $smt_builtin_z_one () ($smt_apply_0 "1"))
(define $smt_builtin_z_two () ($smt_apply_0 "2"))
(define $smt_builtin_q_zero () ($smt_apply_0 "0/1"))
(define $smt_builtin_add ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "+" x1 x2))
(define $smt_builtin_mul ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "*" x1 x2))
(define $smt_builtin_neg ((W Type :implicit) (x1 W)) ($smt_apply_1 "-" x1))
(define $smt_builtin_div ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "div" x1 x2))
(define $smt_builtin_mod ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "mod" x1 x2))
(define $smt_builtin_not ((b $smt_builtin_Bool)) ($smt_apply_1 "not" b))
(define $smt_builtin_and ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "and" b1 b2))
(define $smt_builtin_or ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "or" b1 b2))
(define $smt_builtin_z_inc ((W Type :implicit) (x1 W)) ($smt_apply_1 "+ 1" x1))
(define $smt_builtin_z_dec ((W Type :implicit) (x1 W)) ($smt_apply_1 "+ -1" x1))

; TODO: ite

; In this signature, we heavily use references to the Datatypes corresponding
; to the final deep embeddings of Eunoia terms (eo.Term) and SMT-LIB terms
; (sm.Term), where the latter is a subfield type of the former.
; Opaque arguments of a symbol X will be an argument of the constructor eo.X
; (respectively sm.X). Symbols with no

; We introduce datatype constructors for these datatypes ($smd_eo.X and $smd_sm.X)
; respectively. It is important that we mark their arguments as :opaque, as this
; correctly models the pattern matching in the smt-meta later.

; Note that these datatypes will be renamed and replaced by their definitions
; which is hardcoded into smt_meta.smt2.
; We could also have these auto-generated, but leads to complications when it
; comes to printing the argument types, as e.g. the argument to sm.Numeral is
; an SMT-LIB numeral, not a symbolic SMT term.

;;; Final deep embedding datatypes

; Now, we introduce placeholders for the final deep embedding.
; - $smt_Term, $smt_Type, $smt_Value are introduced as placeholders for the final datatypes in the deep embedding.
; - The SMT-like literals are declared for $smt_Term.
; - 

; A Eunoia term.
; This will be replaced by the datatype eo.Term in the final encoding.
(declare-const $eo_Term Type)

; An atomic SMT-LIB type.
; This will be replaced by the datatype tsm.Type in the final encoding.
(declare-const $smt_Type Type)

; An atomic SMT-LIB term.
; This will be replaced by the datatype sm.Term in the final encoding.
(declare-const $smt_Term Type)

; An SMT-LIB value.
; This will be replaced by the datatype vsm.Value in the final encoding.
(declare-const $smt_Value Type)

; The type used to define values for functions, arrays and sets in SMT-LIB.
(declare-const $smt_Map Type)

; The type used to define values for sequences in SMT-LIB.
(declare-const $smt_Seq Type)

;;; SMT type datatype constructors

; The Boolean type
(declare-const $smd_tsm.Bool $smt_Type)
(define $tsm_Bool () $smd_tsm.Bool)

; Uninterpreted sorts
(declare-parameterized-const $smd_tsm.USort
  ((id $smt_builtin_Int :opaque)) $smt_Type)
(define $tsm_USort ((id $smt_builtin_Int)) ($smd_tsm.USort id))

; The sort of a term that doesn't have an SMT-LIB type.
; This is used as an error condition
(declare-parameterized-const $smd_tsm.NullSort
  ((id $smt_builtin_Int :opaque)) $smt_Type)
(define $tsm_NullSort ((id $smt_builtin_Int)) ($smd_tsm.NullSort id))

;;; SMT term datatype constructors

; the literal types
(declare-parameterized-const $smd_sm.Bool
  ((b $smt_builtin_Bool :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Numeral
  ((n $smt_builtin_Int :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Rational
  ((r $smt_builtin_Real :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.String
  ((s ($smt_type_0 "String") :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Binary
  ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $smt_Term)

; Free constants
(declare-parameterized-const $smd_sm.Const ((v $smt_Value :opaque)) $smt_Term)
(define $sm_Const ((v $smt_Value)) ($smd_sm.Const v))

;;; SMT value datatype constructors

; A value denoting a map.
; note: we store the hash of its type.
(declare-parameterized-const $smd_vsm.Map
  ((T $smt_builtin_Int :opaque) (m $smt_Map :opaque))
  $smt_Value)
(define $vsm_map ((T $smt_builtin_Int) (m $smt_Map))
  ($smd_vsm.Map T m))

; A value denoting a sequence.
; note: we store the hash of its type.
(declare-parameterized-const $smd_vsm.Seq
  ((T $smt_builtin_Int :opaque) (s $smt_Seq :opaque))
  $smt_Value)
(define $vsm_seq ((T $smt_builtin_Int) (s $smt_Seq))
  ($smd_vsm.Seq T s))

; A value denoting an uninterpreted constant.
; note: we store the hash of its type.
(declare-parameterized-const $smd_vsm.UConst
  ((T $smt_builtin_Int :opaque) (id $smt_builtin_Int :opaque))
  $smt_Value)
(define $vsm_uconst ((T $smt_builtin_Int) (id $smt_builtin_Int))
  ($smd_vsm.UConst T id))

; A value represented by an SMT-LIB term. This is used for types
; where terms are used to denote the values of that type, e.g.
; SMT-LIB numerals for Int.
(declare-parameterized-const $smd_vsm.Term
  ((t $smt_Term :opaque))
  $smt_Value)
(define $vsm_term ((t $smt_Term)) ($smd_vsm.Term t))

; Apply values (for Herbrand interpretations).
(declare-parameterized-const $smd_vsm.Apply
  ((f $smt_Value :opaque) (a $smt_Value :opaque))
  $smt_Value)
(define $vsm_apply ((f $smt_Value) (a $smt_Value))
  ($smd_vsm.Apply f a))

; Denotes a failure case for values.
(declare-const $smd_vsm.NotValue $smt_Value)
(define $vsm_not_value () $smd_vsm.NotValue)

;;; SMT map value datatype constructors

; Constructs a map value where i is mapped to e.
(declare-parameterized-const $smd_msm.cons
  ((i $smt_Value :opaque) (e $smt_Value :opaque) (m $smt_Map :opaque))
  $smt_Map)
(define $msm_cons ((i $smt_Value) (e $smt_Value) (m $smt_Map))
  ($smd_msm.cons i e m))

; Constructs a map value where all indices are mapped to e.
(declare-parameterized-const $smd_msm.default
  ((e $smt_Value :opaque))
  $smt_Map)
(define $msm_default ((e $smt_Value)) ($smd_msm.default e))

;;; SMT sequence value datatype constructors

(declare-parameterized-const $smd_ssm.cons
  ((i $smt_Value :opaque) (s $smt_Seq :opaque))
  $smt_Seq)
(define $ssm_cons ((i $smt_Value) (s $smt_Seq)) ($smd_ssm.cons i s))

(declare-parameterized-const $smd_ssm.empty () $smt_Seq)
(define $ssm_empty () $smd_ssm.empty)

;;; Other value utilities

; a pair of values, uses $vsm_apply for now
(define $vsm_Pair () $smt_Value)
(define $vsm_Pair_mk ((v1 $smt_Value) (v2 $smt_Value)) ($vsm_apply v1 v2))

; program: $vsm_Pair_first
; return: The first element in the pair
(program $smtx_vsm_Pair_first ((t $smt_Value) (s $smt_Value) (v $vsm_Pair))
  :signature ($vsm_Pair) $smt_Value
  (
  (($smtx_vsm_Pair_first ($vsm_Pair_mk t s))   t)
  (($smtx_vsm_Pair_first v)                    $vsm_not_value)
  )
)
; program: $vsm_Pair_second
; return: The second element in the pair
(program $smtx_vsm_Pair_second ((t $smt_Value) (s $smt_Value) (v $vsm_Pair))
  :signature ($vsm_Pair) $smt_Value
  (
  (($smtx_vsm_Pair_second ($vsm_Pair_mk t s))  s)
  (($smtx_vsm_Pair_second v)                   $vsm_not_value)
  )
)

; a list of values, uses $vsm_seq
(define $vsm_List () $smt_Value)
(define $vsm_List_empty () ($vsm_seq $smt_builtin_z_zero $ssm_empty))
(program $smtx_vsm_List_cons ((T $smt_builtin_Int) (s $smt_Seq) (v $smt_Value) (vs $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_vsm_List_cons v ($vsm_seq T s))  ($vsm_seq T ($ssm_cons v s)))
  (($smtx_vsm_List_cons v vs)              $vsm_not_value)
  )
)

;;; Eunoia datatype constructors

; The type of types
(declare-const $smd_eo.Type $eo_Term)
(define $eo_Type () $smd_eo.Type)

; The Eunoia representation of "stuckness".
(declare-const $smd_eo.Stuck $eo_Term)
(define $eo_stuck () $smd_eo.Stuck)

; An application of a Eunoia term
(declare-parameterized-const $smd_eo.Apply
  ((f $eo_Term :opaque) (a $eo_Term :opaque))
  $eo_Term)
(define $eo_apply ((x $eo_Term) (y $eo_Term)) ($smd_eo.Apply x y))

; Function type, which Eunoia function type reduces to
(declare-parameterized-const $smd_eo.FunType () $eo_Term)
(define $eo_fun_type () $smd_eo.FunType)

; The Eunoia representation of an SMT-LIB term.
(declare-parameterized-const $smd_eo.SmtTerm ((t $smt_Term :opaque)) $eo_Term)
(define $eo_smt_term ((t $smt_Term)) ($smd_eo.SmtTerm t))

; The Eunoia representation of an SMT-LIB type.
(declare-parameterized-const $smd_eo.SmtType ((t $smt_Type :opaque)) $eo_Term)
(define $eo_smt_type ((T $smt_Type)) ($smd_eo.SmtType T))

; Represents a Eunoia variable in the final deep embedding.
; Note that we embed only the *hash* of its type. This simplifies the
; Eunoia datatype in the final embedding.
(declare-parameterized-const $smd_eo.Var
  ((s $smt_builtin_String :opaque) (T $smt_builtin_Int :opaque))
  $eo_Term)
(define $eo_Var ((s $smt_builtin_String) (T $smt_builtin_Int)) 
  ($smd_eo.Var s T))

;;; External datatype access

(define $sm_mk_true () ($smd_sm.Bool $smt_builtin_true))
(define $sm_mk_false () ($smd_sm.Bool $smt_builtin_false))
(define $sm_mk_bool ((c $smt_builtin_Bool))
  ($smd_sm.Bool c))
(define $sm_mk_z ((n $smt_builtin_Int))
  ($smd_sm.Numeral n))
(define $sm_mk_q ((r $smt_builtin_Real))
  ($smd_sm.Rational r))
(define $sm_mk_str ((s $smt_builtin_String))
  ($smd_sm.String s))
(define $sm_binary ((w $smt_builtin_Int) (n $smt_builtin_Int))
  ($smd_sm.Binary w n))

;(define $smt_Int () ($smt_builtin_type_0 "Int"))
;(define $smt_Real () ($smt_builtin_type_0 "Real"))
;(define $smt_BitVec ((w $smt_builtin_Int)) (_ ($smt_builtin_type_1 "BitVec") w))
;(define $smt_String () ($smt_builtin_type_0 "String"))

(define $vsm_true () ($vsm_term $sm_mk_true))
(define $vsm_false () ($vsm_term $sm_mk_false))

; return: The embedding of (-> T1 T2).
; note: Since the Eunoia function type is an atomic term, this becomes a
;       curried apply.
(define $eo_mk_fun_type ((T1 $eo_Term) (T2 $eo_Term)) 
  ($eo_apply ($eo_apply $eo_fun_type T1) T2))

(define $eo_null_type ()
  ($eo_smt_type ($tsm_NullSort $smt_builtin_z_zero)))

;;; Defining parametric bitvector operators

; The operators in this section are needed to reason about the parametric
; operations on the Eunoia binary literal type.

; program: $smtx_pow2
; return: >
;   The integer value of 2 raised to the i^th power.
; note: We expect i to be non-negative.
(program $smtx_pow2 ((i $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_pow2 i)
    ($smt_apply_3 "ite" ($smt_apply_2 "<=" i $smt_builtin_z_zero)
      $smt_builtin_z_one
      ($smt_builtin_mul $smt_builtin_z_two
        ($smtx_pow2 ($smt_apply_2 "-" i $smt_builtin_z_one)))))
  )
)

; program: $smtx_bit
; return: >
;   true iff the i^th bit of a binary with integer value x is set. Note this
;   method is agnostic to bitwidth. 
(program $smtx_bit ((x $smt_builtin_Int) (i $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Bool
  (
  (($smtx_bit x i) ($smt_apply_1 "= 1" ($smt_builtin_mod ($smt_builtin_div x ($smtx_pow2 i)) $smt_builtin_z_two)))
  )
)

; program: $smtx_binary_and
; return: >
;   The integer value of the binary value obtained by taking the bitwise and of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This value will be
;   taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w.
(program $smtx_binary_and ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_and w n1 n2)
     ($smt_apply_3 "ite" ($smt_apply_= w $smt_builtin_z_zero) $smt_builtin_z_zero
     ($smt_apply_3 "ite" ($smt_apply_= w $smt_builtin_z_one)
       ($smt_apply_3 "ite"
        ($smt_builtin_and
          ($smt_apply_= n1 $smt_builtin_z_one)
          ($smt_apply_= n2 $smt_builtin_z_one))
        $smt_builtin_z_one $smt_builtin_z_zero)
       ($smt_builtin_add
         ($smtx_binary_and ($smt_apply_2 "-" w $smt_builtin_z_one) n1 n2)
         ($smt_builtin_mul ($smtx_pow2 w)
            ($smt_apply_3 "ite" ($smt_builtin_and ($smtx_bit n1 w) ($smtx_bit n2 w)) $smt_builtin_z_one $smt_builtin_z_zero))))))
  )
)

; program: $smtx_binary_or
; return: >
;   The integer value of the binary value obtained by taking the bitwise or of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This is equal to
;   n1+n2-($smtx_binary_and w n1 n2). This value will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w.
(program $smtx_binary_or ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_or w n1 n2)
    ($smt_apply_3 "+" n1 n2 ($smt_builtin_neg ($smtx_binary_and w n1 n2))))
  )
)

; program: $smtx_binary_xor
; return: >
;   The integer value of the binary value obtained by taking the bitwise xor of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This is equal to
;   n1+n2-(2*($smtx_binary_and w n1 n2)). This value will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w.
(program $smtx_binary_xor ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_xor w n1 n2)
    ($smt_apply_3 "+" n1 n2 ($smt_builtin_neg ($smt_apply_1 "* 2" ($smtx_binary_and w n1 n2)))))
  )
)

; program: $smtx_binary_not
; return: >
;   The integer value of the binary value obtained by taking bitwise not of
;   the binary literal ($eo_binary w n). This is equal to 2^w-(1+n). This value
;   will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n < 2^w.
(program $smtx_binary_not ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_not w n)
    ($smt_apply_2 "-" ($smtx_pow2 w) ($smt_builtin_z_inc n)))
  )
)

; program: $smtx_binary_max
; return: >
;   The integer value of the maximum unsigned binary value of width w. This is
;   equal to 2^w-1.
(program $smtx_binary_max ((w $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_max w) ($smt_builtin_z_dec ($smtx_pow2 w)))
  )
)

; program: $smtx_binary_concat
; return: >
;   The integer value of the binary value obtained by concatenating binary
;   literals ($eo_binary w1 n1) and ($eo_binary w2 n2). This is equal to
;   n1*2^w2 + n2. Note the return value does not depend on w1. This value will
;   be taken modulo 2^(w1+w2).
; note: >
;   Assumes that 0 <= n1 < 2^w1, 0 <= n2 < 2^w2.
(program $smtx_binary_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_concat w1 n1 w2 n2)
    ($smt_builtin_add ($smt_builtin_mul n1 ($smtx_pow2 w2)) n2))
  )
)

; program: $smtx_binary_extract
; return: >
;   The integer value of the binary value obtained by extracting bits x1
;   through x2 (inclusive) of binary literal ($eo_binary w n). This is equal
;   to (div n 2^x1). This value will be taken modulo 2^(1+x2-x1).
; note: >
;   Assumes that 0 <= n < 2^w, 0 <= x1 <= x2.
(program $smtx_binary_extract
  ((w $smt_builtin_Int) (n $smt_builtin_Int) (x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_extract w n x1 x2) ($smt_builtin_div n ($smtx_pow2 x1)))
  )
)

; note: Assumes w is legal, makes n legal. We cannot handle errors with
;       w here since we cannot return stuckness.
(define $sm_mk_binary ((w $smt_builtin_Int) (n $smt_builtin_Int))
  ($sm_binary w ($smt_builtin_mod n ($smtx_pow2 w))))

;;; Utilities

(define $eo_mk_bool ((x $smt_builtin_Bool))
  ($eo_smt_term ($sm_mk_bool x)))
(define $eo_mk_numeral ((x $smt_builtin_Int))
  ($eo_smt_term ($sm_mk_z x)))
(define $eo_mk_rational ((x $smt_builtin_Real))
  ($eo_smt_term ($sm_mk_q x)))
(define $eo_mk_string ((x $smt_builtin_String))
  ($eo_smt_term ($sm_mk_str x)))

; define: $eo_binary
; note: >
;   This should be used in pattern matching only, where it is assume that
;   it will match "legal" binary values only.
(define $eo_binary ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  ($eo_smt_term ($sm_binary x1 x2)))

; define: $eo_empty_binary
(define $eo_empty_binary ()
  ($eo_binary $smt_builtin_z_zero $smt_builtin_z_zero))

; program: $eo_mk_binary
; return: >
;   A "legal" binary value ($eo_mk_binary w n1), where 0 <= n1 < 2^w, n1 is
;   congruent mod 2^w to n if w is a 32-bit numeral value, or stuck otherwise.
; note: >
;   All binaries considered by Eunoia should run through this method to ensure
;   they are legal. We alternatively use ($eo_smt_term ($sm_mk_binary w n)) if
;   we are sure that w is legal but not n.
(program $eo_mk_binary ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $eo_Term
  (
  (($eo_mk_binary w n)
    ($smt_apply_3 "ite"
      ($smt_builtin_and ($smt_apply_1 "<= 0" w) ($smt_apply_1 ">= 4294967296" w))
      ($eo_smt_term ($sm_mk_binary w n))  ; ensure that n is legal
      $eo_stuck))
  )
)

;;;;;; Eunoia builtin

; We are now ready to define the builtins of Eunoia.
; We define all the Eunoia builtins here that are best to
; define in terms of SMT-LIB operators.

;;; Is okay

; Returns SMT-LIB builtin true/false if x is stuck
(define $smt_builtin_is_ok ((x $eo_Term))
  ($smt_apply_1 "not" ($smt_apply_= x $eo_stuck)))

; program: $eo_is_ok
; implements: $eo_is_ok
(define $eo_is_ok ((x $eo_Term))
  ($eo_mk_bool ($smt_builtin_is_ok x)))

; program: $eo_ite
; implements: $eo_ite
; note: This definition is only used if we are not eagerly flattening evaluation
(define $eo_ite ((x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term))
  ($smt_apply_3 "ite" ($smt_apply_= x1 true)
    x2
  ($smt_apply_3 "ite" ($smt_apply_= x1 false)
    x3
    $eo_stuck)))

; program: $eo_requires
; implements: $eo_requires
; note: This definition is only used if we are not eagerly flattening evaluation
(define $eo_requires ((x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term))
  ($smt_apply_3 "ite" ($smt_apply_= x1 x2)
    ($smt_apply_3 "ite" ($smt_builtin_is_ok x1) x3 x1)
    $eo_stuck))

; note: This definition is only used if we are not eagerly flattening evaluation
; This ensures that stuckness "propagates" through ordinary constant applications.
(program $eo_mk_apply ((x1 $eo_Term) (x2 $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_mk_apply x1 x2) ($eo_apply x1 x2))
  )
)

;;; Boolean operators

; program: $eo_not
; implements: $eo_not
(program $eo_not ((T Type) (b $smt_builtin_Bool) (w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature (T) T
  (
  (($eo_not ($eo_mk_bool b))   ($eo_mk_bool ($smt_apply_1 "not" b)))
  (($eo_not ($eo_binary w n))  ($eo_smt_term ($sm_mk_binary w ($smtx_binary_not w n))))
  )
)

; program: $eo_and
; implements: $eo_and
(program $eo_and
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool) (w $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_and ($eo_mk_bool b1) ($eo_mk_bool b2))
     ($eo_mk_bool ($smt_apply_2 "and" b1 b2)))
  (($eo_and ($eo_binary w n1) ($eo_binary w n2))
     ($eo_smt_term ($sm_mk_binary w ($smtx_binary_and w n1 n2))))
  )
)

; program: $eo_or
; implements: $eo_or
(program $eo_or
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool) (w $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_or ($eo_mk_bool b1) ($eo_mk_bool b2))
     ($eo_mk_bool ($smt_apply_2 "or" b1 b2)))
  (($eo_or ($eo_binary w n1) ($eo_binary w n2))
     ($eo_smt_term ($sm_mk_binary w ($smtx_binary_or w n1 n2))))
  )
)

; program: $eo_xor
; implements: $eo_xor
(program $eo_xor
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool) (w $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_xor ($eo_mk_bool b1) ($eo_mk_bool b2))
     ($eo_mk_bool ($smt_apply_2 "xor" b1 b2)))
  (($eo_xor ($eo_binary w n1) ($eo_binary w n2))
     ($eo_smt_term ($sm_mk_binary w ($smtx_binary_or w n1 n2))))
  )
)

;;; Arithmetic operators

; program: $eo_add
; implements: $eo_add
(program $eo_add
  ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (r1 $smt_builtin_Real) (r2 $smt_builtin_Real))
  :signature (T T) T
  (
  (($eo_add ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($eo_mk_numeral ($smt_builtin_add n1 n2)))
  (($eo_add ($eo_mk_rational r1) ($eo_mk_rational r2))
    ($eo_mk_rational ($smt_builtin_add r1 r2)))
  (($eo_add ($eo_binary w n1) ($eo_binary w n2))
    ($eo_smt_term ($sm_mk_binary w ($smt_builtin_add n1 n2))))  ; don't need to recheck bitwidth
  )
)

(program $eo_mul
  ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (r1 $smt_builtin_Real) (r2 $smt_builtin_Real))
  :signature (T T) T
  (
  (($eo_mul ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($eo_mk_numeral ($smt_builtin_mul n1 n2)))
  (($eo_mul ($eo_mk_rational r1) ($eo_mk_rational r2))
    ($eo_mk_rational ($smt_builtin_mul r1 r2)))
  (($eo_mul ($eo_binary w n1) ($eo_binary w n2))
    ($eo_smt_term ($sm_mk_binary w ($smt_builtin_mul n1 n2))))
  )
)

(program $eo_qdiv
  ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int)
   (r1 $smt_builtin_Real) (r2 $smt_builtin_Real))
  :signature (T T) $eo_Rational
  (
  (($eo_qdiv ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    (eo::define ((r1 ($smt_apply_1 "to_real" n1)))
    (eo::define ((r2 ($smt_apply_1 "to_real" n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $eo_stuck
      ($eo_mk_rational ($smt_apply_2 "/" r1 r2))))))
  (($eo_qdiv ($eo_mk_rational r1) ($eo_mk_rational r2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0/1" r2)
      $eo_stuck
      ($eo_mk_rational ($smt_apply_2 "/" r1 r2))))
  )
)


(program $eo_zdiv ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_zdiv ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $eo_stuck
      ($eo_mk_numeral ($smt_builtin_div n1 n2))))
  (($eo_zdiv ($eo_binary w n1) ($eo_binary w n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      ($eo_smt_term ($sm_binary w ($smtx_binary_max w)))
      ($eo_smt_term ($sm_mk_binary w ($smt_builtin_div n1 n2)))))
  )
)

(program $eo_zmod ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_zmod ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $eo_stuck
      ($eo_mk_numeral ($smt_builtin_mod n1 n2))))
  (($eo_zmod ($eo_binary w n1) ($eo_binary w n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      ($eo_binary w n1)
      ($eo_smt_term ($sm_mk_binary w ($smt_builtin_mod n1 n2)))))
  )
)

(program $eo_is_neg ((T Type) (n1 $smt_builtin_Int) (r1 $smt_builtin_Real))
  :signature (T) Bool
  (
  (($eo_is_neg ($eo_mk_numeral n1))
    ($eo_mk_bool ($smt_apply_1 "> 0" n1)))
  (($eo_is_neg ($eo_mk_rational r1))
    ($eo_mk_bool ($smt_apply_1 "> 0/1" r1)))
  )
)

; program: $eo_neg
; implements: $eo_neg
(program $eo_neg ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (r1 $smt_builtin_Real))
  :signature (T) T
  (
  (($eo_neg ($eo_mk_numeral n1))
    ($eo_mk_numeral ($smt_builtin_neg n1)))
  (($eo_neg ($eo_mk_rational r1))
    ($eo_mk_rational ($smt_builtin_neg r1)))
  (($eo_neg ($eo_binary w n1))
    ($eo_smt_term ($sm_mk_binary w ($smt_builtin_neg n1))))
  )
)


;;; String operators

; program: $eo_len
; implements: $eo_len
(program $eo_len ((T Type) (s1 $smt_builtin_String) (w $smt_builtin_Int) (n1 $smt_builtin_Int))
  :signature (T) $eo_Numeral
  (
  (($eo_len ($eo_mk_string s1))
    ($eo_mk_numeral ($smt_apply_1 "str.len" s1)))
  (($eo_len ($eo_binary w n1))
    ($eo_mk_numeral w))
  )
)

; program: $eo_concat
; implements: $eo_concat
(program $eo_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int)
   (s1 $smt_builtin_String) (s2 $smt_builtin_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_concat ($eo_mk_string s1) ($eo_mk_string s2))
     ($eo_mk_string ($smt_apply_2 "str.++" s1 s2)))
  (($eo_concat ($eo_binary w1 n1) ($eo_binary w2 n2))
     ($eo_mk_binary ($smt_builtin_add w1 w2) ($smtx_binary_concat w1 n1 w2 n2)))
  )
)

; program: $eo_extract
; implements: $eo_extract
(program $eo_extract
  ((s1 $smt_builtin_String) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (n3 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($eo_extract ($eo_mk_string s1) ($eo_mk_numeral n2) ($eo_mk_numeral n3))
     ($eo_mk_string ($smt_apply_3 "str.substr" s1 n2 ($smt_builtin_z_inc ($smt_apply_2 "-" n3 n2)))))
  (($eo_extract ($eo_binary w n1) ($eo_mk_numeral n2) ($eo_mk_numeral n3))
    (eo::define ((nw ($smt_apply_2 "-" n3 n2)))
    ($smt_apply_3 "ite" ($smt_builtin_or ($smt_apply_1 "> 0" n2) ($smt_apply_1 "> 0" nw))
      $eo_empty_binary
      ($eo_mk_binary
        ($smt_builtin_z_inc nw)
        ($smtx_binary_extract w n1 n2 n3)))))
  )
)

; program: $eo_find
; implements: $eo_find
(program $eo_find ((s1 $smt_builtin_String) (s2 $smt_builtin_String))
  :signature ($eo_Term $eo_Term) $eo_Numeral
  (
  (($eo_find ($eo_mk_string s1) ($eo_mk_string s2))
     ($eo_mk_numeral ($smt_apply_3 "str.indexof" s1 s2 $smt_builtin_z_zero)))
  )
)

;;; Conversion operators

; program: $eo_to_z
; implements: $eo_to_z
(program $eo_to_z ((n1 $smt_builtin_Int) (r1 $smt_builtin_Real) (s1 $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Numeral
  (
  (($eo_to_z ($eo_mk_numeral n1))   ($eo_mk_numeral n1))
  (($eo_to_z ($eo_mk_rational r1))  ($eo_mk_numeral ($smt_apply_1 "to_int" r1)))
  (($eo_to_z ($eo_mk_string s1))
    ($smt_apply_3 "ite"
      ($smt_apply_1 "= 1" ($smt_apply_1 "str.len" s1))
      ($eo_mk_numeral ($smt_apply_1 "str.to_code" s1))
      $eo_stuck))
  (($eo_to_z ($eo_binary w n1))     ($eo_mk_numeral n1))
  )
)

; program: $eo_to_q
; implements: $eo_to_q
(program $eo_to_q ((n1 $smt_builtin_Int) (r1 $smt_builtin_Real) (s1 $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Rational
  (
  (($eo_to_q ($eo_mk_numeral n1))   ($eo_mk_rational ($smt_apply_1 "to_real" n1)))
  (($eo_to_q ($eo_mk_rational r1))  ($eo_mk_rational r1))
  )
)

; program: $eo_to_bin
; implements: $eo_to_bin
(program $eo_to_bin ((w $smt_builtin_Int) (w1 $smt_builtin_Int) (n1 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Binary
  (
  (($eo_to_bin ($eo_mk_numeral w) ($eo_mk_numeral n1))  ($eo_mk_binary w n1))
  (($eo_to_bin ($eo_mk_numeral w) ($eo_binary w1 n1))   ($eo_mk_binary w n1))
  )
)

; program: $eo_to_str
; implements: $eo_to_str
(program $eo_to_str ((n1 $smt_builtin_Int) (s1 $smt_builtin_String))
  :signature ($eo_Term) $eo_String
  (
  (($eo_to_str ($eo_mk_numeral n1))
    ($smt_apply_3 "ite"
      ($smt_builtin_and ($smt_apply_1 "<= 0" n1) ($smt_apply_1 "> 196608" n1))
      ($eo_mk_string ($smt_apply_1 "str.from_code" n1))
      $eo_stuck))
  (($eo_to_str ($eo_mk_string s1)) ($eo_mk_string s1))
  ; TODO: technically others here
  )
)

;;; $eo_is_eq

; Returns true if t and s are equivalent values (ground and fully evaluated).
; define: $eo_is_eq
; implements: $eo_is_eq
(define $eo_is_eq ((t $eo_Term) (s $eo_Term))
  ($eo_mk_bool ($smt_apply_3 "and"
    ($smt_builtin_is_ok t)
    ($smt_builtin_is_ok s)
    ($smt_apply_= s t))))

;;; $eo_is_bool

; Returns true if x is a Boolean literal.
; define: $eo_is_bool
; implements: $eo_is_bool
(program $eo_is_bool ((x $eo_Term) (b $smt_builtin_Bool))
  :signature ($eo_Term) Bool
  (
  (($eo_is_bool ($eo_mk_bool b))  true)
  (($eo_is_bool x)                false)
  )
)

;;; Conversion operators

;;; $eo_is_z

; Returns true if x is a numeral literal.
; define: $eo_is_z
; implements: $eo_is_z
(program $eo_is_z ((x $eo_Term) (n $smt_builtin_Int))
  :signature ($eo_Term) Bool
  (
  (($eo_is_z ($eo_mk_numeral n))  true)
  (($eo_is_z x)                   false)
  )
)

;;; $eo_is_q

; Returns true if x is a rational literal.
; define: $eo_is_q
; implements: $eo_is_q
(program $eo_is_q ((x $eo_Term) (r $smt_builtin_Real))
  :signature ($eo_Term) Bool
  (
  (($eo_is_q ($eo_mk_rational r))  true)
  (($eo_is_q x)                   false)
  )
)

;;; $eo_is_bin

; Returns true if x is a binary literal.
; define: $eo_is_bin
; implements: $eo_is_bin
(program $eo_is_bin ((x $eo_Term) (w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($eo_Term) Bool
  (
  (($eo_is_bin ($eo_binary w n))  true)
  (($eo_is_bin x)                 false)
  )
)

;;; $eo_is_str

; Returns true if x is a string literal.
; define: $eo_is_str
; implements: $eo_is_str
(program $eo_is_str ((x $eo_Term) (s $smt_builtin_String))
  :signature ($eo_Term) Bool
  (
  (($eo_is_str ($eo_mk_string s)) true)
  (($eo_is_str x)                 false)
  )
)

;;; Derived arithmetic

; final-decl: $smtx_hash
; note: this is defined axiomatically in the final smt2 encoding.
(program $smtx_hash ((T Type)) :signature (T) $smt_builtin_Int)

; program: $eo_hash
; implements: $eo_hash
; note: this invokes the underconstrained function above as an oracle.
(program $eo_hash ((T Type) (t T))
  :signature (T) $eo_Numeral
  (
  (($eo_hash t) ($eo_mk_numeral ($smtx_hash t)))
  )
)

; final-decl: $eo_reverse_hash
; note: this is the inverse of $smtx_hash, which will be defined axiomatically.
(program $eo_reverse_hash () :signature ($smt_builtin_Int) $eo_Term)

; The SMT-LIB comparison of two Eunoia or SMT-LIB terms.
(define $smtx_cmp ((T Type :implicit) (a T) (b T))
  ($smt_apply_2 "<=" ($smtx_hash a) ($smtx_hash b)))

; define: $smtx_value_hash
; note: this is an arbitrary hash for SMT values, defined axiomatically.
; We rely on embedding values into constants, which are Eunoia terms.
(define $smtx_value_hash ((v $smt_Value))
  ($smtx_hash ($eo_smt_term ($sm_Const v))))

; The SMT-LIB comparison of two SMT-LIB values.
(define $smtx_value_cmp ((a $smt_Value) (b $smt_Value))
  ($smt_apply_2 "<=" ($smtx_value_hash a) ($smtx_value_hash b)))


;;; $eo_gt

; Compare arithmetic greater than. Assumes x and y are values.
; Returns true if x > y.
; define: $eo_gt
; implements: $eo_gt
(define $eo_gt ((x $eo_Term) (y $eo_Term))
  ($eo_is_neg ($eo_add ($eo_neg x) y)))


;;; $eo_cmp

; An arbitrary deterministic comparison of terms. Returns true if a > b based
; on this ordering.
; define: $eo_cmp
; implements: $eo_cmp
(define $eo_cmp ((a $eo_Term) (b $eo_Term))
  ($eo_is_neg ($eo_add ($eo_hash b) ($eo_neg ($eo_hash a)))))

;;; since eo_typeof depends on literal predicates, typeof is only now ready.

; program: $eo_var
; implements: $eo_var
(program $eo_var ((s $smt_builtin_String) (T $eo_Term))
  :signature ($eo_String $eo_Term) $eo_Term
  (
  (($eo_var ($eo_mk_string s) T)
    ; we use the hash of the type T to identify the variable
    ($eo_requires_eq ($eo_typeof T) Type ($eo_Var s ($smtx_hash T))))
  )
)

; program: $eo_nameof
; implements: $eo_nameof
(program $eo_nameof ((s $smt_builtin_String) (T $eo_Term))
  :signature ($eo_Term) $eo_String
  (
  (($eo_nameof ($eo_Var s T)) ($eo_mk_string s))
  )
)

; Returns true if x is a variable.
; define: $eo_is_var
; implements: $eo_is_var
(define $eo_is_var ((x $eo_Term))
  ($eo_is_eq ($eo_var ($eo_nameof x) ($eo_typeof x)) x))

; fwd-decl: $eo_typeof_main
; note: This method returns the type for all user defined terms.
(program $eo_typeof_main () :signature ($eo_Term) Type)

; program: $eo_typeof
; implements: $eo_typeof
(program $eo_typeof
  ((t $eo_Term) (T $eo_Term) (b $smt_builtin_Bool) (n $smt_builtin_Int) (r $smt_builtin_Real)
   (s $smt_builtin_String) (w $smt_builtin_Int) (val $smt_Value))
  :signature ($eo_Term) $eo_Term
  (
  ; TODO: auto-generate these?
  (($eo_typeof ($eo_mk_bool b))                 Bool)
  (($eo_typeof ($eo_mk_numeral n))              $eo_Numeral)
  (($eo_typeof ($eo_mk_rational r))             $eo_Rational)
  (($eo_typeof ($eo_mk_string s))               $eo_String)
  (($eo_typeof ($eo_binary w n))                $eo_Binary)
  (($eo_typeof ($eo_Var s n))                   ($eo_reverse_hash n))
  ; otherwise, invoke the routine for builtin types from the signature.
  ; Note that we do not include SMT-LIB specific constructs here, as these are
  ; not modelled in Eunoia's builtin typeof method.
  (($eo_typeof t)                               ($eo_typeof_main t))
  )
)
(declare-const $eo_List Type)
(declare-const $eo_List_nil $eo_List)
(declare-parameterized-const $eo_List_cons ((T Type :implicit))
  (-> T $eo_List $eo_List)
  :right-assoc-nil $eo_List_nil)
(define $eo_Option_null () $eo_List_nil)
(define $eo_Option_some ((T Type :implicit) (t T)) ($eo_List_cons t $eo_List_nil))
(define $eo_Option () $eo_List)
(declare-const and (-> Bool (-> Bool Bool)))
(declare-parameterized-const = ((A Type :implicit) ($eo_x_1 A) ($eo_x_2 A)) Bool)
(declare-const BitVec (-> Int Type))
(program $eo_typeof_apply ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_apply (-> T U) T) U)
  )
)
(program $eo_typeof_= ((A Type))
  :signature (Type) Type
  (
  (($eo_typeof_= A) (-> A Bool))
  )
)
(program $eo_typeof_fun_type ()
  :signature (Type Type) Type
  (
  (($eo_typeof_fun_type Type Type) Type)
  )
)
(program $eo_typeof_main
  ((T Type) (U Type) (V Type) (W Type) (f (-> U V T)) (x U) (t T)
   (W1 Type) (x1 W1) (W2 Type) (x2 W2) (W3 Type) (x3 W3)) 
  :signature (T) Type
  (
  (($eo_typeof_main Type)      Type)
  (($eo_typeof_main (-> T U))  ($eo_typeof_fun_type ($eo_typeof T) ($eo_typeof U))) 
  (($eo_typeof_main Bool)      Type)
  (($eo_typeof_main true)      Bool)
  (($eo_typeof_main false)     Bool)
  
  (($eo_typeof_main Int) Type)
  
  (($eo_typeof_main Real) Type)
  
  (($eo_typeof_main Char) Type)
  
  (($eo_typeof_main Seq) (-> Type Type))
  
  (($eo_typeof_main and) (-> Bool (-> Bool Bool)))
  
  (($eo_typeof_main (= x1)) ($eo_typeof_= ($eo_typeof x1)))
  
  (($eo_typeof_main BitVec) (-> Int Type))

  (($eo_typeof_main (f x))     ($eo_typeof_apply ($eo_typeof f) ($eo_typeof x)))
  )
)
(program $eo_dt_constructors
  ((T Type))
  :signature (Type) $eo_List
  (

  (($eo_dt_constructors T) $eo_fail)
  )
)
(program $eo_dt_selectors ((T Type) (t T))
  :signature (T) $eo_List
  (

  (($eo_dt_selectors t) $eo_fail)
  )
)
(program $eo_model_sat () :signature (Bool) $eo_Option)
(program $eo_model_typeof () :signature (Bool) Type)
(program $eo_model_is_input () :signature (Bool) Bool)
; This file defines SMT-LIB model semantics in Eunoia.
; It has exception handling utilities to call Eunoia programs in
; a safe way that ensures that all programs in this signature are total.

; The programs in this file operate on datatypes that correspond to
; a deep embedding of Eunoia and SMT-LIB terms, types and values.
; In particular, we use the following types:
; 1. $eo_Term, the type of Eunoia terms.
; 2. $smt_Term, the type of SMT-LIB terms.
; 3. $smt_Type, the type of SMT-LIB types.
; 4. $smt_Value, the type of SMT-LIB values.
; 5. Further types defining specific SMT-LIB values, e.g. $smt_Map.
; 6. $smt_builtin_X, the builtin SMT-LIB type X.
; Note that the last type allows us to define symbols whose type
; will be a native SMT-LIB type in the final embedding generated
; by the smt-meta plugin.

; forward decl
(program $smtx_typeof () :signature ($eo_Term) $eo_Term)
(program $smtx_typeof_value () :signature ($smt_Value) $eo_Term)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Exception handling

; Invariant: all programs in this signature should be well-founded and never
; never get stuck unless otherwise stated.

; Utilities to ensure that programs are total.
; Takes
; - A $eo_Term t where we are not sure if it gets stuck.
; - A $eo_Term elseTerm where we are sure it does not get stuck.
; Returns the SMT term corresponding to the evaluation of t, if possible,
; or elseTerm otherwise. This always successfully evaluates.
(define $smt_try ((t $eo_Term) (elseTerm $eo_Term))
  ($smt_apply_3 "ite" ($smt_builtin_is_ok t)
    t
    elseTerm))

; Guarded execution of $eo_typeof.
(define $smt_try_typeof ((T Type :implicit) (t T))
  ($smt_try ($eo_typeof t) $eo_null_type))

;;;;;; SMT values

;;; Generic utilities

; returns one of (v1,v2), preferring values to non-values
(program $smtx_value_either ((v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_value_either v1 $vsm_not_value) v1)
  (($smtx_value_either $vsm_not_value v2) v2)
  (($smtx_value_either v1 v2)             v1)
  )
)

;;; Map utilities

; Get the default for the map
(program $smtx_msm_get_default
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Map) $smt_Value
  (
  (($smtx_msm_get_default ($msm_cons j e m))  ($smtx_msm_get_default m))
  (($smtx_msm_get_default ($msm_default e))   e)
  )
)

; This program looks up the value of a term in a map.
; This is used for function evaluation.
(program $smtx_msm_lookup
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Map $smt_Value) $smt_Value
  (
  (($smtx_msm_lookup ($msm_cons i e m) i)  e)
  (($smtx_msm_lookup ($msm_cons j e m) i)  ($smtx_msm_lookup m i))
  (($smtx_msm_lookup ($msm_default e) i)   e)
  )
)

; updates the map with a new entry, maintaining ordered-ness
(program $smtx_msm_update
  ((i $smt_Value) (j $smt_Value) (e1 $smt_Value) (e2 $smt_Value) (m $smt_Map))
  :signature ($smt_Map $smt_Value $smt_Value) $smt_Map
  (
  ; we overwrite if same index
  (($smtx_msm_update ($msm_cons i e1 m) i e2) ($msm_cons i e2 m))
  ; otherwise, we check the hash to retain sortedness
  (($smtx_msm_update ($msm_cons j e1 m) i e2) ($smt_apply_3 "ite" ($smtx_value_cmp j i)
                                                ($msm_cons i e2 ($msm_cons j e1 m))
                                                ($msm_cons j e1 ($smtx_msm_update m i e2))))
  ; we are redundant wrt the default value
  (($smtx_msm_update ($msm_default e1) i e1)  ($msm_default e1))
  ; ensures totality, we are a non-redundant update of the default map
  (($smtx_msm_update m i e2)                  ($msm_cons i e2 m))
  )
)

; This program determines whether the map value is canonical.
; It returns true if the array is "redundant", i.e. has a non-canonical
; ordering of indicies, or duplicate/redundant entries.
(program $smtx_msm_is_irredundant ((i $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Map) $smt_builtin_Bool
  (
  (($smtx_msm_is_irredundant ($msm_default e))     $smt_builtin_true)
  (($smtx_msm_is_irredundant ($msm_cons i e m))
    ; Recompute the update. If it changes, we are redundant.
    ($smt_apply_3 "ite"
      ($smt_apply_= ($smtx_msm_update m i e) ($msm_cons i e m))
      ($smtx_msm_is_irredundant m)
      $smt_builtin_false))
  )
)

; Returns the first index of m1 that is mapped to a different value in m2.
; If no such value exists, return $vsm_not_value.
(program $smtx_msm_find_diff
  ((i $smt_Value) (e $smt_Value) (m1 $smt_Map) (m2 $smt_Map))
  :signature ($smt_Map $smt_Map) $smt_Value
  (
  (($smtx_msm_find_diff ($msm_default e) m2)    $vsm_not_value)
  (($smtx_msm_find_diff ($msm_cons i e m1) m2)
    ; Lookup the current index, if it different, return this index.
    ($smt_apply_3 "ite"
      ($smt_apply_= ($smtx_msm_lookup m2 i) e)
      ($smtx_msm_find_diff m1 m2)
      i))
  )
)

; note: this is only correct for infinite maps!!!
(define $smtx_map_is_value ((m $smt_Map))
  ($smtx_msm_is_irredundant m))

;;; Map as sets

; A set is a mapping to Bool.
; The empty set maps all to false.
(define $smtx_msm_empty_set () ($msm_default $vsm_false))
; Inserting sets e to true.
(define $smtx_mss_mk_insert ((e $smt_Value) (m $smt_Map)) ($smtx_msm_update m e $vsm_true))
(define $smtx_mss_insert ((e $smt_Value) (m $smt_Map)) ($msm_cons e $vsm_true m))
(define $smtx_mss_member ((e $smt_Value) (m $smt_Map))
  ($smt_apply_= ($smtx_msm_lookup m e) $vsm_true))

; Helper for computing binary set operators.
(program $smtx_mss_op_internal
  ((m1 $smt_Map) (m2 $smt_Map) (acc $smt_Map) (e $smt_Value) (isInter $smt_builtin_Bool))
  :signature ($smt_builtin_Bool $smt_Map $smt_Map $smt_Map) $smt_Map
  (
  (($smtx_mss_op_internal isInter $smtx_msm_empty_set m2 acc) acc)
  (($smtx_mss_op_internal isInter ($smtx_mss_insert e m1) m2 acc)
    ($smtx_mss_op_internal isInter m1 m2
      ($smt_apply_3 "ite"
        ($smt_apply_= ($smtx_mss_member e m2) isInter)
        ($smtx_mss_mk_insert e acc)
        acc)))
  )
)

;;; Utilities for Sequence values

(program $smtx_ssm_seq_nth ((v $smt_Value) (vs $smt_Seq) (n $smt_builtin_Int))
  :signature ($smt_Seq $smt_builtin_Int) $smt_Value
  (
  (($smtx_ssm_seq_nth $ssm_empty n)                           $vsm_not_value)
  (($smtx_ssm_seq_nth ($ssm_cons v vs) $smt_builtin_z_zero)   v)
  (($smtx_ssm_seq_nth ($ssm_cons v vs) n)
    ($smtx_ssm_seq_nth vs ($smt_builtin_z_dec n)))
  )
)

; TODO
(program $smtx_seq_is_value () :signature ($smt_Seq) $smt_builtin_Bool)

;;; Utilities for Datatype values

; TODO: meta semantics for arbitrary unknown datatypes?

; define: $smt_is_dt
; returns: true if t is a datatpe (i.e. it has constructors).
(define $smt_is_dt ((t $smt_Type))
  ($smt_builtin_is_ok ($eo_dt_constructors t)))

; define: $smt_is_dt_cons
; returns: true if t is a constructor (i.e. it has selectors).
(define $smt_is_dt_cons ((t $smt_Term))
  ($smt_builtin_is_ok ($eo_dt_selectors t)))

;;; Utilities for making values

; program: $smtx_is_atomic_term_value
; Returns true if its argument is an SMT value.
; This function is expected to never get stuck.
; Note that this does not take a type. This function must ensure
; that if it returns true for two terms t1 and t2 of the same type,
; then t1 != t2 in all models.
(program $smtx_is_atomic_term_value
  ((t $smt_Term) (b $smt_builtin_Bool) (n $smt_builtin_Int) (r $smt_builtin_Real) (s $smt_builtin_String))
  :signature ($smt_Term) $smt_builtin_Bool
  (
  ; standard atomic types are values
  (($smtx_is_atomic_term_value ($sm_mk_bool b))  $smt_builtin_true)
  (($smtx_is_atomic_term_value ($sm_mk_z n))     $smt_builtin_true)
  (($smtx_is_atomic_term_value ($sm_mk_q r))     $smt_builtin_true)
  (($smtx_is_atomic_term_value ($sm_mk_str s))   $smt_builtin_true)
  ; by default, not a value
  (($smtx_is_atomic_term_value t)                $smt_builtin_false)
  )
)

; Returns a term of type $smt_Value, embeds the term
; if indeed it is a value, or returns not a value otherwise.
(define $smt_mk_value_term ((t $smt_Term))
  ($smt_apply_3 "ite" ($smtx_is_atomic_term_value t)
    ; an atomic term, e.g. 0, true, "abc"
    ($vsm_term t)
    ($smt_apply_3 "ite" ($smt_is_dt_cons t)
      ; a datatype constructor, which becomes a (nil-terminated) vsm_apply
      ($vsm_apply ($vsm_term t) $vsm_not_value)
      $vsm_not_value)))

(define $smt_mk_value_map ((T $smt_builtin_Int) (m $smt_Map))
  ($smt_apply_3 "ite"
    ($smtx_map_is_value m)
    ($vsm_map T m)
    $vsm_not_value))

; fwd-decl: $smtx_is_value
(program $smtx_is_value () :signature ($smt_Value) $smt_builtin_Bool)

; program: $smtx_is_value
(program $smtx_is_value
  ((t $smt_Term) (f $smt_Value) (v $smt_Value) (T $eo_Term) (m $smt_Map) (s $smt_Seq)
   (T $smt_builtin_Int) (id $smt_builtin_Int))
  :signature ($smt_Value) $smt_builtin_Bool
  (
  (($smtx_is_value ($vsm_term t))         ($smtx_is_atomic_term_value t))
  (($smtx_is_value ($vsm_map T m))        ($smtx_map_is_value m))
  (($smtx_is_value ($vsm_seq T s))        ($smtx_seq_is_value s))
  (($smtx_is_value ($vsm_uconst T id))    $smt_builtin_true)
  ; Herbrand interpretations: nil terminated apply of value terms
  (($smtx_is_value ($vsm_apply ($vsm_term t) $vsm_not_value))
                                          ($smt_is_dt_cons t))
  (($smtx_is_value ($vsm_apply f v))      ($smt_apply_2 "and" ($smtx_is_value f) ($smtx_is_value v)))
  ; Otherwise false
  (($smtx_is_value v)                     $smt_builtin_false)
  )
)

; program: $smtx_ensure_value
; args:
; - v $smt_Value: A value term.
; return: >
;   v itself if it denotes a proper SMT-LIB value, or $vsm_not_value otherwise.
(program $smtx_ensure_value
  ((v $smt_Value) (t $smt_Term) (T $smt_builtin_Int) (m $smt_Map) (id $smt_builtin_Int))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_ensure_value ($vsm_term t))         ($smt_mk_value_term t))
  (($smtx_ensure_value ($vsm_map T m))        ($smt_mk_value_map T m))
  (($smtx_ensure_value ($vsm_uconst T id))    ($vsm_uconst T id))
  (($smtx_ensure_value v)                     $vsm_not_value)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Model semantics

; Forward declaration of the main method defined by this signature.
; We use this to define $eo_model_sat.
(program $smtx_model_eval () :signature ($eo_Term) $smt_Value)

;;; Core

; program: $smtx_model_eval_apply
; We call ($smtx_model_eval_apply value_f value_i) when
; evaluating (f i) whose values are value_f and value_i
; respectively. If value_f is a map value, then we extract
; the map and call the map lookup routine.
(program $smtx_model_eval_apply
  ((T $smt_builtin_Int) (m $smt_Map) (i $smt_Value) (f $smt_Value) (v $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  ; If a Herbrand interpretation, apply it to the next value.
  (($smtx_model_eval_apply ($vsm_apply f v) i)  ($vsm_apply ($vsm_apply f v) i))
  ; The function evaluated to a map value, call the map lookup.
  (($smtx_model_eval_apply ($vsm_map T m) i)    ($smtx_msm_lookup m i))
  ; The function did not evaluate to a map value, we fail.
  (($smtx_model_eval_apply v i)                 $vsm_not_value)
  )
)

; ITE branches to the appropriate child.
; return: The evaluation of an ite application.
(program $smtx_model_eval_ite
  ((t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value

  (
  (($smtx_model_eval_ite $vsm_true t2 t3)   t2)
  (($smtx_model_eval_ite $vsm_false t2 t3)  t3)
  (($smtx_model_eval_ite t1 t2 t3)          $vsm_not_value)
  )
)

; Equality insists on valueness and then reduces to an equality over datatypes
; in the deep embedding (vsm.Value), meaning it works for all types, including
; functions and uninterpreted sorts where values are not represented by terms.
; Note that the valueness predicate ensures this is sound. Moreover note that
; we do not invoke the type checker here. This means that if an ill-typed
; equality was given as input to this method, it would always evaluate to false.
; The caller of this method is responsible for ensuring that this behavior is
; either avoided or admissible.
; return: The evaluation of an equality application.
(program $smtx_model_eval_=
  ((t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_= $vsm_not_value t2) $vsm_not_value)
  (($smtx_model_eval_= t1 $vsm_not_value) $vsm_not_value)
  ; use datatype equality over $smt_Value, which depends on t1 and t2 being proper values.
  (($smtx_model_eval_= t1 t2)             ($vsm_term ($sm_mk_bool ($smt_apply_= t1 t2))))
  )
)

;;; Functions, arrays

(program $smtx_map_select
  ((v $smt_Value) (i $smt_Value) (T $smt_builtin_Int) (m $smt_Map))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_select ($vsm_map T m) i) ($smtx_msm_lookup m i))
  (($smtx_map_select v i)              $vsm_not_value)
  )
)

(program $smtx_map_store
  ((v $smt_Value) (i $smt_Value) (e $smt_Value) (T $smt_builtin_Int) (m $smt_Map))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_store ($vsm_map T m) i e) ($vsm_map T ($smtx_msm_update m i e)))
  (($smtx_map_store v i e)              $vsm_not_value)
  )
)

; Returns the value where m1 and m2 differ, or $vsm_not_value otherwise.
(program $smtx_map_diff
  ((T $smt_builtin_Int) (m1 $smt_Map) (m2 $smt_Map))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_diff ($vsm_map T m1) ($vsm_map T m2))
    ; find an index in the first that conflicts with the second, or vice versa
    ($smtx_value_either ($smtx_msm_find_diff m1 m2) ($smtx_msm_find_diff m2 m1)))
  )
)

;;; Sets

; args:
; - T: the type of the empty set. This is expected to have type Type.
(program $smtx_empty_set ((T $eo_Term))
  :signature ($eo_Term) $smt_Value
  (
  (($smtx_empty_set T) ($vsm_map ($smtx_hash T) $smtx_msm_empty_set))
  )
)

; return the singleton set whose type is T and contains e.
(program $smtx_set_singleton ((T $eo_Term) (e $smt_Value))
  :signature ($eo_Term $smt_Value) $smt_Value
  (
  (($smtx_set_singleton T e)
     ($vsm_map ($smtx_hash T) ($smtx_mss_insert e $smtx_msm_empty_set)))
  )
)

; return the intersection of two set values.
(program $smtx_set_inter
  ((T $smt_builtin_Int) (m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_inter ($vsm_map T m1) ($vsm_map T m2))
    ; m1 intersected m2 starting with empty set.
    ($vsm_map T ($smtx_mss_op_internal $smt_builtin_true m1 m2 $smtx_msm_empty_set)))
  (($smtx_set_inter v1 v2)  $vsm_not_value)
  )
)

; return the set minus of two set values.
(program $smtx_set_minus
  ((T $smt_builtin_Int) (m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_minus ($vsm_map T m1) ($vsm_map T m2))
    ; m1 minus m2 starting with empty set.
    ($vsm_map T ($smtx_mss_op_internal $smt_builtin_false m1 m2 $smtx_msm_empty_set)))
  (($smtx_set_minus v1 v2)  $vsm_not_value)
  )
)

; return the union of two set values.
(program $smtx_set_union
  ((T $smt_builtin_Int) (m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_union ($vsm_map T m1) ($vsm_map T m2))
    ; m1 minus the empty set starting with m2.
    ($vsm_map T ($smtx_mss_op_internal $smt_builtin_false m1 $smtx_msm_empty_set m2)))
  (($smtx_set_union v1 v2)  $vsm_not_value)
  )
)

;;; Sequences

(program $smtx_empty_seq ((T $eo_Term))
  :signature ($eo_Term) $smt_Value
  (
  (($smtx_empty_seq T) ($vsm_seq ($smtx_hash T) $ssm_empty))
  )
)

(program $smtx_seq_unit ((e $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_seq_unit e)
    ($vsm_seq ($smtx_hash ($smtx_typeof_value e)) ($ssm_cons e $ssm_empty)))
  )
)

(program $smtx_seq_nth
  ((T $smt_builtin_Int) (s $smt_Seq) (n $smt_builtin_Int) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_seq_nth ($vsm_seq T s) ($vsm_term ($sm_mk_z n))) ($smtx_ssm_seq_nth s n))
  (($smtx_seq_nth v1 v2) $vsm_not_value)
  )
)

;;; Quantifiers

; returns $vsm_not_value if we are done (i.e. the cardinality of T is less than i).
(program $smtx_enum_type ((T $eo_Term) (i $smt_builtin_Int))
  :signature ($eo_Term $smt_builtin_Int) $smt_Value
  (
  ; otherwise, uninterpreted constant.
  (($smtx_enum_type T i)               ($vsm_uconst ($smtx_hash T) i))
  )
)

; program: $smtx_model_val_substitute
; Used to define $smtx_eval_quant.
; ($smtx_model_val_substitute x v t) returns the term where x is replaced by
; the constant that is interpreted as v.
(program $smtx_model_val_substitute
  ((x $eo_Term) (v $smt_Value) (f $eo_Term) (a $eo_Term) (z $eo_Term))
  :signature ($eo_Term $smt_Value $eo_Term) $eo_Term
  (
  (($smtx_model_val_substitute x v (f a))
    (_ ($smtx_model_val_substitute x v f) ($smtx_model_val_substitute x v a)))
  (($smtx_model_val_substitute x v x)
    ($eo_smt_term ($sm_Const v)))   ; we are now the constant with the given interpretation
  (($smtx_model_val_substitute x v z) z)
  )
)

; Say we are checking the satisfiability of (exists ((x T)) F).
; We call ($smtx_eval_quant_next ($vsm_Pair_mk m ws) w true) in this context
; where F[w/x] evaluated to m, where ws is the list of witnesses we have accumulated
; so far. This method either returns a $vsm_Pair corresponding to the final return value of
; the function below, or $vsm_not_value if we were inconclusive. In particular, if m is
; true, we append w to ws. If m is false, we are inconclusive. If m was another value, then
; we return $vsm_not_value, indicating the model value of the entire quantified formula is
; unknown.
(program $smtx_eval_quant_next
  ((b $smt_builtin_Bool) (mv $smt_Value) (w $smt_Value) (ws $vsm_List) (tgt $smt_builtin_Bool))
  :signature ($vsm_Pair $smt_Value $smt_builtin_Bool) $smt_Value
  (
  ; if the body evaluated to the target value, return successfully
  (($smtx_eval_quant_next ($vsm_Pair_mk ($vsm_term ($sm_mk_bool tgt)) ws) w tgt)
    ($vsm_Pair_mk ($vsm_term ($sm_mk_bool tgt)) ($smtx_vsm_List_cons w ws)))
  ; if the body successfully evaluated but was the negation of the target, we are inconclusive
  (($smtx_eval_quant_next ($vsm_Pair_mk ($vsm_term ($sm_mk_bool b)) ws) w tgt)
    $vsm_not_value)
  ; if the body evaluated to something else, return that we are unevaluated
  (($smtx_eval_quant_next mv w b)
    ($vsm_Pair_mk $vsm_not_value $vsm_List_empty))
  )
)

; Returns a pair of values (v, k) where
;   v is the result of evaluating (Q xs F),
;   k is the sequence of values that witnessed it.
; note: this assumes that binders use $eo_List for their binder!
(program $smtx_eval_quant
  ((Q (-> $eo_List $eo_Term $eo_Term)) (x $eo_Term) (xs $eo_Term) (F $eo_Term) (i $smt_builtin_Int) (tgt $smt_builtin_Bool))
  :signature ($eo_Term $smt_builtin_Int $smt_builtin_Bool) $vsm_Pair
  (
  (($smtx_eval_quant (Q $eo_List_nil F) i tgt)
    ; finished instantiation, evaluate the instantiated body and give the empty list
    ($vsm_Pair_mk ($smtx_model_eval F) $vsm_List_empty))
  (($smtx_eval_quant (Q ($eo_List_cons x xs) F) i tgt)
    ; get the next value in the type enumeration
    (eo::define ((next ($smtx_enum_type ($eo_model_typeof x) i)))
    ; if we are out of values, we return the negation
    ($smt_apply_3 "ite" ($smt_apply_= next $vsm_not_value)
      ; out of values, return the negation of target with no value (no witness)
      ($vsm_Pair_mk ($vsm_term ($sm_mk_bool ($smt_apply_1 "not" tgt))) $vsm_List_empty)
      ; recurse on the next variable
      (eo::define ((eval ($smtx_eval_quant (Q xs ($smtx_model_val_substitute x next F)) $smt_builtin_z_zero tgt)))
      ; setup the return value
      (eo::define ((ret ($smtx_eval_quant_next eval next tgt)))
      ; check if the above setup was inconclusive
      ($smt_apply_3 "ite" ($smt_apply_= ret $vsm_not_value)
        ; inconclusive, recurse for the next value in the type enumeration for the current variable
        ($smtx_eval_quant (Q ($eo_List_cons x xs) F) ($smt_builtin_z_inc i) tgt)
        ; otherwise return, which is either the case that we failed to evaluate, or evaluated to tgt
        ret))))))
  ; not a quantified formula, fail
  (($smtx_eval_quant F i tgt) $vsm_not_value)
  )
)

; main entry for model evaluation of exists.
(program $smtx_model_eval_exists ((F $eo_Term))
  :signature ($eo_Term) $smt_Value
  (
  (($smtx_model_eval_exists F)
    ; use the routine above, returning the first component
    ($smtx_vsm_Pair_first ($smtx_eval_quant F $smt_builtin_z_zero $smt_builtin_true)))
  )
)

; main entry for model evaluation of forall.
(program $smtx_model_eval_forall ((F $eo_Term))
  :signature ($eo_Term) $smt_Value
  (
  (($smtx_model_eval_forall F)
    ; use the routine above, returning the second component
    ($smtx_vsm_Pair_first ($smtx_eval_quant F $smt_builtin_z_zero $smt_builtin_false)))
  )
)

; main entry for model evaluation of choice.
; this returns the choice function for the n^th variable of existential F.
(program $smtx_eval_choice_nth ((F $eo_Term) (n $smt_builtin_Int) (t $eo_Term))
  :signature ($eo_Term $eo_Term) $smt_Value
  (
  (($smtx_eval_choice_nth F ($eo_mk_numeral n))
    ; use the routine above, returning the n^th element of the second component
    (eo::define ((eval ($smtx_eval_quant F $smt_builtin_z_zero $smt_builtin_false)))
      ($smtx_seq_nth ($smtx_vsm_Pair_second eval) ($vsm_term ($sm_mk_z n)))))
  (($smtx_eval_choice_nth F t) $vsm_not_value)
  )
)

;;; Other model evaluation functions

(program $smtx_model_eval_and
  ((x1 $smt_builtin_Bool) (x2 $smt_builtin_Bool) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_and ($vsm_term ($sm_mk_bool x1)) ($vsm_term ($sm_mk_bool x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "and" x1 x2))))
  (($smtx_model_eval_and t1 t2) $vsm_not_value)
  )
)


; An evaluator for all terms that we can reason about models.
; This is a recursive call.
; invariant: this must be a total function
; invariant: unless this method returns $vsm_not_value, it must be such that
;            it represents a unique SMT-LIB value, i.e. ($vsm_term t) is
;            forbidden unless t denotes a value.
(program $smtx_model_eval
  ((f $eo_Term) (y $eo_Term) (z $eo_Term)
   (val $smt_Value)
   ; generic parameters that may appear in terms to pattern match
   (x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term) (x4 $eo_Term) (x5 $eo_Term))
  :signature ($eo_Term) $smt_Value
  (
  ; evaluation of standard SMT symbols
  ; These calls will reference helper methods above, e.g. of the form
  ; $smtx_model_eval_*, or call builtin methods e.g. $smtx_eval_quant.
  (($smtx_model_eval (and x1 x2)) ($smtx_model_eval_and ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (= x1 x2)) ($smtx_model_eval_= ($smtx_model_eval x1) ($smtx_model_eval x2)))

  ;; free constants
  ; Constants carry their value in the model, which is an arbitrary value term.
  ; We run this value through $smtx_ensure_value to ensure it is a proper value.
  (($smtx_model_eval ($sm_Const val))           ($smtx_ensure_value val))
  
  ; Apply case. We evaluate f and y separately and then call the
  ; $smtx_model_eval_apply above. We expect f to be an uninterpreted
  ; function whose model evaluation is an SMT-LIB map in this case.
  ; All interpreted f should be handled in the evaluation cases above.
  (($smtx_model_eval (f y))
    ($smtx_model_eval_apply ($smtx_model_eval f) ($smtx_model_eval y)))

  ; Otherwise, it may be a term value (e.g. if z is a Boolean or numeral constant).
  ; We call the utility method which will either generate an SMT-LIB term value or
  ; a SMT-LIB non-value error term.
  (($smtx_model_eval z)                         ($smt_mk_value_term z))
  )
)

; program: $smtx_model_sat
(program $smtx_model_sat ((val $smt_Value))
  :signature ($smt_Value) $eo_Option
  (
  (($smtx_model_sat $vsm_true)  ($eo_Option_some true))
  (($smtx_model_sat $vsm_false) ($eo_Option_some false))
  (($smtx_model_sat val)        $eo_Option_null)
  )
)

; program: $smtx_model_sat_combined
; args:
; - isInput Bool: Whether it is legal SMT-LIB input syntax.
; - T Type: Its type.
; - val $smt_Value: The result of model value.
(program $smtx_model_sat_combined ((b Bool) (T Type) (val $smt_Value))
  :signature (Bool Type $smt_Value) $eo_Option
  (
  (($smtx_model_sat_combined true Bool $vsm_true)  ($eo_Option_some true))
  (($smtx_model_sat_combined true Bool $vsm_false) ($eo_Option_some false))
  (($smtx_model_sat_combined b T val)        $eo_Option_null)
  )
)

;;; type of

(program $smtx_mk_fun_type_internal
  ((T $eo_Term) (U $eo_Term) (Tt $eo_Term) (Ut $eo_Term))
  :signature ($eo_Term $eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($smtx_mk_fun_type_internal T U Type Type) ($eo_mk_fun_type T U))
  (($smtx_mk_fun_type_internal T U Tt Ut)     $eo_null_type)
  )
)

; note: Helper for below. This is analogous to the method $eo_typeof_apply
(program $smtx_typeof_apply ((T $eo_Term) (U $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($smtx_typeof_apply ($eo_mk_fun_type T U) T) U)
  )
)

; Helper for below. This defines the typeof
(program $smtx_typeof_value
  ((val $smt_Value) (T $smt_builtin_Int) (m $smt_Map) (s $smt_Seq)
   (id $smt_builtin_Int) (f $smt_Value) (a $smt_Term) (U $smt_Type))
  :signature ($smt_Value) $eo_Term
  (
  (($smtx_typeof_value ($vsm_apply f val))
    ($smtx_typeof_apply ($smtx_typeof_value f)  ($smtx_typeof_value val)))
  ; the type of a value term is the type of its term.
  (($smtx_typeof_value ($vsm_term a))           ($smtx_typeof ($eo_smt_term a)))
  (($smtx_typeof_value ($vsm_map T m))          ($eo_reverse_hash T))
  (($smtx_typeof_value ($vsm_seq T s))          ($eo_reverse_hash T))
  ; the type of uninterpreted constants carry its type, accessible via reverse hash.
  (($smtx_typeof_value ($vsm_uconst T id))      ($eo_reverse_hash T))
  ; the type of not-values is the null sort.
  (($smtx_typeof_value val)                     $eo_null_type)
  )
)

; The EO model typeof function, which incorporates SMT terms introduced in the
; model_smt layer.
; This is intended to cover all Eunoia and SMT terms (those of the form
; (eo.SmtTerm *). Since values are embedded into SMT terms, we cover SMT values,
; i.e. those of the form (eo.SmtValue *) as well.
; Furthermore note:
; - (SMT terms in $eo_typeof_main): sm.True, sm.False
; - (SMT terms in $eo_typeof): sm.Numeral, sm.Rational, sm.String, sm.Binary
; - (SMT terms handled below): sm.Const, sm.Apply
; - (EO terms in $eo_typeof_main): eo.Type, eo.FunType, eo.Apply
; - (EO terms in $eo_typeof): eo.Var
; - (EO terms intentionally unhandled): eo.Stuck, eo.SmtType
; invariant: all terms introduced by this layer must be given a type rule here.
; TODO: use hash for the nullsort below?
(program $smtx_typeof
  ((t $eo_Term) (val $smt_Value) (T $eo_Term) (m $smt_Map) (id $smt_builtin_Int)
   (f $smt_Value) (a $smt_Term) (U $smt_Type))
  :signature ($eo_Term) $eo_Term
  (
  ; the arrow type is first class in this embedding but not in Eunoia, requires a case
  (($smtx_typeof $eo_fun_type)                        $eo_Type)
  ; the type of an atomic type uses Eunoia's typeof builtin, or null sort if this fails.
  (($smtx_typeof ($eo_smt_type U))                    ($smt_try_typeof U))
  ; the type of a constant is the type of its value.
  (($smtx_typeof ($eo_smt_term ($sm_Const val)))      ($smtx_typeof_value val))
  ; similar to above, we try Eunoia's typeof, or null sort.
  (($smtx_typeof ($eo_smt_term a))                    ($smt_try_typeof a))
  ; For all other terms, we try Eunoia's typeof, or null sort.
  (($smtx_typeof t)                                   ($smt_try_typeof t))
  )
)

;;; SMT input

; program: $smtx_is_input
(program $smtx_is_input
  ((t $eo_Term) (a $eo_Term) (s $smt_Term) (T $smt_Type) (v $smt_Value))
  :signature ($eo_Term) Bool
  (
  (($smtx_is_input ($eo_apply t a))
    ($eo_if_both ($smtx_is_input t) ($smtx_is_input a)))
  (($smtx_is_input ($eo_smt_term ($sm_Const v)))  ($eo_mk_bool ($smtx_is_value v)))
  (($smtx_is_input ($eo_smt_term s))              true)
  (($smtx_is_input ($eo_smt_type T))              true)
  (($smtx_is_input t)                             false)
  )
)

;;;;;;;;;;;;;;;;;;;;;;

; program: $eo_model_sat
; note: F is satisfied by the model if F evaluates to the SMT-LIB value denoting true.
; We expect the input to this method to be a Eunoia term denoting an SMT-LIB formula
; (term of Boolean type).
(program $eo_model_sat ((F Bool))
  :signature (Bool) $eo_Option
  (
  (($eo_model_sat F) ($smtx_model_sat ($smtx_model_eval F)))
  )
)

; program: $eo_model_typeof
; note: F is satisfied by the model if F evaluates to the SMT-LIB value denoting true.
; We expect the input to this method to be a Eunoia term denoting an SMT-LIB formula
; (term of Boolean type).
(program $eo_model_typeof ((F Bool))
  :signature (Bool) Type
  (
  (($eo_model_typeof F) ($smtx_typeof F))
  )
)

; program: $eo_model_is_input
; return: true if this is a legal SMT-LIB input term or type.
(program $eo_model_is_input ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_is_input F) ($smtx_is_input F))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_end
(program $eor_bool-eq-true ((t1 Bool))
  :signature (Bool) Bool
  (
  (($eor_bool-eq-true t1) (_ (= (_ (= t1) true)) t1))
  )
)
(program $eovc_bool-eq-true ((t1 Bool))
  :signature (Bool) Bool
  (
  (($eovc_bool-eq-true t1) ($eo_requires_eq ($eo_model_sat ($eor_bool-eq-true t1)) ($eo_Option_some false) true))
  )
)
(echo "smt-meta $eovc_bool-eq-true :deps $smtx_hash $eo_reverse_hash $smtx_value_hash $eo_smt_type $tsm_Bool $eo_type $eo_fun_type $eo_apply ")
