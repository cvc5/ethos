; trim-defs: $eovc_evaluate
; #trim-defs: 232
(declare-const $eo_Proof Type)
(declare-parameterized-const $eo_pf ((F Bool :opaque)) $eo_Proof)
(program $eo_proven ((F Bool))
  :signature ($eo_Proof) Bool
  (
  (($eo_proven ($eo_pf F)) F)
  )
)
(declare-const Int Type)
(declare-consts <numeral> Int)
(define $eo_Numeral () Int)
(declare-const Real Type)
(declare-consts <rational> Real)
(define $eo_Rational () Real)
(declare-const BitVec (-> Int Type))
(declare-consts <binary> (BitVec (eo::len eo::self)))
(define $eo_Binary () (BitVec 1))
(declare-const Char Type)
(declare-const Seq (-> Type Type))
(declare-consts <string> (Seq Char))
(define $eo_String () (Seq Char))
(declare-const $eo_List Type)
(declare-const $eo_List_nil $eo_List)
(declare-parameterized-const $eo_List_cons ((T Type :implicit))
  (-> T $eo_List $eo_List))
(program $eo_typeof ((T Type)) :signature (T) Type)
(program $eo_nil ((T Type) (U Type) (V Type) (W Type))
  :signature ((-> T U V) (eo::quote W)) W)
(program $eo_dt_constructors () :signature (Type) $eo_List)
(program $eo_dt_selectors ((T Type)) :signature (T) $eo_List)
; This file defines the semantics of Eunoia operators that require calling
; SMT-LIB like computations.

; Embedding into SMT operators, which defines $smt_builtin_*, $smt_apply_* etc.
; This file defines a deep embedding of SMT-LIB into Eunoia.
; It has the following uses:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin
;    Eunoia functions, e.g. $eo_add.
; 2. It is used to define the end signature for defining the model semantics of
;    SMT-LIB.

; The type of $smt_apply_* terms.
; If a term has this type, we know it is an SMT-LIB type,
; but we don't know which one from ordinary type checking.
(declare-const $smt_BuiltinType Type)

;;; Deep embedding of SMT-LIB operator applications into Eunoia

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_type_0
  (($smt_id Type :implicit) (op $smt_id :opaque))
  Type)
(declare-parameterized-const $smt_type_1
  (($smt_id Type :implicit) (W1 Type :implicit) (op $smt_id :opaque) (x1 W1 :opaque))
  Type)
(declare-parameterized-const $smt_apply_0
  (($smt_id Type :implicit) (op $smt_id :opaque))
  $smt_BuiltinType)
(declare-parameterized-const $smt_apply_1
  (($smt_id Type :implicit) (W1 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_2
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_3
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_4
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit)
   (W3 Type :implicit) (W4 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_5
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit)
   (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque) (x5 W5 :opaque)) $smt_BuiltinType)

; builtin types, which print as e.g. "sm.Int".
(declare-parameterized-const $smt_builtin_type_0
  (($smt_id Type :implicit) (op $smt_id :opaque))
  Type)
; NOTE: the fact that x1 is not opaque indicates that
; bitvectors print as (_ BitVec w) not (BitVec w).
(declare-parameterized-const $smt_builtin_type_1
  (($smt_id Type :implicit) (W1 Type :implicit) (op $smt_id :opaque) (x1 W1))
  Type)

(define $smt_builtin_Bool () ($smt_type_0 "Bool"))
(define $smt_builtin_Int () ($smt_type_0 "Int"))
(define $smt_builtin_Real () ($smt_type_0 "Real"))
; Assumes Rat is defined as Real.
(define $smt_builtin_Rat () ($smt_type_0 "Rat"))
(define $smt_builtin_String () ($smt_type_0 "String"))
(define $smt_builtin_RegLan () ($smt_type_0 "RegLan"))
(define $smt_builtin_true () ($smt_apply_0 "true"))
(define $smt_builtin_false () ($smt_apply_0 "false"))
(define $smt_builtin_ite ((W Type :implicit) (b $smt_builtin_Bool) (x1 W) (x2 W)) ($smt_apply_3 "ite" b x1 x2))
(define $smt_builtin_z_zero () ($smt_apply_0 "0"))
(define $smt_builtin_z_one () ($smt_apply_0 "1"))
(define $smt_builtin_z_two () ($smt_apply_0 "2"))
(define $smt_builtin_z_max_code () ($smt_apply_0 "196608"))
(define $smt_builtin_z_max_width () ($smt_apply_0 "4294967296"))
;(define $smt_builtin_q_zero () ($smt_apply_0 "0/1"))
(define $smt_builtin_q_zero () ($smt_apply_2 "mk_rational" $smt_builtin_z_zero $smt_builtin_z_one))
(define $smt_builtin_str_empty () ($smt_apply_0 """"""))
(define $smt_builtin_not ((b $smt_builtin_Bool)) ($smt_apply_1 "not" b))
(define $smt_builtin_and ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "and" b1 b2))
(define $smt_builtin_or ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "or" b1 b2))
(define $smt_builtin_xor ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "xor" b1 b2))
(define $smt_builtin_iff ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "iff" b1 b2))
; Integer operators
; These assume zeq, zleq, zlt, zplus, zmult, zneg are defined as =, <=, <, +, *, -
(define $smt_builtin_z_eq ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zeq" x1 x2))
(define $smt_builtin_z_<= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zleq" x1 x2))
(define $smt_builtin_z_< ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zlt" x1 x2))
(define $smt_builtin_z_add ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zplus" x1 x2))
(define $smt_builtin_z_mul ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "zmult" x1 x2))
(define $smt_builtin_z_neg ((W Type :implicit) (x1 W)) ($smt_apply_1 "zneg" x1))
; Real operators
; These assume qleq, qlt, qplus, qmult, qneg are defined as <=, <, +, *, -
(define $smt_builtin_q_eq ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qeq" x1 x2))
(define $smt_builtin_q_<= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qleq" x1 x2))
(define $smt_builtin_q_< ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qlt" x1 x2))
(define $smt_builtin_q_add ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qplus" x1 x2))
(define $smt_builtin_q_mul ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "qmult" x1 x2))
(define $smt_builtin_q_neg ((W Type :implicit) (x1 W)) ($smt_apply_1 "qneg" x1))
; other arithmetic
(define $smt_builtin_div ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "div" x1 x2))
(define $smt_builtin_mod ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "mod" x1 x2))
(define $smt_builtin_z_sub ((W Type :implicit) (x1 W) (x2 W)) ($smt_builtin_z_add x1 ($smt_builtin_z_neg x2)))
(define $smt_builtin_z_neg_one () ($smt_builtin_z_neg $smt_builtin_z_one))
(define $smt_builtin_z_inc ((W Type :implicit) (x1 W)) ($smt_builtin_z_add x1 $smt_builtin_z_one))
(define $smt_builtin_z_dec ((W Type :implicit) (x1 W)) ($smt_builtin_z_add x1 $smt_builtin_z_neg_one))

; macro for applying (+ t1 t2 t3), which is (+ t1 (+ t2 t3))
(define $smt_apply_nary_3
  (($smt_id Type :implicit) (W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit)
   (op $smt_id) (x1 W1) (x2 W2) (x3 W3))
  ($smt_apply_2 op x1 ($smt_apply_2 op x2 x3)))

;;; Defining parametric bitvector operators

; The operators in this section are needed to reason about the parametric
; operations on the Eunoia binary literal type.

; program: $smtx_pow2
; return: >
;   The integer value of 2 raised to the i^th power.
; note: We expect i to be non-negative.
(program $smtx_pow2 ((i $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_pow2 i)
    ($smt_builtin_ite ($smt_builtin_z_<= i $smt_builtin_z_zero)
      $smt_builtin_z_one
      ($smt_builtin_z_mul $smt_builtin_z_two
        ($smtx_pow2 ($smt_builtin_z_dec i)))))
  )
)

; program: $smtx_bit
; return: >
;   true iff the i^th bit of a binary with integer value x is set. Note this
;   method is agnostic to bitwidth.
(program $smtx_bit ((x $smt_builtin_Int) (i $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Bool
  (
  (($smtx_bit x i)
    ($smt_builtin_z_eq
      $smt_builtin_z_one
      ($smt_builtin_mod ($smt_builtin_div x ($smtx_pow2 i)) $smt_builtin_z_two)))
  )
)

; program: $smtx_msb
; return: >
;   true iff the most significant bit of the binary of width w and value n is
;   set.
(program $smtx_msb ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Bool
  (
  (($smtx_msb w n) ($smtx_bit n ($smt_builtin_z_dec w)))
  )
)

; program: $smtx_binary_and_rec
; note: Helper for $smtx_binary_and below.
(program $smtx_binary_and_rec ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_and_rec w n1 n2)
      ($smt_builtin_z_add
        ($smt_builtin_ite ($smt_builtin_z_eq w $smt_builtin_z_zero)
          $smt_builtin_z_zero
          ($smtx_binary_and_rec ($smt_builtin_z_dec w) n1 n2))
        ($smt_builtin_z_mul ($smtx_pow2 w)
            ($smt_builtin_ite ($smt_builtin_and ($smtx_bit n1 w) ($smtx_bit n2 w)) 
              $smt_builtin_z_one 
              $smt_builtin_z_zero))))
  )
)

; program: $smtx_binary_and
; return: >
;   The integer value of the binary value obtained by taking the bitwise and of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This value will be
;   taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w, 0 <= w.
(define $smtx_binary_and
  ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  ($smt_builtin_ite ($smt_builtin_z_eq w $smt_builtin_z_zero)
    $smt_builtin_z_zero
    ($smtx_binary_and_rec ($smt_builtin_z_dec w) n1 n2)))

; program: $smtx_binary_or
; return: >
;   The integer value of the binary value obtained by taking the bitwise or of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This is equal to
;   n1+n2-($smtx_binary_and w n1 n2). This value will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w, 0 <= w.
(program $smtx_binary_or ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_or w n1 n2)
    ($smt_builtin_z_add n1 ($smt_builtin_z_sub n2 ($smtx_binary_and w n1 n2))))
  )
)

; program: $smtx_binary_xor
; return: >
;   The integer value of the binary value obtained by taking the bitwise xor of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This is equal to
;   n1+n2-(2*($smtx_binary_and w n1 n2)). This value will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w, 0 <= w.
(program $smtx_binary_xor ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_xor w n1 n2)
    ($smt_builtin_z_add n1 ($smt_builtin_z_sub n2 ($smt_builtin_z_mul $smt_builtin_z_two ($smtx_binary_and w n1 n2)))))
  )
)

; program: $smtx_binary_not
; return: >
;   The integer value of the binary value obtained by taking bitwise not of
;   the binary literal ($eo_binary w n). This is equal to 2^w-(1+n). This value
;   will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n < 2^w, 0 <= w.
(program $smtx_binary_not ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_not w n)
    ($smt_builtin_z_sub ($smtx_pow2 w) ($smt_builtin_z_inc n)))
  )
)

; program: $smtx_binary_max
; return: >
;   The integer value of the maximum unsigned binary value of width w. This is
;   equal to 2^w-1.
(program $smtx_binary_max ((w $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_max w) ($smt_builtin_z_dec ($smtx_pow2 w)))
  )
)

; program: $smtx_binary_uts
; return: >
;   The conversion of n from unsigned to signed integer, which is
;   2*(n mod 2^w-1) - n.
(program $smtx_binary_uts ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_uts w n) 
    ($smt_builtin_z_sub
      ($smt_builtin_z_mul $smt_builtin_z_two
        ($smt_builtin_mod n ($smtx_pow2 ($smt_builtin_z_dec w))))
      n))
  )
)

; program: $smtx_binary_concat
; return: >
;   The integer value of the binary value obtained by concatenating binary
;   literals ($eo_binary w1 n1) and ($eo_binary w2 n2). This is equal to
;   n1*2^w2 + n2. Note the return value does not depend on w1. This value will
;   be taken modulo 2^(w1+w2).
; note: >
;   Assumes that 0 <= n1 < 2^w1, 0 <= n2 < 2^w2, 0 <= w1, 0 <= w2.
(program $smtx_binary_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_concat w1 n1 w2 n2)
    ($smt_builtin_z_add ($smt_builtin_z_mul n1 ($smtx_pow2 w2)) n2))
  )
)

; program: $smtx_binary_extract
; return: >
;   The integer value of the binary value obtained by extracting bits x1
;   through x2 (inclusive) of binary literal ($eo_binary w n). This is equal
;   to (div n 2^x1). This value will be taken modulo 2^(1+x2-x1).
; note: >
;   Assumes that 0 <= n < 2^w, 0 <= x1 <= x2 < w.
(program $smtx_binary_extract
  ((w $smt_builtin_Int) (n $smt_builtin_Int) (x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_extract w n x1 x2) ($smt_builtin_div n ($smtx_pow2 x2)))
  )
)

; In this signature, we heavily use references to the Datatypes corresponding
; to the final deep embeddings of Eunoia terms (eo.Term).
; Opaque arguments of a symbol X will be an argument of the constructor eo.X.
; We introduce datatype constructors for this datatype ($smd_X).
; It is important that we mark their arguments as :opaque, as this
; correctly models the pattern matching in the smt-meta later.
; Note that these datatypes will be renamed and replaced by their definitions
; which is hardcoded into smt_meta.smt2.

;;; Final deep embedding datatypes

; Now, we introduce placeholders for the final deep embedding.

; A Eunoia term.
; This will be replaced by the datatype eo.Term in the final encoding.
(declare-const $eo_Term Type)

; Assumes that teq is defined to be equality over eo.Term
(define $smt_builtin_teq ((x1 $eo_Term) (x2 $eo_Term)) ($smt_apply_2 "teq" x1 x2))

;;; Eunoia datatype constructors

; The Boolean type
(declare-const $smd_Bool $eo_Term)
(define $eo_Bool () $smd_Bool)

; the literal types
(declare-parameterized-const $smd_Boolean
  ((b $smt_builtin_Bool :opaque)) $eo_Term)
(define $eo_bool ((x $smt_builtin_Bool))
  ($smd_Boolean x))

(declare-parameterized-const $smd_Numeral
  ((n $smt_builtin_Int :opaque)) $eo_Term)
(define $eo_numeral ((x $smt_builtin_Int))
  ($smd_Numeral x))

(declare-parameterized-const $smd_Rational
  ((r $smt_builtin_Rat :opaque)) $eo_Term)
(define $eo_rational ((x $smt_builtin_Rat))
  ($smd_Rational x))

(declare-parameterized-const $smd_String
  ((s $smt_builtin_String :opaque)) $eo_Term)
(define $eo_string ((x $smt_builtin_String))
  ($smd_String x))

(declare-parameterized-const $smd_Binary
  ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $eo_Term)
; define: $eo_binary
; note: >
;   This should be used in pattern matching only, where it is assume that
;   it will match "legal" binary values only.
(define $eo_binary ((w $smt_builtin_Int) (v $smt_builtin_Int))
  ($smd_Binary w v))

; The type of types
(declare-const $smd_Type $eo_Term)
(define $eo_Type () $smd_Type)

; The Eunoia representation of "stuckness".
(declare-const $smd_Stuck $eo_Term)
(define $eo_stuck () $smd_Stuck)

; An application of a Eunoia term
(declare-parameterized-const $smd_Apply
  ((f $eo_Term :opaque) (a $eo_Term :opaque))
  $eo_Term)
(define $eo_apply ((x $eo_Term) (y $eo_Term)) ($smd_Apply x y))

; Function type, which Eunoia function type reduces to
(declare-parameterized-const $smd_FunType () $eo_Term)
(define $eo_fun_type () $smd_FunType)

; Represents a Eunoia variable in the final deep embedding.
(declare-parameterized-const $smd_Var
  ((s $smt_builtin_String :opaque) (T $eo_Term :opaque))
  $eo_Term)
(define $eo_Var ((s $smt_builtin_String) (T $eo_Term))
  ($smd_Var s T))

;;; External datatype access

; return: The embedding of (-> T1 T2).
; note: Since the Eunoia function type is an atomic term, this becomes a
;       curried apply.
(define $eo_mk_fun_type ((T1 $eo_Term) (T2 $eo_Term))
  ($eo_apply ($eo_apply $eo_fun_type T1) T2))

;;; Defining parametric bitvector operators

; The operators in this section are needed to reason about the parametric
; operations on the Eunoia binary literal type.

; define: $eo_empty_binary
(define $eo_empty_binary ()
  ($eo_binary $smt_builtin_z_zero $smt_builtin_z_zero))

; note: Assumes 0 <= w, makes n legal. We cannot handle errors with
;       w here since we cannot return stuckness.
(define $eo_binary_mod_w ((w $smt_builtin_Int) (n $smt_builtin_Int))
  ($eo_binary w ($smt_builtin_mod n ($smtx_pow2 w))))

; program: $eo_mk_binary
; return: >
;   A "legal" binary value ($eo_mk_binary w n1), where 0 <= n1 < 2^w, n1 is
;   congruent mod 2^w to n if w is positive, or stuck otherwise.
; note: >
;   All binaries considered by Eunoia should run through this method to ensure
;   they are legal. We alternatively use ($eo_binary_mod_w w n) if
;   we are sure that w is legal but not n.
(program $eo_mk_binary ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $eo_Term
  (
  (($eo_mk_binary w n)
    ($smt_builtin_ite ($smt_builtin_z_<= $smt_builtin_z_zero w)
      ($eo_binary_mod_w w n)  ; ensure that n is legal
      $eo_stuck))
  )
)

;;;;;; Eunoia builtin

(program $eo_typeof () :signature ($eo_Term) $eo_Term)

; We are now ready to define the builtins of Eunoia.
; We define all the Eunoia builtins here that are best to
; define in terms of SMT-LIB operators.

;;; Is okay

; Returns SMT-LIB builtin true/false if x is stuck
(define $smt_builtin_is_ok ((x $eo_Term))
  ($smt_builtin_not ($smt_builtin_teq x $eo_stuck)))

; program: $eo_is_ok
; implements: eo::is_ok
(define $eo_is_ok ((x $eo_Term))
  ($eo_bool ($smt_builtin_is_ok x)))

; program: $eo_ite
; implements: eo::ite
; note: This definition is only used if we are not eagerly flattening evaluation
(define $eo_ite ((x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term))
  ($smt_builtin_ite ($smt_builtin_teq x1 true)
    x2
  ($smt_builtin_ite ($smt_builtin_teq x1 false)
    x3
    $eo_stuck)))

; program: $eo_requires
; implements: eo::requires
; note: This definition is only used if we are not eagerly flattening evaluation
(define $eo_requires ((x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term))
  ($smt_builtin_ite ($smt_builtin_teq x1 x2)
    ($smt_builtin_ite ($smt_builtin_is_ok x1) x3 $eo_stuck)
    $eo_stuck))

; note: This definition is only used if we are not eagerly flattening evaluation
; This ensures that stuckness "propagates" through ordinary constant applications.
(program $eo_mk_apply ((x1 $eo_Term) (x2 $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_mk_apply x1 x2) ($eo_apply x1 x2))
  )
)

;;; Boolean operators

; program: $eo_not
; implements: eo::not
(program $eo_not ((T Type) (b $smt_builtin_Bool) (w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature (T) T
  (
  (($eo_not ($eo_bool b))     ($eo_bool ($smt_builtin_not b)))
  (($eo_not ($eo_binary w n)) ($eo_binary_mod_w w ($smtx_binary_not w n)))
  )
)

; program: $eo_and
; implements: eo::and
(program $eo_and
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)
   (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_and ($eo_bool b1) ($eo_bool b2))
     ($eo_bool ($smt_builtin_and b1 b2)))
  (($eo_and ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
      ($eo_binary_mod_w w1 ($smtx_binary_and w1 n1 n2))))
  )
)

; program: $eo_or
; implements: eo::or
(program $eo_or
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)
   (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_or ($eo_bool b1) ($eo_bool b2))
     ($eo_bool ($smt_builtin_or b1 b2)))
  (($eo_or ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
     ($eo_binary_mod_w w1 ($smtx_binary_or w1 n1 n2))))
  )
)

; program: $eo_xor
; implements: eo::xor
(program $eo_xor
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)
   (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_xor ($eo_bool b1) ($eo_bool b2))
     ($eo_bool ($smt_apply_2 "xor" b1 b2)))
  (($eo_xor ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
     ($eo_binary_mod_w w1 ($smtx_binary_or w1 n1 n2))))
  )
)

;;; Arithmetic operators

; program: $eo_add
; implements: eo::add
(program $eo_add
  ((T Type) (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (r1 $smt_builtin_Rat) (r2 $smt_builtin_Rat))
  :signature (T T) T
  (
  (($eo_add ($eo_numeral n1) ($eo_numeral n2))
    ($eo_numeral ($smt_builtin_z_add n1 n2)))
  (($eo_add ($eo_rational r1) ($eo_rational r2))
    ($eo_rational ($smt_builtin_q_add r1 r2)))
  (($eo_add ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
      ($eo_binary_mod_w w1 ($smt_builtin_z_add n1 n2))))  ; don't need to recheck bitwidth
  )
)

(program $eo_mul
  ((T Type) (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (r1 $smt_builtin_Rat) (r2 $smt_builtin_Rat))
  :signature (T T) T
  (
  (($eo_mul ($eo_numeral n1) ($eo_numeral n2))
    ($eo_numeral ($smt_builtin_z_mul n1 n2)))
  (($eo_mul ($eo_rational r1) ($eo_rational r2))
    ($eo_rational ($smt_builtin_q_mul r1 r2)))
  (($eo_mul ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
      ($eo_binary_mod_w w1 ($smt_builtin_z_mul n1 n2))))
  )
)

(program $eo_qdiv
  ((T Type) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int)
   (r1 $smt_builtin_Rat) (r2 $smt_builtin_Rat))
  :signature (T T) $eo_Term
  (
  (($eo_qdiv ($eo_numeral n1) ($eo_numeral n2))
    (eo::define ((r1 ($smt_apply_1 "to_real" n1)))
    (eo::define ((r2 ($smt_apply_1 "to_real" n2)))
    ($smt_builtin_ite ($smt_builtin_z_eq $smt_builtin_z_zero n2)
      $eo_stuck
      ($eo_rational ($smt_apply_2 "/" r1 r2))))))
  (($eo_qdiv ($eo_rational r1) ($eo_rational r2))
    ($smt_builtin_ite ($smt_builtin_q_eq $smt_builtin_q_zero r2)
      $eo_stuck
      ($eo_rational ($smt_apply_2 "/" r1 r2))))
  )
)


(program $eo_zdiv
  ((T Type) (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_zdiv ($eo_numeral n1) ($eo_numeral n2))
    ($smt_builtin_ite ($smt_builtin_z_eq $smt_builtin_z_zero n2)
      $eo_stuck
      ($eo_numeral ($smt_builtin_div n1 n2))))
  (($eo_zdiv ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
      ($smt_builtin_ite ($smt_builtin_z_eq $smt_builtin_z_zero n2)
        ($eo_binary w1 ($smtx_binary_max w1))
        ($eo_binary_mod_w w1 ($smt_builtin_div n1 n2)))))
  )
)

(program $eo_zmod
  ((T Type) (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_zmod ($eo_numeral n1) ($eo_numeral n2))
    ($smt_builtin_ite ($smt_builtin_z_eq $smt_builtin_z_zero n2)
      $eo_stuck
      ($eo_numeral ($smt_builtin_mod n1 n2))))
  (($eo_zmod ($eo_binary w1 n1) ($eo_binary w2 n2))
    ($eo_requires ($eo_numeral w1) ($eo_numeral w2)
      ($smt_builtin_ite ($smt_builtin_z_eq $smt_builtin_z_zero n2)
        ($eo_binary w1 n1)
        ($eo_binary_mod_w w1 ($smt_builtin_mod n1 n2)))))
  )
)

(program $eo_is_neg ((T Type) (n1 $smt_builtin_Int) (r1 $smt_builtin_Rat))
  :signature (T) Bool
  (
  (($eo_is_neg ($eo_numeral n1))
    ($eo_bool ($smt_builtin_z_< n1 $smt_builtin_z_zero)))
  (($eo_is_neg ($eo_rational r1))
    ($eo_bool ($smt_builtin_q_< r1 $smt_builtin_q_zero)))
  )
)

; program: $eo_neg
; implements: eo::neg
(program $eo_neg ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (r1 $smt_builtin_Rat))
  :signature (T) T
  (
  (($eo_neg ($eo_numeral n1))
    ($eo_numeral ($smt_builtin_z_neg n1)))
  (($eo_neg ($eo_rational r1))
    ($eo_rational ($smt_builtin_q_neg r1)))
  (($eo_neg ($eo_binary w n1))
    ($eo_binary_mod_w w ($smt_builtin_z_neg n1)))
  )
)


;;; String operators

; program: $eo_len
; implements: eo::len
(program $eo_len ((T Type) (s1 $smt_builtin_String) (w $smt_builtin_Int) (n1 $smt_builtin_Int))
  :signature (T) $eo_Term
  (
  (($eo_len ($eo_string s1))
    ($eo_numeral ($smt_apply_1 "str.len" s1)))
  (($eo_len ($eo_binary w n1))
    ($eo_numeral w))
  )
)

; program: $eo_concat
; implements: eo::concat
(program $eo_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int)
   (s1 $smt_builtin_String) (s2 $smt_builtin_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_concat ($eo_string s1) ($eo_string s2))
     ($eo_string ($smt_apply_2 "str.++" s1 s2)))
  (($eo_concat ($eo_binary w1 n1) ($eo_binary w2 n2))
     ($eo_mk_binary ($smt_builtin_z_add w1 w2) ($smtx_binary_concat w1 n1 w2 n2)))
  )
)

; program: $eo_extract
; implements: eo::extract
(program $eo_extract
  ((s1 $smt_builtin_String) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (n3 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($eo_extract ($eo_string s1) ($eo_numeral n2) ($eo_numeral n3))
     ($eo_string ($smt_apply_3 "str.substr" s1 n2 ($smt_builtin_z_inc ($smt_builtin_z_sub n3 n2)))))
  (($eo_extract ($eo_binary w n1) ($eo_numeral n2) ($eo_numeral n3))
    (eo::define ((nw ($smt_builtin_z_sub n3 n2)))
    ($smt_builtin_ite ($smt_builtin_or ($smt_builtin_z_< n2 $smt_builtin_z_zero) ($smt_builtin_z_< nw $smt_builtin_z_zero))
      $eo_empty_binary
      ($eo_mk_binary
        ($smt_builtin_z_inc nw)
        ($smtx_binary_extract w n1 n2 n3)))))
  )
)

; program: $eo_find
; implements: eo::find
(program $eo_find ((s1 $smt_builtin_String) (s2 $smt_builtin_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_find ($eo_string s1) ($eo_string s2))
     ($eo_numeral ($smt_apply_3 "str.indexof" s1 s2 $smt_builtin_z_zero)))
  )
)

;;; Conversion operators

; program: $eo_to_z
; implements: eo::to_z
(program $eo_to_z ((n1 $smt_builtin_Int) (r1 $smt_builtin_Rat) (s1 $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_z ($eo_numeral n1))   ($eo_numeral n1))
  (($eo_to_z ($eo_rational r1))  ($eo_numeral ($smt_apply_1 "to_int" r1)))
  (($eo_to_z ($eo_string s1))
    ($smt_builtin_ite
      ($smt_builtin_z_eq $smt_builtin_z_one ($smt_apply_1 "str.len" s1))
      ($eo_numeral ($smt_apply_1 "str.to_code" s1))
      $eo_stuck))
  (($eo_to_z ($eo_binary w n1))     ($eo_numeral n1))
  )
)

; program: $eo_to_q
; implements: eo::to_q
(program $eo_to_q ((n1 $smt_builtin_Int) (r1 $smt_builtin_Rat) (s1 $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_q ($eo_numeral n1))   ($eo_rational ($smt_apply_1 "to_real" n1)))
  (($eo_to_q ($eo_rational r1))  ($eo_rational r1))
  )
)

; program: $eo_to_bin
; implements: eo::to_bin
(program $eo_to_bin ((w $smt_builtin_Int) (w1 $smt_builtin_Int) (n1 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_to_bin ($eo_numeral w) ($eo_numeral n1))
    ; the upper bound is enforced here
    ($smt_builtin_ite ($smt_builtin_z_<= w $smt_builtin_z_max_width)
      ($eo_mk_binary w n1)
      $eo_stuck))
  (($eo_to_bin ($eo_numeral w) ($eo_binary w1 n1))
    ; the upper bound is enforced here
    ($smt_builtin_ite ($smt_builtin_z_<= w $smt_builtin_z_max_width)
      ($eo_mk_binary w n1)
      $eo_stuck))
  )
)

; program: $eo_to_str
; implements: eo::to_str
(program $eo_to_str ((n1 $smt_builtin_Int) (s1 $smt_builtin_String))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_to_str ($eo_numeral n1))
    ($smt_builtin_ite
      ($smt_builtin_and ($smt_builtin_z_<= $smt_builtin_z_zero n1) ($smt_builtin_z_< n1 $smt_builtin_z_max_code))
      ($eo_string ($smt_apply_1 "str.from_code" n1))
      $eo_stuck))
  (($eo_to_str ($eo_string s1)) ($eo_string s1))
  ; TODO: technically others here
  )
)

;;; Testers

;;; $eo_is_eq

;;; $eo_eq

; program: $eo_eq
; implements: eo::eq
(program $eo_eq ((t $eo_Term) (s $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_eq t s) ($eo_bool ($smt_builtin_teq s t)))
  )
)

; Returns true if t and s are equivalent values (ground and fully evaluated).
; define: $eo_is_eq
; implements: eo::is_eq
(define $eo_is_eq ((t $eo_Term) (s $eo_Term))
  ($eo_bool ($smt_apply_nary_3 "and"
    ($smt_builtin_is_ok t)
    ($smt_builtin_is_ok s)
    ($smt_builtin_teq s t))))

;;; $eo_is_bool

; Returns true if x is a Boolean literal.
(program $eo_is_bool_internal ((x $eo_Term) (b $smt_builtin_Bool))
  :signature ($eo_Term) Bool
  (
  (($eo_is_bool_internal ($eo_bool b))  true)
  (($eo_is_bool_internal x)                false)
  )
)

; Returns true if x is a Boolean literal.
; define: $eo_is_bool
; implements: eo::is_bool
(define $eo_is_bool ((t $eo_Term))
  ($eo_bool ($smt_builtin_and ($smt_builtin_is_ok t)
    ($smt_builtin_teq ($eo_is_bool_internal t) true))))

;;; $eo_is_z

; Returns true if x is a numeral literal.
(program $eo_is_z_internal ((x $eo_Term) (n $smt_builtin_Int))
  :signature ($eo_Term) Bool
  (
  (($eo_is_z_internal ($eo_numeral n))  true)
  (($eo_is_z_internal x)                false)
  )
)

; Returns true if x is a numeral literal.
; define: $eo_is_z
; implements: eo::is_z
(define $eo_is_z ((t $eo_Term))
  ($eo_bool ($smt_builtin_and ($smt_builtin_is_ok t)
    ($smt_builtin_teq ($eo_is_z_internal t) true))))

;;; $eo_is_q

; Returns true if x is a rational literal.
(program $eo_is_q_internal ((x $eo_Term) (r $smt_builtin_Rat))
  :signature ($eo_Term) Bool
  (
  (($eo_is_q_internal ($eo_rational r))  true)
  (($eo_is_q_internal x)                 false)
  )
)

; Returns true if x is a rational literal.
; define: $eo_is_q
; implements: eo::is_q
(define $eo_is_q ((t $eo_Term))
  ($eo_bool ($smt_builtin_and ($smt_builtin_is_ok t)
    ($smt_builtin_teq ($eo_is_q_internal t) true))))


;;; $eo_is_bin

; Returns true if x is a binary literal.
(program $eo_is_bin_internal ((x $eo_Term) (w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($eo_Term) Bool
  (
  (($eo_is_bin_internal ($eo_binary w n))  true)
  (($eo_is_bin_internal x)                 false)
  )
)

; Returns true if x is a binary literal.
; define: $eo_is_bin
; implements: eo::is_bin
(define $eo_is_bin ((t $eo_Term))
  ($eo_bool ($smt_builtin_and ($smt_builtin_is_ok t)
    ($smt_builtin_teq ($eo_is_bin_internal t) true))))

;;; $eo_is_str

; Returns true if x is a string literal.
(program $eo_is_str_internal ((x $eo_Term) (s $smt_builtin_String))
  :signature ($eo_Term) Bool
  (
  (($eo_is_str_internal ($eo_string s)) true)
  (($eo_is_str_internal x)                 false)
  )
)

; Returns true if x is a string literal.
; define: $eo_is_str
; implements: eo::is_str
(define $eo_is_str ((t $eo_Term))
  ($eo_bool ($smt_builtin_and ($smt_builtin_is_ok t)
    ($smt_builtin_teq ($eo_is_str_internal t) true))))

;;; Derived arithmetic

; final-decl: $smtx_hash
; note: this is defined axiomatically in the final smt2 encoding.
(program $smtx_hash ((T Type)) :signature (T) $smt_builtin_Int)

; program: $eo_hash
; implements: eo::hash
; note: this invokes the underconstrained function above as an oracle.
(program $eo_hash ((T Type) (t T))
  :signature (T) $eo_Term
  (
  (($eo_hash t) ($eo_numeral ($smtx_hash t)))
  )
)

; final-decl: $eo_reverse_hash
; note: this is the inverse of $smtx_hash, which will be defined axiomatically.
(program $eo_reverse_hash () :signature ($smt_builtin_Int) $eo_Term)

; The SMT-LIB comparison of two Eunoia or SMT-LIB terms.
(define $smtx_cmp ((T Type :implicit) (a T) (b T))
  ($smt_builtin_z_<= ($smtx_hash a) ($smtx_hash b)))


;;; $eo_gt

; Compare arithmetic greater than. Assumes x and y are values.
; Returns true if x > y.
; define: $eo_gt
; implements: eo::gt
(define $eo_gt ((x $eo_Term) (y $eo_Term))
  ($eo_is_neg ($eo_add ($eo_neg x) y)))


;;; $eo_cmp

; An arbitrary deterministic comparison of terms. Returns true if a > b based
; on this ordering.
; define: $eo_cmp
; implements: eo::cmp
(define $eo_cmp ((a $eo_Term) (b $eo_Term))
  ($eo_is_neg ($eo_add ($eo_hash b) ($eo_neg ($eo_hash a)))))

;;; since eo_typeof depends on literal predicates, typeof is only now ready.

; program: $eo_var
; implements: eo::var
(program $eo_var ((s $smt_builtin_String) (T $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_var ($eo_string s) T)
    ; we use the hash of the type T to identify the variable
    ($eo_requires ($eo_typeof T) Type ($eo_Var s T)))
  )
)

; program: $eo_nameof
; implements: eo::nameof
(program $eo_nameof ((s $smt_builtin_String) (T $eo_Term))
  :signature ($eo_Term) $eo_Term
  (
  (($eo_nameof ($eo_Var s T)) ($eo_string s))
  )
)

; Returns true if x is a variable.
; define: $eo_is_var
; implements: eo::is_var
(define $eo_is_var ((x $eo_Term))
  ($eo_is_eq ($eo_var ($eo_nameof x) ($eo_typeof x)) x))

; fwd-decl: $eo_typeof_main
; note: This method returns the type for all user defined terms.
(program $eo_typeof_main () :signature ($eo_Term) Type)

; forward declarations for literal type rules
(program $eo_lit_type_Numeral ((T Type)) :signature (T) Type)
(program $eo_lit_type_Rational ((T Type)) :signature (T) Type)
(program $eo_lit_type_Binary ((T Type)) :signature (T) Type)
(program $eo_lit_type_String ((T Type)) :signature (T) Type)
  
; program: $eo_typeof
; implements: eo::typeof
(program $eo_typeof
  ((t $eo_Term) (T $eo_Term) (b $smt_builtin_Bool) (n $smt_builtin_Int) (r $smt_builtin_Rat)
   (s $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Term
  (
  ; TODO: auto-generate these?
  (($eo_typeof ($eo_bool b))                 Bool)
  (($eo_typeof ($eo_numeral n))              ($eo_lit_type_Numeral ($eo_numeral n)))
  (($eo_typeof ($eo_rational r))             ($eo_lit_type_Rational ($eo_rational r)))
  (($eo_typeof ($eo_string s))               ($eo_lit_type_String ($eo_string s)))
  (($eo_typeof ($eo_binary w n))             ($eo_lit_type_Binary ($eo_binary w n)))
  (($eo_typeof ($eo_Var s T))                T)
  ; otherwise, invoke the routine for user types from the signature.
  (($eo_typeof t)                            ($eo_typeof_main t))
  )
)
(program $eo_is_list_rec
  ((T Type) (U Type) (V Type) (W Type) (X Type)
   (f (-> T U V)) (g (-> T U V)) (x T) (y U) (nil W) (z X))
  :signature ((-> T U V) W X) Bool
  (
  (($eo_is_list_rec f nil (g x y)) (eo::ite (eo::eq f g)
                                      ($eo_is_list_rec f nil y) false))
  (($eo_is_list_rec f nil z)       (eo::eq nil z))
  )
)
(define $eo_is_list
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T U V)) (x W))
  ($eo_is_list_rec f ($eo_nil f ($eo_typeof x)) x))
(define $eo_cons
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (W1 Type :implicit) (W2 Type :implicit)
   (f (-> T U V)) (e W1) (a W2))
  (eo::requires ($eo_is_list f a) true (f e a)))
(program $eo_list_concat_rec
  ((T Type) (U Type) (V Type) (W Type) (f (-> T V V)) (x W) (y U) (z U) (nil U))
  :signature (U U) U
  (
  (($eo_list_concat_rec (f x y) z)  (f x ($eo_list_concat_rec y z)))
  (($eo_list_concat_rec nil z)      z)
  )
)
(define $eo_list_concat
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (f (-> T V V)) (a U) (b U))
  (eo::requires ($eo_is_list f a) true
  (eo::requires ($eo_is_list f b) true
    ($eo_list_concat_rec a b))))
(program $eo_list_rev_rec
  ((T Type) (U Type) (V Type) (W Type)
   (f (-> T V V)) (x W) (y U) (nil U) (acc U))
  :signature (U U) U
  (
    (($eo_list_rev_rec (f x y) acc) ($eo_list_rev_rec y (f x acc)))
    (($eo_list_rev_rec nil acc)      acc)
  )
)
(define $eo_list_rev
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (f (-> T V V)) (a U))
  (eo::requires ($eo_is_list f a) true
    ($eo_list_rev_rec a ($eo_nil f ($eo_typeof a)))))
(declare-const @@Pair (-> Type (-> Type Type)))
(declare-parameterized-const @@pair ((U Type :implicit) ($eo_x_1 U) (T Type :implicit) ($eo_x_2 T)) (_ (@@Pair U) T))
(program $pair_first ((S Type) (T Type) (s S) (t T))
  :signature ((_ (@@Pair T) S)) T
  (
  (($pair_first (_ (@@pair t) s)) t)
  )
)
(program $pair_second ((T Type) (S Type) (t T) (s S))
  :signature ((_ (@@Pair T) S)) S
  (
  (($pair_second (_ (@@pair t) s)) s)
  )
)
(declare-parameterized-const ite (($eo_x_1 Bool) (A Type :implicit) ($eo_x_2 A) ($eo_x_3 A)) A)
(declare-const not (-> Bool Bool))
(declare-const or (-> Bool (-> Bool Bool)))
(declare-const and (-> Bool (-> Bool Bool)))
(declare-const => (-> Bool (-> Bool Bool)))
(declare-const xor (-> Bool (-> Bool Bool)))
(declare-parameterized-const = ((A Type :implicit) ($eo_x_1 A) ($eo_x_2 A)) Bool)
(program $arith_typeunion ()
  :signature (Type Type) Type
  (
  (($arith_typeunion Int Int) Int)
  (($arith_typeunion Real Real) Real)
  (($arith_typeunion Real Int) Real)
  (($arith_typeunion Int Real) Real)
  )
)
(program $is_arith_type ()
  :signature (Type) Bool
  (
  (($is_arith_type Int) true)
  (($is_arith_type Real) true)
  )
)
(declare-parameterized-const + ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) ($arith_typeunion T U))
(declare-parameterized-const - ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) ($arith_typeunion T U))
(declare-parameterized-const * ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) ($arith_typeunion T U))
(declare-parameterized-const < ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
(declare-parameterized-const <= ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
(declare-parameterized-const > ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
(declare-parameterized-const >= ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
(declare-parameterized-const to_real ((T Type :implicit) ($eo_x_1 T)) Real)
(declare-parameterized-const to_int ((T Type :implicit) ($eo_x_1 T)) Int)
(declare-parameterized-const is_int ((T Type :implicit) ($eo_x_1 T)) Bool)
(declare-parameterized-const abs ((T Type :implicit) ($eo_x_1 T)) T)
(declare-parameterized-const $eoo_-.2 ((T Type :implicit) ($eo_x_1 T)) T)
(declare-const div (-> Int (-> Int Int)))
(declare-const mod (-> Int (-> Int Int)))
(declare-const int.pow2 (-> Int Int))
(declare-const int.log2 (-> Int Int))
(declare-const int.ispow2 (-> Int Bool))
(declare-const div_total (-> Int (-> Int Int)))
(declare-const mod_total (-> Int (-> Int Int)))
(program $arith_eval_int_log_2_rec ((x Int))
  :signature (Int) Int
  (
  (($arith_eval_int_log_2_rec 1) 0)
  (($arith_eval_int_log_2_rec x) (eo::add 1 ($arith_eval_int_log_2_rec (eo::zdiv x 2))))
  )
)
(program $arith_eval_int_pow_2_rec ((x Int))
  :signature (Int) Int
  (
  (($arith_eval_int_pow_2_rec 0) 1)
  (($arith_eval_int_pow_2_rec x) (eo::mul 2 ($arith_eval_int_pow_2_rec (eo::add x -1))))
  )
)
(program $bv_bitwidth ((n Int))
  :signature (Type) Int
  (
  (($bv_bitwidth (BitVec n)) n)
  )
)
(declare-parameterized-const @bvsize ((m Int :implicit) ($eo_x_1 (BitVec m))) Int)
(declare-parameterized-const concat ((n Int :implicit) ($eo_x_1 (BitVec n)) (m Int :implicit) ($eo_x_2 (BitVec m))) (BitVec (eo::add n m)))
(declare-parameterized-const extract ((h Int) (l Int) (n Int :implicit) ($eo_x_1 (BitVec n))) (BitVec (eo::requires (eo::gt (eo::add l 1) 0) true (eo::requires (eo::gt n h) true (eo::add (eo::add h (eo::neg l)) 1)))))
(declare-parameterized-const repeat ((i Int) (n Int :implicit) ($eo_x_1 (BitVec n))) (BitVec (eo::mul i n)))
(declare-parameterized-const bvnot ((m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec m))
(declare-parameterized-const bvand ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvor ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvxor ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvneg ((m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec m))
(declare-parameterized-const bvadd ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvmul ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvudiv ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvurem ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvsub ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvult ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvule ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvugt ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvuge ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvslt ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvsle ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvsgt ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvsge ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvshl ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvlshr ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvashr ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const zero_extend ((i Int) (m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec (eo::add m i)))
(declare-parameterized-const sign_extend ((i Int) (m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec (eo::add m i)))
(declare-parameterized-const @bv ((value Int) (w Int)) (BitVec w))
(declare-parameterized-const seq.empty ((T Type :implicit)) (Seq T))
(program $seq_empty ((T Type))
  :signature ((eo::quote T)) T
  (
  (($seq_empty (Seq Char)) "")
  (($seq_empty T) (as seq.empty T))
  )
)
(declare-parameterized-const str.len ((T Type :implicit) ($eo_x_1 (Seq T))) Int)
(declare-parameterized-const str.++ ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) (Seq T))
(declare-parameterized-const str.substr ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 Int) ($eo_x_3 Int)) (Seq T))
(declare-parameterized-const str.contains ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) Bool)
(declare-parameterized-const str.replace ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T)) ($eo_x_3 (Seq T))) (Seq T))
(declare-parameterized-const str.indexof ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T)) ($eo_x_3 Int)) Int)
(declare-parameterized-const str.at ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 Int)) (Seq T))
(declare-parameterized-const str.prefixof ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) Bool)
(declare-parameterized-const str.suffixof ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) Bool)
(declare-parameterized-const str.rev ((T Type :implicit) ($eo_x_1 (Seq T))) (Seq T))
(declare-parameterized-const str.update ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 Int) ($eo_x_3 (Seq T))) (Seq T))
(declare-const str.to_lower (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
(declare-const str.to_upper (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
(declare-const str.to_code (-> (Seq Char) Int))
(declare-const str.from_code (-> Int (Seq Char)))
(declare-const str.to_int (-> (Seq Char) Int))
(declare-const str.from_int (-> Int (Seq Char)))
(declare-const str.<= (eo::define ((_v0 (Seq Char))) (-> _v0 (-> _v0 Bool))))
(declare-parameterized-const str.replace_all ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T)) ($eo_x_3 (Seq T))) (Seq T))
(declare-parameterized-const / ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Real)
(declare-parameterized-const /_total ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Real)
(program $bv_unfold_repeat_rec ((m Int) (n Int) (b (BitVec m)))
  :signature ((eo::quote n) (BitVec m)) (BitVec (eo::mul n m))
  (
  (($bv_unfold_repeat_rec 0 b) (eo::to_bin 0 0))
  (($bv_unfold_repeat_rec n b) (eo::cons concat b ($bv_unfold_repeat_rec (eo::add n -1) b)))
  )
)
(program $str_nary_intro ((T Type) (ss (Seq T)) (t (Seq T)))
  :signature ((Seq T)) (Seq T)
  (
  (($str_nary_intro (_ (str.++ t) ss)) (_ (str.++ t) ss))
  (($str_nary_intro t) (eo::define ((_v0 ($seq_empty (eo::typeof t)))) (eo::ite (eo::eq t _v0) t (eo::cons str.++ t _v0))))
  )
)
(program $str_nary_elim ((T Type) (ss (Seq T)) (t (Seq T)))
  :signature ((Seq T)) (Seq T)
  (
  (($str_nary_elim (_ (str.++ t) ss)) (eo::ite (eo::eq ss ($seq_empty (eo::typeof t))) t (_ (str.++ t) ss)))
  (($str_nary_elim t) (eo::requires t ($seq_empty (eo::typeof t)) t))
  )
)
(program $str_flatten_word ((U Type) (t (Seq U)))
  :signature ((Seq U)) (Seq U)
  (
  (($str_flatten_word "") "")
  (($str_flatten_word t) (eo::cons str.++ (eo::extract t 0 0) ($str_flatten_word (eo::extract t 1 (eo::len t)))))
  )
)
(program $str_flatten ((U Type) (tail (Seq U)) (t (Seq U)))
  :signature ((Seq U)) (Seq U)
  (
  (($str_flatten (_ (str.++ t) tail)) (eo::define ((_v0 ($str_flatten tail))) (eo::ite (eo::is_eq (eo::is_neg (eo::add 1 (eo::neg (eo::len t)))) true) (eo::list_concat str.++ ($str_flatten_word t) _v0) (eo::cons str.++ t _v0))))
  (($str_flatten t) (eo::requires t ($seq_empty (eo::typeof t)) t))
  )
)
(program $str_collect_acc ((U Type) (t (Seq U)) (tail (Seq U)))
  :signature ((Seq U)) (eo::define ((_v0 (Seq U))) (_ (@@Pair _v0) _v0))
  (
  (($str_collect_acc (_ (str.++ t) tail)) (eo::define ((_v0 ($str_collect_acc tail))) (eo::define ((_v1 ($pair_second _v0))) (eo::define ((_v2 ($pair_first _v0))) (eo::ite (eo::is_eq (eo::len t) 1) (eo::ite (eo::eq _v2 "") (_ (@@pair t) _v1) (_ (@@pair (eo::concat t _v2)) _v1)) (_ (@@pair "") (_ (str.++ t) tail)))))))
  (($str_collect_acc "") (_ (@@pair "") ""))
  )
)
(program $str_collect ((U Type) (s (Seq U)) (t (Seq U)))
  :signature ((Seq U)) (Seq U)
  (
  (($str_collect (_ (str.++ t) s)) (eo::define ((_v0 ($str_collect_acc (_ (str.++ t) s)))) (eo::define ((_v1 ($pair_first _v0))) (eo::ite (eo::eq _v1 "") (eo::cons str.++ t ($str_collect s)) (eo::cons str.++ _v1 ($str_collect ($pair_second _v0)))))))
  (($str_collect t) (eo::requires t ($seq_empty (eo::typeof t)) t))
  )
)
(program $str_from_int_eval_rec ((n Int) (s (Seq Char)))
  :signature (Int (Seq Char)) (Seq Char)
  (
  (($str_from_int_eval_rec n s) (eo::ite (eo::eq n 0) (eo::ite (eo::eq s "") "0" s) ($str_from_int_eval_rec (eo::zdiv n 10) (eo::concat (eo::to_str (eo::add 48 (eo::zmod n 10))) s))))
  )
)
(program $str_to_int_eval_rec ((s2 (Seq Char)) (s1 (Seq Char)) (e Int) (n Int))
  :signature ((Seq Char) Int Int) Int
  (
  (($str_to_int_eval_rec (_ (str.++ s1) s2) e n) (eo::define ((_v0 (eo::add (eo::to_z s1) -48))) (eo::ite (eo::and (eo::gt 10 _v0) (eo::not (eo::is_neg _v0))) ($str_to_int_eval_rec s2 (eo::mul e 10) (eo::add (eo::mul _v0 e) n)) -1)))
  (($str_to_int_eval_rec "" e n) n)
  )
)
(program $str_case_conv_rec ((s1 (Seq Char)) (s2 (Seq Char)) (isLower Bool))
  :signature ((Seq Char) Bool) (Seq Char)
  (
  (($str_case_conv_rec (_ (str.++ s1) s2) true) (eo::define ((_v0 (eo::to_z s1))) (eo::concat (eo::to_str (eo::add _v0 (eo::ite (eo::and (eo::gt 91 _v0) (eo::gt _v0 64)) 32 0))) ($str_case_conv_rec s2 true))))
  (($str_case_conv_rec (_ (str.++ s1) s2) false) (eo::define ((_v0 (eo::to_z s1))) (eo::concat (eo::to_str (eo::add _v0 (eo::ite (eo::and (eo::gt 123 _v0) (eo::gt _v0 96)) -32 0))) ($str_case_conv_rec s2 false))))
  (($str_case_conv_rec "" isLower) "")
  )
)
(program $str_leq_eval_rec ((s2 (Seq Char)) (t2 (Seq Char)) (s1 (Seq Char)) (t1 (Seq Char)))
  :signature ((Seq Char) (Seq Char)) Bool
  (
  (($str_leq_eval_rec (_ (str.++ s1) s2) (_ (str.++ t1) t2)) (eo::ite (eo::eq s1 t1) ($str_leq_eval_rec s2 t2) (eo::gt (eo::to_z t1) (eo::to_z s1))))
  (($str_leq_eval_rec "" t1) true)
  (($str_leq_eval_rec s1 t1) false)
  )
)
(program $str_eval_replace_all_rec ((u (Seq Char)) (n Int) (s (Seq Char)) (t (Seq Char)) (lent Int))
  :signature ((Seq Char) (Seq Char) (Seq Char) Int Int) (Seq Char)
  (
  (($str_eval_replace_all_rec s t u -1 lent) s)
  (($str_eval_replace_all_rec s t u n lent) (eo::define ((_v0 (eo::extract s (eo::add n lent) (eo::len s)))) (eo::concat (eo::concat (eo::extract s 0 (eo::add n -1)) u) ($str_eval_replace_all_rec _v0 t u (eo::find _v0 t) lent))))
  )
)
(declare-parameterized-const int_to_bv ((w Int) ($eo_x_1 Int)) (BitVec w))
(declare-parameterized-const ubv_to_int ((m Int :implicit) ($eo_x_1 (BitVec m))) Int)
(declare-parameterized-const sbv_to_int ((m Int :implicit) ($eo_x_1 (BitVec m))) Int)
(program $run_evaluate ((S Type) (bs Bool) (b Bool) (b2 Bool) (ys S) (T Type) (y T) (i2 Int) (x T) (i1 Int) (sys (Seq T)) (sz (Seq T)) (ssz (Seq Char)) (ssy (Seq Char)) (ssx (Seq Char)) (sy (Seq T)) (sx (Seq T)) (m Int) (ybs (BitVec m)) (n Int) (zbs (BitVec n)) (yb (BitVec m)) (xb (BitVec m)) (z S))
  :signature (S) S
  (
  (($run_evaluate (_ (= x) y)) (eo::define ((_v0 ($run_evaluate y))) (eo::define ((_v1 ($run_evaluate x))) (eo::define ((_v2 (eo::eq _v1 _v0))) (eo::ite (eo::and (eo::is_q _v1) (eo::is_q _v0)) _v2 (eo::ite (eo::and (eo::is_z _v1) (eo::is_z _v0)) _v2 (eo::ite (eo::and (eo::is_bin _v1) (eo::is_bin _v0)) _v2 (eo::ite (eo::and (eo::is_str _v1) (eo::is_str _v0)) _v2 (eo::ite (eo::and (eo::is_bool _v1) (eo::is_bool _v0)) _v2 (_ (= _v1) _v0))))))))))
  (($run_evaluate (not b)) (eo::not ($run_evaluate b)))
  (($run_evaluate (_ (_ (ite b) x) y)) (eo::ite ($run_evaluate b) ($run_evaluate x) ($run_evaluate y)))
  (($run_evaluate (_ (or b) bs)) (eo::or ($run_evaluate b) ($run_evaluate bs)))
  (($run_evaluate (_ (=> b) b2)) (eo::or (eo::not ($run_evaluate b)) ($run_evaluate b2)))
  (($run_evaluate (_ (and b) bs)) (eo::and ($run_evaluate b) ($run_evaluate bs)))
  (($run_evaluate (_ (xor b) b2)) (eo::xor ($run_evaluate b) ($run_evaluate b2)))
  (($run_evaluate (_ (< x) z)) (eo::is_neg (eo::add (eo::to_q ($run_evaluate x)) (eo::neg (eo::to_q ($run_evaluate z))))))
  (($run_evaluate (_ (<= x) z)) (eo::define ((_v0 (eo::add (eo::to_q ($run_evaluate x)) (eo::neg (eo::to_q ($run_evaluate z)))))) (eo::or (eo::is_neg _v0) (eo::eq _v0 0/1))))
  (($run_evaluate (_ (> x) z)) (eo::is_neg (eo::add (eo::to_q ($run_evaluate z)) (eo::neg (eo::to_q ($run_evaluate x))))))
  (($run_evaluate (_ (>= x) z)) (eo::define ((_v0 (eo::add (eo::to_q ($run_evaluate z)) (eo::neg (eo::to_q ($run_evaluate x)))))) (eo::or (eo::is_neg _v0) (eo::eq _v0 0/1))))
  (($run_evaluate (_ (+ x) ys)) (eo::define ((_v0 ($run_evaluate ys))) (eo::define ((_v1 ($run_evaluate x))) (eo::define ((_v2 (eo::to_q _v0))) (eo::define ((_v3 (eo::to_q _v1))) (eo::define ((_v4 (eo::add _v3 _v2))) (eo::ite (eo::eq _v1 _v3) _v4 (eo::ite (eo::eq _v0 _v2) _v4 (eo::add _v1 _v0)))))))))
  (($run_evaluate (_ (- x) z)) (eo::define ((_v0 (eo::neg ($run_evaluate z)))) (eo::define ((_v1 ($run_evaluate x))) (eo::define ((_v2 (eo::to_q _v0))) (eo::define ((_v3 (eo::to_q _v1))) (eo::define ((_v4 (eo::add _v3 _v2))) (eo::ite (eo::eq _v1 _v3) _v4 (eo::ite (eo::eq _v0 _v2) _v4 (eo::add _v1 _v0)))))))))
  (($run_evaluate (_ (* x) ys)) (eo::define ((_v0 ($run_evaluate ys))) (eo::define ((_v1 ($run_evaluate x))) (eo::define ((_v2 (eo::to_q _v0))) (eo::define ((_v3 (eo::to_q _v1))) (eo::define ((_v4 (eo::mul _v3 _v2))) (eo::ite (eo::eq _v1 _v3) _v4 (eo::ite (eo::eq _v0 _v2) _v4 (eo::mul _v1 _v0)))))))))
  (($run_evaluate ($eoo_-.2 x)) (eo::neg ($run_evaluate x)))
  (($run_evaluate (_ (/ x) y)) (eo::qdiv (eo::to_q ($run_evaluate x)) (eo::to_q ($run_evaluate y))))
  (($run_evaluate (_ (/_total x) y)) (eo::define ((_v0 (eo::to_q ($run_evaluate y)))) (eo::ite (eo::eq _v0 0/1) 0/1 (eo::qdiv (eo::to_q ($run_evaluate x)) _v0))))
  (($run_evaluate (_ (div i1) i2)) (eo::zdiv ($run_evaluate i1) ($run_evaluate i2)))
  (($run_evaluate (_ (div_total i1) i2)) (eo::define ((_v0 ($run_evaluate i2))) (eo::ite (eo::eq _v0 0) 0 (eo::zdiv ($run_evaluate i1) _v0))))
  (($run_evaluate (_ (mod i1) i2)) (eo::zmod ($run_evaluate i1) ($run_evaluate i2)))
  (($run_evaluate (_ (mod_total i1) i2)) (eo::define ((_v0 ($run_evaluate i2))) (eo::define ((_v1 ($run_evaluate i1))) (eo::ite (eo::eq _v0 0) _v1 (eo::zmod _v1 _v0)))))
  (($run_evaluate (to_real x)) (eo::to_q ($run_evaluate x)))
  (($run_evaluate (to_int x)) (eo::to_z ($run_evaluate x)))
  (($run_evaluate (is_int x)) (eo::define ((_v0 ($run_evaluate x))) (eo::eq (eo::to_q (eo::to_z _v0)) (eo::to_q _v0))))
  (($run_evaluate (abs x)) (eo::define ((_v0 ($run_evaluate x))) (eo::ite (eo::is_neg _v0) (eo::neg _v0) _v0)))
  (($run_evaluate (int.log2 i1)) (eo::define ((_v0 ($run_evaluate i1))) (eo::ite (eo::is_neg (eo::neg _v0)) ($arith_eval_int_log_2_rec _v0) 0)))
  (($run_evaluate (int.pow2 i1)) (eo::define ((_v0 ($run_evaluate i1))) (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) 0 ($arith_eval_int_pow_2_rec _v0)) (int.pow2 _v0))))
  (($run_evaluate (int.ispow2 i1)) (eo::define ((_v0 ($run_evaluate i1))) (eo::define ((_v1 (eo::ite (eo::is_neg (eo::neg _v0)) ($arith_eval_int_log_2_rec _v0) 0))) (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) false (eo::eq _v0 (eo::ite (eo::is_z _v1) (eo::ite (eo::is_neg _v1) 0 ($arith_eval_int_pow_2_rec _v1)) (int.pow2 _v1)))) (int.ispow2 _v0)))))
  (($run_evaluate (_ (str.++ sx) sys)) (eo::concat ($run_evaluate sx) ($run_evaluate sys)))
  (($run_evaluate (str.len sx)) (eo::len ($run_evaluate sx)))
  (($run_evaluate (_ (_ (str.substr sx) n) m)) (eo::define ((_v0 ($run_evaluate n))) (eo::extract ($run_evaluate sx) _v0 (eo::add (eo::add _v0 ($run_evaluate m)) -1))))
  (($run_evaluate (_ (str.at sx) n)) (eo::define ((_v0 ($run_evaluate n))) (eo::extract ($run_evaluate sx) _v0 _v0)))
  (($run_evaluate (_ (str.contains sx) sy)) (eo::not (eo::is_neg (eo::find ($run_evaluate sx) ($run_evaluate sy)))))
  (($run_evaluate (_ (_ (str.replace sx) sy) sz)) (eo::define ((_v0 ($run_evaluate sx))) (eo::define ((_v1 ($run_evaluate sy))) (eo::define ((_v2 (eo::find (eo::to_str _v0) (eo::to_str _v1)))) (eo::ite (eo::is_neg _v2) _v0 (eo::concat (eo::concat (eo::extract _v0 0 (eo::add _v2 -1)) ($run_evaluate sz)) (eo::extract _v0 (eo::add _v2 (eo::len _v1)) (eo::len _v0))))))))
  (($run_evaluate (_ (_ (str.replace_all ssx) ssy) ssz)) (eo::ite (eo::and (eo::and (eo::is_str ssx) (eo::is_str ssy)) (eo::is_str ssz)) (eo::ite (eo::eq ssy "") ssx ($str_eval_replace_all_rec ssx ssy ssz (eo::find ssx ssy) (eo::len ssy))) (_ (_ (str.replace_all ssx) ssy) ssz)))
  (($run_evaluate (_ (str.prefixof sx) sy)) (eo::define ((_v0 ($run_evaluate sx))) (eo::eq _v0 (eo::extract ($run_evaluate sy) 0 (eo::add (eo::len _v0) -1)))))
  (($run_evaluate (_ (str.suffixof sx) sy)) (eo::define ((_v0 ($run_evaluate sy))) (eo::define ((_v1 (eo::len _v0))) (eo::define ((_v2 ($run_evaluate sx))) (eo::eq _v2 (eo::extract _v0 (eo::add _v1 (eo::neg (eo::len _v2))) (eo::add _v1 -1)))))))
  (($run_evaluate (_ (_ (str.indexof sx) sy) n)) (eo::define ((_v0 ($run_evaluate sx))) (eo::define ((_v1 (eo::len _v0))) (eo::define ((_v2 (eo::find (eo::to_str (eo::extract _v0 n _v1)) (eo::to_str ($run_evaluate sy))))) (eo::define ((_v3 ($run_evaluate n))) (eo::ite (eo::is_neg _v3) -1 (eo::ite (eo::gt _v3 _v1) -1 (eo::ite (eo::is_neg _v2) _v2 (eo::add n _v2)))))))))
  (($run_evaluate (str.to_code ssx)) (eo::define ((_v0 ($run_evaluate ssx))) (eo::define ((_v1 (eo::len _v0))) (eo::ite (eo::eq _v1 1) (eo::to_z _v0) (eo::ite (eo::is_z _v1) -1 (str.to_code _v0))))))
  (($run_evaluate (str.from_code n)) (eo::define ((_v0 ($run_evaluate n))) (eo::ite (eo::ite (eo::is_z _v0) (eo::ite (eo::ite (eo::eq 196608 _v0) true (eo::gt 196608 _v0)) (eo::not (eo::is_neg _v0)) false) false) (eo::to_str n) "")))
  (($run_evaluate (str.to_int ssx)) (eo::define ((_v0 ($run_evaluate ssx))) (eo::ite (eo::is_str _v0) (eo::ite (eo::eq _v0 "") -1 ($str_to_int_eval_rec (eo::list_rev str.++ ($str_flatten ($str_nary_intro _v0))) 1 0)) (str.to_int _v0))))
  (($run_evaluate (str.from_int n)) (eo::define ((_v0 ($run_evaluate n))) (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) "" ($str_from_int_eval_rec _v0 "")) (str.from_int _v0))))
  (($run_evaluate (_ (str.<= ssx) ssy)) (eo::define ((_v0 ($run_evaluate ssy))) (eo::define ((_v1 ($run_evaluate ssx))) (eo::ite (eo::and (eo::is_str _v1) (eo::is_str _v0)) ($str_leq_eval_rec ($str_flatten ($str_nary_intro _v1)) ($str_flatten ($str_nary_intro _v0))) (_ (str.<= _v1) _v0)))))
  (($run_evaluate (str.to_lower ssx)) (eo::define ((_v0 ($run_evaluate ssx))) (eo::ite (eo::is_str _v0) ($str_case_conv_rec ($str_flatten ($str_nary_intro _v0)) true) (str.to_lower _v0))))
  (($run_evaluate (str.to_upper ssx)) (eo::define ((_v0 ($run_evaluate ssx))) (eo::ite (eo::is_str _v0) ($str_case_conv_rec ($str_flatten ($str_nary_intro _v0)) false) (str.to_upper _v0))))
  (($run_evaluate (str.rev sx)) (eo::define ((_v0 ($run_evaluate sx))) (eo::ite (eo::is_str _v0) ($str_nary_elim ($str_collect (eo::list_rev str.++ ($str_flatten ($str_nary_intro _v0))))) (str.rev _v0))))
  (($run_evaluate (_ (_ (str.update sx) n) sy)) (eo::define ((_v0 ($run_evaluate sx))) (eo::define ((_v1 (eo::len _v0))) (eo::define ((_v2 ($run_evaluate sy))) (eo::define ((_v3 ($run_evaluate n))) (eo::ite (eo::or (eo::gt 0 _v3) (eo::gt _v3 _v1)) _v0 (eo::concat (eo::concat (eo::extract _v0 0 (eo::add _v3 -1)) (eo::extract _v2 0 (eo::add (eo::add (eo::neg _v3) _v1) -1))) (eo::extract _v0 (eo::add _v3 (eo::len _v2)) _v1))))))))
  (($run_evaluate (bvnot xb)) (eo::not ($run_evaluate xb)))
  (($run_evaluate (bvneg xb)) (eo::neg ($run_evaluate xb)))
  (($run_evaluate (_ (bvadd xb) ybs)) (eo::add ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvmul xb) ybs)) (eo::mul ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvudiv xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($bv_bitwidth (eo::typeof xb)))) (eo::ite (eo::eq (eo::to_z _v0) 0) (eo::to_bin _v1 (eo::add (eo::ite (eo::is_z _v1) (eo::ite (eo::is_neg _v1) 0 ($arith_eval_int_pow_2_rec _v1)) (int.pow2 _v1)) -1)) (eo::zdiv ($run_evaluate xb) _v0)))))
  (($run_evaluate (_ (bvurem xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($run_evaluate xb))) (eo::ite (eo::eq (eo::to_z _v0) 0) _v1 (eo::zmod _v1 _v0)))))
  (($run_evaluate (_ (bvand xb) ybs)) (eo::and ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvor xb) ybs)) (eo::or ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvxor xb) ybs)) (eo::xor ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (concat xb) zbs)) (eo::concat ($run_evaluate xb) ($run_evaluate zbs)))
  (($run_evaluate (_ (bvsub xb) yb)) (eo::add ($run_evaluate xb) (eo::neg ($run_evaluate yb))))
  (($run_evaluate (_ (_ (extract m) n) xb)) (eo::extract ($run_evaluate xb) n m))
  (($run_evaluate (_ (bvult xb) yb)) ($run_evaluate (_ (bvugt yb) xb)))
  (($run_evaluate (_ (bvule xb) yb)) ($run_evaluate (_ (bvuge yb) xb)))
  (($run_evaluate (_ (bvugt xb) yb)) (eo::gt (eo::to_z ($run_evaluate xb)) (eo::to_z ($run_evaluate yb))))
  (($run_evaluate (_ (bvuge xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($run_evaluate xb))) (eo::or (eo::gt _v1 _v0) (eo::eq _v1 _v0)))))
  (($run_evaluate (_ (bvslt xb) yb)) ($run_evaluate (_ (bvsgt yb) xb)))
  (($run_evaluate (_ (bvsle xb) yb)) ($run_evaluate (_ (bvsge yb) xb)))
  (($run_evaluate (_ (bvsgt xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($bv_bitwidth (eo::typeof _v0)))) (eo::define ((_v2 (eo::to_z (eo::extract _v0 0 (eo::add _v1 -2))))) (eo::define ((_v3 (eo::add _v1 -1))) (eo::define ((_v4 ($run_evaluate xb))) (eo::define ((_v5 ($bv_bitwidth (eo::typeof _v4)))) (eo::define ((_v6 (eo::to_z (eo::extract _v4 0 (eo::add _v5 -2))))) (eo::define ((_v7 (eo::add _v5 -1))) (eo::gt (eo::ite (eo::eq (eo::extract _v4 _v7 _v7) #b1) (eo::add (eo::neg (eo::ite (eo::is_z _v7) (eo::ite (eo::is_neg _v7) 0 ($arith_eval_int_pow_2_rec _v7)) (int.pow2 _v7))) _v6) _v6) (eo::ite (eo::eq (eo::extract _v0 _v3 _v3) #b1) (eo::add (eo::neg (eo::ite (eo::is_z _v3) (eo::ite (eo::is_neg _v3) 0 ($arith_eval_int_pow_2_rec _v3)) (int.pow2 _v3))) _v2) _v2)))))))))))
  (($run_evaluate (_ (bvsge xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($bv_bitwidth (eo::typeof _v0)))) (eo::define ((_v2 (eo::to_z (eo::extract _v0 0 (eo::add _v1 -2))))) (eo::define ((_v3 (eo::add _v1 -1))) (eo::define ((_v4 (eo::ite (eo::eq (eo::extract _v0 _v3 _v3) #b1) (eo::add (eo::neg (eo::ite (eo::is_z _v3) (eo::ite (eo::is_neg _v3) 0 ($arith_eval_int_pow_2_rec _v3)) (int.pow2 _v3))) _v2) _v2))) (eo::define ((_v5 ($run_evaluate xb))) (eo::define ((_v6 ($bv_bitwidth (eo::typeof _v5)))) (eo::define ((_v7 (eo::to_z (eo::extract _v5 0 (eo::add _v6 -2))))) (eo::define ((_v8 (eo::add _v6 -1))) (eo::define ((_v9 (eo::ite (eo::eq (eo::extract _v5 _v8 _v8) #b1) (eo::add (eo::neg (eo::ite (eo::is_z _v8) (eo::ite (eo::is_neg _v8) 0 ($arith_eval_int_pow_2_rec _v8)) (int.pow2 _v8))) _v7) _v7))) (eo::or (eo::gt _v9 _v4) (eo::eq _v9 _v4)))))))))))))
  (($run_evaluate (_ (bvshl xb) yb)) (eo::define ((_v0 (eo::to_z ($run_evaluate yb)))) (eo::define ((_v1 ($bv_bitwidth (eo::typeof xb)))) (eo::ite (eo::gt _v0 _v1) (eo::to_bin _v1 0) (eo::to_bin _v1 (eo::mul (eo::to_z ($run_evaluate xb)) (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) 0 ($arith_eval_int_pow_2_rec _v0)) (int.pow2 _v0))))))))
  (($run_evaluate (_ (bvlshr xb) yb)) (eo::define ((_v0 (eo::to_z ($run_evaluate yb)))) (eo::define ((_v1 ($bv_bitwidth (eo::typeof xb)))) (eo::ite (eo::gt _v0 _v1) (eo::to_bin _v1 0) (eo::to_bin _v1 (eo::zdiv (eo::to_z ($run_evaluate xb)) (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) 0 ($arith_eval_int_pow_2_rec _v0)) (int.pow2 _v0))))))))
  (($run_evaluate (_ (bvashr xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($run_evaluate xb))) (eo::define ((_v2 (eo::add ($bv_bitwidth (eo::typeof _v1)) -1))) (eo::ite (eo::eq (eo::extract _v1 _v2 _v2) #b0) ($run_evaluate (_ (bvlshr _v1) _v0)) ($run_evaluate (bvnot (_ (bvlshr (bvnot _v1)) _v0))))))))
  (($run_evaluate (_ (repeat n) xb)) (eo::define ((_v0 ($run_evaluate xb))) (eo::define ((_v1 ($run_evaluate n))) ($run_evaluate (eo::ite (eo::and (eo::is_z _v1) (eo::not (eo::is_neg _v1))) ($bv_unfold_repeat_rec _v1 _v0) (_ (repeat _v1) _v0))))))
  (($run_evaluate (_ (sign_extend n) xb)) (eo::define ((_v0 ($run_evaluate xb))) (eo::define ((_v1 (eo::add ($bv_bitwidth (eo::typeof _v0)) -1))) (eo::define ((_v2 (eo::extract _v0 _v1 _v1))) (eo::define ((_v3 ($run_evaluate n))) (eo::concat ($run_evaluate (eo::ite (eo::and (eo::is_z _v3) (eo::not (eo::is_neg _v3))) ($bv_unfold_repeat_rec _v3 _v2) (_ (repeat _v3) _v2))) _v0))))))
  (($run_evaluate (_ (zero_extend n) xb)) (eo::define ((_v0 ($run_evaluate n))) (eo::concat ($run_evaluate (eo::ite (eo::and (eo::is_z _v0) (eo::not (eo::is_neg _v0))) ($bv_unfold_repeat_rec _v0 #b0) (_ (repeat _v0) #b0))) ($run_evaluate xb))))
  (($run_evaluate (_ (@bv n) m)) (eo::to_bin ($run_evaluate m) ($run_evaluate n)))
  (($run_evaluate (@bvsize xb)) ($bv_bitwidth (eo::typeof xb)))
  (($run_evaluate (_ (int_to_bv n) m)) (eo::to_bin ($run_evaluate n) ($run_evaluate m)))
  (($run_evaluate (ubv_to_int xb)) (eo::to_z ($run_evaluate xb)))
  (($run_evaluate (sbv_to_int xb)) (eo::define ((_v0 ($bv_bitwidth (eo::typeof xb)))) (eo::define ((_v1 (eo::to_z ($run_evaluate xb)))) (eo::define ((_v2 (eo::add _v0 -1))) (eo::ite (eo::eq (eo::extract xb _v2 _v2) #b0) _v1 (eo::add _v1 (eo::neg (eo::ite (eo::is_z _v0) (eo::ite (eo::is_neg _v0) 0 ($arith_eval_int_pow_2_rec _v0)) (int.pow2 _v0)))))))))
  (($run_evaluate z) z)
  )
)
(program $eo_prog_evaluate (($eo_arg_0 Type) (U Type) (t U))
  :signature ($eo_arg_0) Bool
  (
  (($eo_prog_evaluate t) (_ (= t) ($run_evaluate t)))
  )
)
(program $eo_typeof_apply ((T Type) (U Type) (V Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_apply (-> T U) V) (eo::requires T V U))
  )
)
(program $eo_typeof_@@pair ((U Type) (T Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_@@pair U T) (_ (@@Pair U) T))
  )
)
(program $eo_typeof_ite ((A Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_ite Bool A) (-> A A))
  )
)
(program $eo_typeof_= ((A Type))
  :signature (Type) Type
  (
  (($eo_typeof_= A) (-> A Bool))
  )
)
(program $eo_typeof_+ ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_+ T U) ($arith_typeunion T U))
  )
)
(program $eo_typeof_- ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_- T U) ($arith_typeunion T U))
  )
)
(program $eo_typeof_* ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_* T U) ($arith_typeunion T U))
  )
)
(program $eo_typeof_< ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_< T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Bool)))
  )
)
(program $eo_typeof_<= ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_<= T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Bool)))
  )
)
(program $eo_typeof_> ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_> T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Bool)))
  )
)
(program $eo_typeof_>= ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_>= T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Bool)))
  )
)
(program $eo_typeof_to_real ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_to_real T) (eo::requires ($is_arith_type T) true Real))
  )
)
(program $eo_typeof_to_int ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_to_int T) (eo::requires ($is_arith_type T) true Int))
  )
)
(program $eo_typeof_is_int ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_is_int T) (eo::requires ($is_arith_type T) true Bool))
  )
)
(program $eo_typeof_abs ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_abs T) (eo::requires ($is_arith_type T) true T))
  )
)
(program $eo_typeof_$eoo_-.2 ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_$eoo_-.2 T) (eo::requires ($is_arith_type T) true T))
  )
)
(program $eo_typeof_@bvsize ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_@bvsize (BitVec m)) Int)
  )
)
(program $eo_typeof_concat ((n Int) (m Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_concat (BitVec n) (BitVec m)) (BitVec (eo::add n m)))
  )
)
(program $eo_typeof_extract ((n Int) (h Int) (l Int))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_extract h l (BitVec n)) (BitVec (eo::requires (eo::gt (eo::add l 1) 0) true (eo::requires (eo::gt n h) true (eo::add (eo::add h (eo::neg l)) 1)))))
  )
)
(program $eo_typeof_repeat ((i Int) (n Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_repeat i (BitVec n)) (BitVec (eo::mul i n)))
  )
)
(program $eo_typeof_bvnot ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvnot (BitVec m)) (BitVec m))
  )
)
(program $eo_typeof_bvand ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvand (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvor ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvor (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvxor ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvxor (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvneg ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvneg (BitVec m)) (BitVec m))
  )
)
(program $eo_typeof_bvadd ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvadd (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvmul ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvmul (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvudiv ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvudiv (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvurem ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvurem (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvsub ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsub (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvult ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvult (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvule ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvule (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvugt ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvugt (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvuge ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvuge (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvslt ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvslt (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvsle ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsle (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvsgt ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsgt (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvsge ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsge (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvshl ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvshl (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvlshr ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvlshr (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvashr ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvashr (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_zero_extend ((m Int) (i Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_zero_extend i (BitVec m)) (BitVec (eo::add m i)))
  )
)
(program $eo_typeof_sign_extend ((m Int) (i Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_sign_extend i (BitVec m)) (BitVec (eo::add m i)))
  )
)
(program $eo_typeof_@bv ((value Int) (w Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_@bv value w) (BitVec w))
  )
)
(program $eo_typeof_seq.empty ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_seq.empty (Seq T)) (Seq T))
  )
)
(program $eo_typeof_str.len ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.len (Seq T)) Int)
  )
)
(program $eo_typeof_str.++ ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.++ (Seq T)) (eo::define ((_v0 (Seq T))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_str.substr ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.substr (Seq T)) (-> Int (-> Int (Seq T))))
  )
)
(program $eo_typeof_str.contains ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.contains (Seq T)) (-> (Seq T) Bool))
  )
)
(program $eo_typeof_str.replace ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.replace (Seq T)) (eo::define ((_v0 (Seq T))) (-> _v0 (-> _v0 _v0))))
  )
)
(program $eo_typeof_str.indexof ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.indexof (Seq T)) (-> (Seq T) (-> Int Int)))
  )
)
(program $eo_typeof_str.at ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.at (Seq T)) (-> Int (Seq T)))
  )
)
(program $eo_typeof_str.prefixof ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.prefixof (Seq T)) (-> (Seq T) Bool))
  )
)
(program $eo_typeof_str.suffixof ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.suffixof (Seq T)) (-> (Seq T) Bool))
  )
)
(program $eo_typeof_str.rev ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.rev (Seq T)) (Seq T))
  )
)
(program $eo_typeof_str.update ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.update (Seq T)) (eo::define ((_v0 (Seq T))) (-> Int (-> _v0 _v0))))
  )
)
(program $eo_typeof_str.replace_all ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.replace_all (Seq T)) (eo::define ((_v0 (Seq T))) (-> _v0 (-> _v0 _v0))))
  )
)
(program $eo_typeof_/ ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_/ T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Real)))
  )
)
(program $eo_typeof_/_total ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_/_total T U) (eo::requires ($is_arith_type T) true (eo::requires ($is_arith_type U) true Real)))
  )
)
(program $eo_typeof_int_to_bv ((w Int))
  :signature (Type) Type
  (
  (($eo_typeof_int_to_bv w) (-> Int (BitVec w)))
  )
)
(program $eo_typeof_ubv_to_int ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_ubv_to_int (BitVec m)) Int)
  )
)
(program $eo_typeof_sbv_to_int ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_sbv_to_int (BitVec m)) Int)
  )
)
(program $eo_typeof_fun_type ()
  :signature (Type Type) Type
  (
  (($eo_typeof_fun_type Type Type) Type)
  )
)
(program $eo_typeof_main
  (($eo_T Type) ($eo_U Type) ($eo_V Type) ($eo_W Type) 
   ($eo_f (-> $eo_U $eo_V $eo_T)) ($eo_x $eo_U) ($eo_t $eo_T)
   ($eo_W1 Type) ($eo_x1 $eo_W1)
   ($eo_W2 Type) ($eo_x2 $eo_W2)
   ($eo_W3 Type) ($eo_x3 $eo_W3)
   ($eo_W4 Type) ($eo_x4 $eo_W4)) 
  :signature ($eo_T) Type
  (
  (($eo_typeof_main Type)                   Type)
  (($eo_typeof_main (-> $eo_T $eo_U))
    
    ($eo_typeof_fun_type ($eo_typeof $eo_T) ($eo_typeof $eo_U)))
  (($eo_typeof_main Bool)                   Type)
  (($eo_typeof_main true)                   Bool)
  (($eo_typeof_main false)                  Bool)
  
  (($eo_typeof_main $eo_List)               Type)
  (($eo_typeof_main $eo_List_nil)           $eo_List)
  (($eo_typeof_main ($eo_List_cons $eo_x1)) (-> $eo_List $eo_List))
  
  (($eo_typeof_main Int) Type)
  
  (($eo_typeof_main Real) Type)
  
  (($eo_typeof_main BitVec) (-> Int Type))
  
  (($eo_typeof_main Char) Type)
  
  (($eo_typeof_main Seq) (-> Type Type))
  
  (($eo_typeof_main @@Pair) (-> Type (-> Type Type)))
  
  (($eo_typeof_main (_ (@@pair $eo_x1) $eo_x2)) ($eo_typeof_@@pair ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (_ (ite $eo_x1) $eo_x2)) ($eo_typeof_ite ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main not) (-> Bool Bool))
  
  (($eo_typeof_main or) (-> Bool (-> Bool Bool)))
  
  (($eo_typeof_main and) (-> Bool (-> Bool Bool)))
  
  (($eo_typeof_main =>) (-> Bool (-> Bool Bool)))
  
  (($eo_typeof_main xor) (-> Bool (-> Bool Bool)))
  
  (($eo_typeof_main (= $eo_x1)) ($eo_typeof_= ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (_ (+ $eo_x1) $eo_x2)) ($eo_typeof_+ ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (_ (- $eo_x1) $eo_x2)) ($eo_typeof_- ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (_ (* $eo_x1) $eo_x2)) ($eo_typeof_* ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (_ (< $eo_x1) $eo_x2)) ($eo_typeof_< ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (_ (<= $eo_x1) $eo_x2)) ($eo_typeof_<= ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (_ (> $eo_x1) $eo_x2)) ($eo_typeof_> ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (_ (>= $eo_x1) $eo_x2)) ($eo_typeof_>= ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (to_real $eo_x1)) ($eo_typeof_to_real ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (to_int $eo_x1)) ($eo_typeof_to_int ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (is_int $eo_x1)) ($eo_typeof_is_int ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (abs $eo_x1)) ($eo_typeof_abs ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main ($eoo_-.2 $eo_x1)) ($eo_typeof_$eoo_-.2 ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main div) (-> Int (-> Int Int)))
  
  (($eo_typeof_main mod) (-> Int (-> Int Int)))
  
  (($eo_typeof_main int.pow2) (-> Int Int))
  
  (($eo_typeof_main int.log2) (-> Int Int))
  
  (($eo_typeof_main int.ispow2) (-> Int Bool))
  
  (($eo_typeof_main div_total) (-> Int (-> Int Int)))
  
  (($eo_typeof_main mod_total) (-> Int (-> Int Int)))
  
  (($eo_typeof_main (@bvsize $eo_x1)) ($eo_typeof_@bvsize ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (_ (concat $eo_x1) $eo_x2)) ($eo_typeof_concat ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (_ (_ (extract $eo_x1) $eo_x2) $eo_x3)) ($eo_typeof_extract $eo_x1 $eo_x2 ($eo_typeof $eo_x3)))
  
  (($eo_typeof_main (_ (repeat $eo_x1) $eo_x2)) ($eo_typeof_repeat $eo_x1 ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (bvnot $eo_x1)) ($eo_typeof_bvnot ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvand $eo_x1)) ($eo_typeof_bvand ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvor $eo_x1)) ($eo_typeof_bvor ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvxor $eo_x1)) ($eo_typeof_bvxor ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvneg $eo_x1)) ($eo_typeof_bvneg ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvadd $eo_x1)) ($eo_typeof_bvadd ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvmul $eo_x1)) ($eo_typeof_bvmul ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvudiv $eo_x1)) ($eo_typeof_bvudiv ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvurem $eo_x1)) ($eo_typeof_bvurem ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvsub $eo_x1)) ($eo_typeof_bvsub ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvult $eo_x1)) ($eo_typeof_bvult ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvule $eo_x1)) ($eo_typeof_bvule ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvugt $eo_x1)) ($eo_typeof_bvugt ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvuge $eo_x1)) ($eo_typeof_bvuge ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvslt $eo_x1)) ($eo_typeof_bvslt ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvsle $eo_x1)) ($eo_typeof_bvsle ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvsgt $eo_x1)) ($eo_typeof_bvsgt ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvsge $eo_x1)) ($eo_typeof_bvsge ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvshl $eo_x1)) ($eo_typeof_bvshl ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvlshr $eo_x1)) ($eo_typeof_bvlshr ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (bvashr $eo_x1)) ($eo_typeof_bvashr ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (_ (zero_extend $eo_x1) $eo_x2)) ($eo_typeof_zero_extend $eo_x1 ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (_ (sign_extend $eo_x1) $eo_x2)) ($eo_typeof_sign_extend $eo_x1 ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (_ (@bv $eo_x1) $eo_x2)) ($eo_typeof_@bv $eo_x1 $eo_x2))
  
  (($eo_typeof_main (as seq.empty $eo_x1)) ($eo_typeof_seq.empty $eo_x1))
  
  (($eo_typeof_main (str.len $eo_x1)) ($eo_typeof_str.len ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (str.++ $eo_x1)) ($eo_typeof_str.++ ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (str.substr $eo_x1)) ($eo_typeof_str.substr ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (str.contains $eo_x1)) ($eo_typeof_str.contains ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (str.replace $eo_x1)) ($eo_typeof_str.replace ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (str.indexof $eo_x1)) ($eo_typeof_str.indexof ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (str.at $eo_x1)) ($eo_typeof_str.at ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (str.prefixof $eo_x1)) ($eo_typeof_str.prefixof ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (str.suffixof $eo_x1)) ($eo_typeof_str.suffixof ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (str.rev $eo_x1)) ($eo_typeof_str.rev ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (str.update $eo_x1)) ($eo_typeof_str.update ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main str.to_lower) (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
  
  (($eo_typeof_main str.to_upper) (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
  
  (($eo_typeof_main str.to_code) (-> (Seq Char) Int))
  
  (($eo_typeof_main str.from_code) (-> Int (Seq Char)))
  
  (($eo_typeof_main str.to_int) (-> (Seq Char) Int))
  
  (($eo_typeof_main str.from_int) (-> Int (Seq Char)))
  
  (($eo_typeof_main str.<=) (eo::define ((_v0 (Seq Char))) (-> _v0 (-> _v0 Bool))))
  
  (($eo_typeof_main (str.replace_all $eo_x1)) ($eo_typeof_str.replace_all ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (_ (/ $eo_x1) $eo_x2)) ($eo_typeof_/ ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (_ (/_total $eo_x1) $eo_x2)) ($eo_typeof_/_total ($eo_typeof $eo_x1) ($eo_typeof $eo_x2)))
  
  (($eo_typeof_main (int_to_bv $eo_x1)) ($eo_typeof_int_to_bv $eo_x1))
  
  (($eo_typeof_main (ubv_to_int $eo_x1)) ($eo_typeof_ubv_to_int ($eo_typeof $eo_x1)))
  
  (($eo_typeof_main (sbv_to_int $eo_x1)) ($eo_typeof_sbv_to_int ($eo_typeof $eo_x1)))

  (($eo_typeof_main ($eo_f $eo_x))          ($eo_typeof_apply ($eo_typeof $eo_f) ($eo_typeof $eo_x)))
  )
)
(program $eo_lit_type_Numeral ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_Numeral t) Int)
  )
)
(program $eo_lit_type_Rational ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_Rational t) Real)
  )
)
(program $eo_lit_type_Binary ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_Binary t) (BitVec (eo::len t)))
  )
)
(program $eo_lit_type_String ((T Type) (t T))
  :signature (T) Type
  (
  (($eo_lit_type_String t) (Seq Char))
  )
)
(program $eo_dt_constructors
  ((T Type))
  :signature (Type) $eo_List
  (

  )
)
(program $eo_dt_selectors ((T Type) (t T))
  :signature (T) $eo_List
  (

  )
)
(program $eo_nil_bvand (($eoT_3 Type) (m Int))
  :signature ((eo::quote $eoT_3)) $eoT_3
  (
  (($eo_nil_bvand (BitVec m)) (eo::not (eo::to_bin m 0)))
  )
)
(program $eo_nil_bvor (($eoT_4 Type) (m Int))
  :signature ((eo::quote $eoT_4)) $eoT_4
  (
  (($eo_nil_bvor (BitVec m)) (eo::to_bin m 0))
  )
)
(program $eo_nil_bvxor (($eoT_5 Type) (m Int))
  :signature ((eo::quote $eoT_5)) $eoT_5
  (
  (($eo_nil_bvxor (BitVec m)) (eo::to_bin m 0))
  )
)
(program $eo_nil_bvadd (($eoT_6 Type) (m Int))
  :signature ((eo::quote $eoT_6)) $eoT_6
  (
  (($eo_nil_bvadd (BitVec m)) (eo::to_bin m 0))
  )
)
(program $eo_nil_bvmul (($eoT_7 Type) (m Int))
  :signature ((eo::quote $eoT_7)) $eoT_7
  (
  (($eo_nil_bvmul (BitVec m)) (eo::to_bin m 1))
  )
)
(program $eo_nil_str.++ (($eoT_8 Type) (T Type))
  :signature ((eo::quote $eoT_8)) $eoT_8
  (
  (($eo_nil_str.++ (Seq T)) ($seq_empty (Seq T)))
  )
)
(program $eo_nil
  ((T Type) (U Type) (V Type) (W Type) (f (-> T U V)))
  :signature ((-> T U V) (eo::quote W)) W
  (
  (($eo_nil or T) false)
  (($eo_nil and T) true)
  (($eo_nil + T) 0)
  (($eo_nil * T) 1)
  (($eo_nil concat T) (eo::to_bin 0 0))
  (($eo_nil bvand T) ($eo_nil_bvand T))
  (($eo_nil bvor T) ($eo_nil_bvor T))
  (($eo_nil bvxor T) ($eo_nil_bvxor T))
  (($eo_nil bvadd T) ($eo_nil_bvadd T))
  (($eo_nil bvmul T) ($eo_nil_bvmul T))
  (($eo_nil str.++ T) ($eo_nil_str.++ T))

  
  (($eo_nil $eo_List_cons $eo_List) $eo_List_nil)
  )
)
(program $eo_model_unsat () :signature (Bool) Bool)
; This file defines SMT-LIB model semantics in Eunoia.
; The programs in this file operate on datatypes that correspond to
; a deep embedding of SMT-LIB values.
; In particular, we use the following types:
; 1. $smt_Value, the type of SMT-LIB values.
; 2. Further types defining specific SMT-LIB values, e.g. $smt_Map.

;;;;;; SMT values

; An SMT-LIB value.
; This will be replaced by the datatype vsm.Value in the final encoding.
(declare-const $smt_Value Type)

; Assumes that veq is defined to be equality over $smt_Value
(define $smt_builtin_veq ((x1 $smt_Value) (x2 $smt_Value)) ($smt_apply_2 "veq" x1 x2))

; The type used to define values for functions, arrays and sets in SMT-LIB.
(declare-const $smt_Map Type)

; The type used to define values for sequences in SMT-LIB.
(declare-const $smt_Seq Type)


;;; SMT value datatype constructors

; A value denoting a map.
(declare-parameterized-const $smd_vsm.Map ((m $smt_Map :opaque)) $smt_Value)
(define $vsm_map ((m $smt_Map)) ($smd_vsm.Map m))

; A value denoting a sequence.
(declare-parameterized-const $smd_vsm.Seq ((s $smt_Seq :opaque)) $smt_Value)
(define $vsm_seq ((s $smt_Seq)) ($smd_vsm.Seq s))

; A value denoting a regular language.
(declare-parameterized-const $smd_vsm.RegLan ((r $smt_builtin_RegLan :opaque)) $smt_Value)
(define $vsm_re ((r $smt_builtin_RegLan)) ($smd_vsm.RegLan r))

; A value represented by an SMT-LIB term. This is used for types
; where terms are used to denote the values of that type, e.g.
; SMT-LIB numerals for Int.
(declare-parameterized-const $smd_vsm.Term
  ((t $eo_Term :opaque))
  $smt_Value)
(define $vsm_term ((t $eo_Term)) ($smd_vsm.Term t))

; Apply values (for Herbrand interpretations).
(declare-parameterized-const $smd_vsm.Apply
  ((f $smt_Value :opaque) (a $smt_Value :opaque))
  $smt_Value)
(define $vsm_apply ((f $smt_Value) (a $smt_Value))
  ($smd_vsm.Apply f a))

; Denotes a failure case for values.
(declare-const $smd_vsm.NotValue $smt_Value)
(define $vsm_not_value () $smd_vsm.NotValue)

;;; SMT map value datatype constructors

; Constructs a map value where i is mapped to e.
(declare-parameterized-const $smd_msm.cons
  ((i $smt_Value :opaque) (e $smt_Value :opaque) (m $smt_Map :opaque))
  $smt_Map)
(define $msm_cons ((i $smt_Value) (e $smt_Value) (m $smt_Map))
  ($smd_msm.cons i e m))

; Constructs a map value where all indices are mapped to e.
(declare-parameterized-const $smd_msm.default
  ((e $smt_Value :opaque))
  $smt_Map)
(define $msm_default ((e $smt_Value)) ($smd_msm.default e))

;;; SMT sequence value datatype constructors

(declare-parameterized-const $smd_ssm.cons
  ((i $smt_Value :opaque) (s $smt_Seq :opaque))
  $smt_Seq)
(define $ssm_cons ((i $smt_Value) (s $smt_Seq)) ($smd_ssm.cons i s))

(declare-parameterized-const $smd_ssm.empty () $smt_Seq)
(define $ssm_empty () $smd_ssm.empty)

;;; Generic utilities

(define $vsm_true () ($vsm_term true))
(define $vsm_false () ($vsm_term false))

; define: $smtx_value_hash
; note: this is an arbitrary hash for SMT values, defined axiomatically.
(program $smtx_value_hash () :signature ($smt_Value) $smt_builtin_Int)
(program $smtx_reverse_value_hash () :signature ($smt_builtin_Int) $smt_Value)

; The SMT-LIB comparison of two SMT-LIB values.
(define $smtx_value_cmp ((a $smt_Value) (b $smt_Value))
  ($smt_builtin_z_<= ($smtx_value_hash a) ($smtx_value_hash b)))

; returns one of (v1,v2), preferring values to non-values
(program $smtx_value_either ((v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_value_either v1 $vsm_not_value) v1)
  (($smtx_value_either $vsm_not_value v2) v2)
  (($smtx_value_either v1 v2)             v1)
  )
)

;;; Map utilities

; Get the default for the map
(program $smtx_msm_get_default
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Map) $smt_Value
  (
  (($smtx_msm_get_default ($msm_cons j e m))  ($smtx_msm_get_default m))
  (($smtx_msm_get_default ($msm_default e))   e)
  )
)

; This program looks up the value of a term in a map.
; This is used for function evaluation.
(program $smtx_msm_lookup
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Map $smt_Value) $smt_Value
  (
  (($smtx_msm_lookup ($msm_cons i e m) i)  e)
  (($smtx_msm_lookup ($msm_cons j e m) i)  ($smtx_msm_lookup m i))
  (($smtx_msm_lookup ($msm_default e) i)   e)
  )
)

; updates the map with a new entry, maintaining ordered-ness
(program $smtx_msm_update
  ((i $smt_Value) (j $smt_Value) (e1 $smt_Value) (e2 $smt_Value) (m $smt_Map))
  :signature ($smt_Map $smt_Value $smt_Value) $smt_Map
  (
  ; we overwrite if same index
  (($smtx_msm_update ($msm_cons i e1 m) i e2) ($msm_cons i e2 m))
  ; otherwise, we check the hash to retain sortedness
  (($smtx_msm_update ($msm_cons j e1 m) i e2) ($smt_builtin_ite ($smtx_value_cmp j i)
                                                ($msm_cons i e2 ($msm_cons j e1 m))
                                                ($msm_cons j e1 ($smtx_msm_update m i e2))))
  ; we are redundant wrt the default value
  (($smtx_msm_update ($msm_default e1) i e1)  ($msm_default e1))
  ; ensures totality, we are a non-redundant update of the default map
  (($smtx_msm_update m i e2)                  ($msm_cons i e2 m))
  )
)

; Returns the first index of m1 that is mapped to a different value in m2.
; If no such value exists, return $vsm_not_value.
(program $smtx_msm_find_diff
  ((i $smt_Value) (e $smt_Value) (m1 $smt_Map) (m2 $smt_Map))
  :signature ($smt_Map $smt_Map) $smt_Value
  (
  (($smtx_msm_find_diff ($msm_default e) m2)    $vsm_not_value)
  (($smtx_msm_find_diff ($msm_cons i e m1) m2)
    ; Lookup the current index, if it different, return this index.
    ($smt_builtin_ite
      ($smt_builtin_veq ($smtx_msm_lookup m2 i) e)
      ($smtx_msm_find_diff m1 m2)
      i))
  )
)

;;; Map as sets

; A set is a mapping to Bool.
; The empty set maps all to false.
(define $msm_empty_set () ($msm_default $vsm_false))
; Inserting sets e to true.
(define $smtx_mss_mk_insert ((e $smt_Value) (m $smt_Map)) ($smtx_msm_update m e $vsm_true))
(define $smtx_mss_insert ((e $smt_Value) (m $smt_Map)) ($msm_cons e $vsm_true m))
(define $smtx_mss_member ((e $smt_Value) (m $smt_Map))
  ($smt_builtin_veq ($smtx_msm_lookup m e) $vsm_true))

; Helper for computing binary set operators.
(program $smtx_mss_op_internal
  ((m1 $smt_Map) (m2 $smt_Map) (acc $smt_Map) (e $smt_Value) (isInter $smt_builtin_Bool))
  :signature ($smt_builtin_Bool $smt_Map $smt_Map $smt_Map) $smt_Map
  (
  (($smtx_mss_op_internal isInter $msm_empty_set m2 acc) acc)
  (($smtx_mss_op_internal isInter ($smtx_mss_insert e m1) m2 acc)
    ($smtx_mss_op_internal isInter m1 m2
      ($smt_builtin_ite
        ($smt_builtin_iff ($smtx_mss_member e m2) isInter)
        ($smtx_mss_mk_insert e acc)
        acc)))
  )
)

;;; Utilities for Sequence values

(program $smtx_ssm_seq_nth ((v $smt_Value) (vs $smt_Seq) (n $smt_builtin_Int))
  :signature ($smt_Seq $smt_builtin_Int) $smt_Value
  (
  (($smtx_ssm_seq_nth $ssm_empty n)                           $vsm_not_value)
  (($smtx_ssm_seq_nth ($ssm_cons v vs) $smt_builtin_z_zero)   v)
  (($smtx_ssm_seq_nth ($ssm_cons v vs) n)
    ($smtx_ssm_seq_nth vs ($smt_builtin_z_dec n)))
  )
)

; Converts a $smt_Seq to a (Seq $smt_Value).
(program $smtx_ssm_seq_to_smt_seq ((v $smt_Value) (vs $smt_Seq))
  :signature ($smt_Seq) ($smt_builtin_type_1 "Seq" $smt_Value)
  (
  (($smtx_ssm_seq_to_smt_seq $ssm_empty)
    ($smt_apply_0 "(as seq.empty (Seq vsm.Value))"))
  (($smtx_ssm_seq_to_smt_seq ($ssm_cons v vs))
    ($smt_apply_2 "seq.++" v ($smtx_ssm_seq_to_smt_seq vs)))
  )
)

; Converts a (Seq $smt_Value) to a $smt_Seq
;(program $smtx_smt_seq_to_ssm_seq ((s ($smt_builtin_type_1 "Seq" $smt_Value)))
;  :signature (($smt_builtin_type_1 "Seq" $smt_Value)) $smt_Seq
;  (
;  (($smtx_smt_seq_to_ssm_seq s)
;    (eo::define ((lens ($smt_apply_2 "seq.len" s)))
;    ($smt_builtin_ite
;      ($smt_builtin_= lens $smt_builtin_z_zero)
;      $ssm_empty
;      ($ssm_cons
;        ($smt_apply_3 "seq.substr" s $smt_builtin_z_zero $smt_builtin_z_one)
;        ($smtx_smt_seq_to_ssm_seq
;          ($smt_apply_3 "seq.substr" s $smt_builtin_z_one lens))))))
;  )
;)

;;; Utilities for Datatype values

; define: $smt_is_dt
; returns: true if t is a datatpe (i.e. it has constructors).
(define $smt_is_dt ((t $eo_Term))
  ($smt_builtin_is_ok ($eo_dt_constructors t)))

; define: $smt_is_dt_cons
; returns: true if t is a constructor (i.e. it has selectors).
(define $smt_is_dt_cons ((t $eo_Term))
  ($smt_builtin_is_ok ($eo_dt_selectors t)))

;;; Utilities for making values

; program: $smtx_is_atomic_term_value
; Returns true if its argument is an SMT value.
; This function is expected to never get stuck.
; Note that this does not take a type. This function must ensure
; that if it returns true for two terms t1 and t2 of the same type,
; then t1 != t2 in all models.
(program $smtx_is_atomic_term_value
  ((t $eo_Term) (b $smt_builtin_Bool) (w $smt_builtin_Int) (n $smt_builtin_Int) (r $smt_builtin_Real) (s $smt_builtin_String))
  :signature ($eo_Term) $smt_builtin_Bool
  (
  ; standard atomic types are values
  (($smtx_is_atomic_term_value ($eo_bool b))  $smt_builtin_true)
  (($smtx_is_atomic_term_value ($eo_numeral n))     $smt_builtin_true)
  (($smtx_is_atomic_term_value ($eo_rational r))     $smt_builtin_true)
  (($smtx_is_atomic_term_value ($eo_string s))   $smt_builtin_true)
  (($smtx_is_atomic_term_value ($eo_binary w n))
    ; must be legal width and value
    ($smt_builtin_and
      ($smt_apply_2 "<=" $smt_builtin_z_zero w)
      ($smt_builtin_teq ($eo_binary w n) ($eo_binary_mod_w w n))))
  ; by default, not a value
  (($smtx_is_atomic_term_value t)                $smt_builtin_false)
  )
)

; Returns a term of type $smt_Value, embeds the term
; if indeed it is a value, or returns not a value otherwise.
(define $smt_mk_value_term ((t $eo_Term))
  ($smt_builtin_ite ($smtx_is_atomic_term_value t)
    ; an atomic term, e.g. 0, true, "abc"
    ($vsm_term t)
    ($smt_builtin_ite ($smt_is_dt_cons t)
      ; a datatype constructor, which becomes a (nil-terminated) vsm_apply
      ($vsm_apply ($vsm_term t) $vsm_not_value)
      $vsm_not_value)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Model semantics

; Forward declaration of the main method defined by this signature.
; We use this to define $eo_model_sat.
(program $smtx_model_eval () :signature ($eo_Term) $smt_Value)

;;; Core

; program: $smtx_model_eval_apply
; We call ($smtx_model_eval_apply value_f value_i) when
; evaluating (f i) whose values are value_f and value_i
; respectively. If value_f is a map value, then we extract
; the map and call the map lookup routine.
(program $smtx_model_eval_apply
  ((m $smt_Map) (i $smt_Value) (f $smt_Value) (v $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  ; If a Herbrand interpretation, apply it to the next value.
  (($smtx_model_eval_apply ($vsm_apply f v) i)  ($vsm_apply ($vsm_apply f v) i))
  ; The function evaluated to a map value, call the map lookup.
  (($smtx_model_eval_apply ($vsm_map m) i)    ($smtx_msm_lookup m i))
  ; The function did not evaluate to a map value, we fail.
  (($smtx_model_eval_apply v i)                 $vsm_not_value)
  )
)

; ITE branches to the appropriate child.
; return: The evaluation of an ite application.
(program $smtx_model_eval_ite
  ((t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_ite $vsm_true t2 t3)   t2)
  (($smtx_model_eval_ite $vsm_false t2 t3)  t3)
  (($smtx_model_eval_ite t1 t2 t3)          $vsm_not_value)
  )
)

; Equality insists on valueness and then reduces to an equality over datatypes
; in the deep embedding (vsm.Value), meaning it works for all types, including
; functions and uninterpreted sorts where values are not represented by terms.
; Note that the valueness predicate ensures this is sound. Moreover note that
; we do not invoke the type checker here. This means that if an ill-typed
; equality was given as input to this method, it would always evaluate to false.
; The caller of this method is responsible for ensuring that this behavior is
; either avoided or admissible.
; return: The evaluation of an equality application.
(program $smtx_model_eval_=
  ((t1 $smt_Value) (t2 $smt_Value)
   (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)
   (w1 $smt_builtin_Int) (w2 $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int)
   (r1 $smt_builtin_Real) (r2 $smt_builtin_Real)
   (s1 $smt_builtin_String) (s2 $smt_builtin_String)
  )
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_= ($vsm_term ($eo_bool b1)) ($vsm_term ($eo_bool b2)))
    ($vsm_term ($eo_bool ($smt_builtin_teq ($eo_bool b1) ($eo_bool b2)))))
  (($smtx_model_eval_= ($vsm_term ($eo_bool b1)) t2) $vsm_not_value)
  (($smtx_model_eval_= t1 ($vsm_term ($eo_bool b2))) $vsm_not_value)
  (($smtx_model_eval_= ($vsm_term ($eo_numeral n1)) ($vsm_term ($eo_numeral n2)))
    ($vsm_term ($eo_bool ($smt_builtin_teq ($eo_numeral n1) ($eo_numeral n2)))))
  (($smtx_model_eval_= ($vsm_term ($eo_numeral n1)) t2) $vsm_not_value)
  (($smtx_model_eval_= t1 ($vsm_term ($eo_numeral n2))) $vsm_not_value)
  (($smtx_model_eval_= ($vsm_term ($eo_rational r1)) ($vsm_term ($eo_rational r2)))
    ($vsm_term ($eo_bool ($smt_builtin_teq ($eo_rational r1) ($eo_rational r2)))))
  (($smtx_model_eval_= ($vsm_term ($eo_rational r1)) t2) $vsm_not_value)
  (($smtx_model_eval_= t1 ($vsm_term ($eo_rational r2))) $vsm_not_value)
  (($smtx_model_eval_= ($vsm_term ($eo_string s1)) ($vsm_term ($eo_string s2)))
    ($vsm_term ($eo_bool ($smt_builtin_teq ($eo_string s1) ($eo_string s2)))))
  (($smtx_model_eval_= ($vsm_term ($eo_string s1)) t2) $vsm_not_value)
  (($smtx_model_eval_= t1 ($vsm_term ($eo_string s2))) $vsm_not_value)
  (($smtx_model_eval_= ($vsm_term ($eo_binary w1 n1)) ($vsm_term ($eo_binary w2 n2)))
    ; note that we know that w1, w2 are legal by invariant on model eval
    ($smt_builtin_ite ($smt_builtin_z_eq w1 w2)
      ($vsm_term ($eo_bool ($smt_builtin_teq ($eo_binary w1 n1) ($eo_binary w2 n2))))
      $vsm_not_value))
  (($smtx_model_eval_= ($vsm_term ($eo_binary w1 n1)) t2) $vsm_not_value)
  (($smtx_model_eval_= t1 ($vsm_term ($eo_binary w2 n2))) $vsm_not_value)
  ; TODO: datatype values, others?
  (($smtx_model_eval_= $vsm_not_value t2) $vsm_not_value)
  (($smtx_model_eval_= t1 $vsm_not_value) $vsm_not_value)
  ; use datatype equality over $smt_Value, which depends on t1 and t2 being proper values.
  (($smtx_model_eval_= t1 t2)             ($vsm_term ($eo_bool ($smt_builtin_veq t1 t2))))
  )
)

;;; Functions, arrays

; Array select
(program $smtx_map_select
  ((v $smt_Value) (i $smt_Value) (m $smt_Map))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_select ($vsm_map m) i) ($smtx_msm_lookup m i))
  (($smtx_map_select v i)              $vsm_not_value)
  )
)

; Array store
(program $smtx_map_store
  ((v $smt_Value) (i $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_store ($vsm_map m) i e) ($vsm_map ($smtx_msm_update m i e)))
  (($smtx_map_store v i e)            $vsm_not_value)
  )
)

; Array diff
; Returns the value where m1 and m2 differ, or $vsm_not_value otherwise.
(program $smtx_map_diff ((m1 $smt_Map) (m2 $smt_Map))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_map_diff ($vsm_map m1) ($vsm_map m2))
    ; find an index in the first that conflicts with the second, or vice versa
    ($smtx_value_either ($smtx_msm_find_diff m1 m2) ($smtx_msm_find_diff m2 m1)))
  )
)

;;; Sets

; Empty set
(define $smtx_empty_set () ($vsm_map $msm_empty_set))

; Set singleton
; return the singleton set whose type is T and contains e.
(define $smtx_set_singleton ((e $smt_Value))
  ($vsm_map ($smtx_mss_insert e $msm_empty_set)))

; Set intersection
; return the intersection of two set values.
(program $smtx_set_inter
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_inter ($vsm_map m1) ($vsm_map m2))
    ; m1 intersected m2 starting with empty set.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_true m1 m2 $msm_empty_set)))
  (($smtx_set_inter v1 v2)  $vsm_not_value)
  )
)

; Set minus
; return the set minus of two set values.
(program $smtx_set_minus
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_minus ($vsm_map m1) ($vsm_map m2))
    ; m1 minus m2 starting with empty set.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_false m1 m2 $msm_empty_set)))
  (($smtx_set_minus v1 v2)  $vsm_not_value)
  )
)

; Set union
; return the union of two set values.
(program $smtx_set_union
  ((m1 $smt_Map) (m2 $smt_Map) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_set_union ($vsm_map m1) ($vsm_map m2))
    ; m1 minus the empty set starting with m2.
    ($vsm_map ($smtx_mss_op_internal $smt_builtin_false m1 $msm_empty_set m2)))
  (($smtx_set_union v1 v2)  $vsm_not_value)
  )
)

;;; Sequences

; Empty sequence
(define $smtx_empty_seq () ($vsm_seq $ssm_empty))

; Sequence unit
(define $smtx_seq_unit ((e $smt_Value)) ($vsm_seq ($ssm_cons e $ssm_empty)))

; Sequence nth
(program $smtx_seq_nth
  ((s $smt_Seq) (n $smt_builtin_Int) (v1 $smt_Value) (v2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_seq_nth ($vsm_seq s) ($vsm_term ($eo_numeral n))) ($smtx_ssm_seq_nth s n))
  (($smtx_seq_nth v1 v2) $vsm_not_value)
  )
)

;;; Quantifiers

; Returns the n^th term in the enumeration of type.
; We return a term that has model value that has the n^th value, or
; stuck if we are beyond the cardinality of the type.
; TODO: This is axiomatized.
(program $smtx_model_type_enum () :signature ($eo_Term $smt_builtin_Int) $eo_Term)

; Substitution
; program: $smtx_model_substitute
; Used to define $smtx_eval_exists_rec.
; ($smtx_model_substitute x v t) returns the term where x is replaced by
; the constant that is interpreted as v.
(program $smtx_model_substitute
  ((x $eo_Term) (v $eo_Term) (f $eo_Term) (a $eo_Term) (z $eo_Term))
  :signature ($eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($smtx_model_substitute x v (f a))
    (_ ($smtx_model_substitute x v f) ($smtx_model_substitute x v a)))
  (($smtx_model_substitute x v x) v)   ; we are now the constant with the given interpretation
  (($smtx_model_substitute x v z) z)
  )
)

(program $smtx_eval_exists_rec
  ((s $smt_builtin_String) (T $eo_Term) (v $eo_Term) (F $eo_Term) (i $smt_builtin_Int))
  :signature ($eo_Term $eo_Term $smt_builtin_Int) $smt_Value
  (
  (($smtx_eval_exists_rec ($eo_Var s T) F i)
    (eo::define ((next ($smtx_model_type_enum T i)))
    ; check if we are out of values
    ($smt_builtin_ite ($smt_builtin_is_ok next)
      ; If not out of values, evaluate for the current variable.
      ; Note we do not check for variable shadowing, which will induce ill-formed binders
      ; and fail to evaluate.
      (eo::define ((Fsubs ($smtx_model_substitute ($eo_Var s T) next F)))
      (eo::define ((eval ($smtx_model_eval Fsubs)))
      ; if false, inconclusive, recurse for the next value in the type enumeration for the variable
      ($smt_builtin_ite ($smt_builtin_veq eval $vsm_false)
        ($smtx_eval_exists_rec ($eo_Var s T) F ($smt_builtin_z_inc i))
        ; if true, return successfully, return true
        ($smt_builtin_ite ($smt_builtin_veq eval $vsm_true)
          $vsm_true
          ; otherwise return not value, which is the case that we failed to evaluate
          $vsm_not_value))))
      ; out of values, return false
      $vsm_false)))
  ; not a variable, fail
  (($smtx_eval_exists_rec v F i) $vsm_not_value)
  )
)

; main entry for model evaluation of exists.
(define $smtx_model_eval_exists ((v $eo_Term) (F $eo_Term))
  ; use the routine above, returning the first component
  ($smtx_eval_exists_rec v F $smt_builtin_z_zero))

; alternative implementation
;(program $smtx_model_eval_exists2
;  ((s $smt_builtin_String) (T $eo_Term) (v $eo_Term) (F $eo_Term))
;  :signature ($eo_Term $eo_Term) $smt_Value
;  (
;  (($smtx_model_eval_exists2 ($eo_Var s T) F)
;    ($vsm_term ($eo_bool
;      ($smt_apply_1 "exists (($eo_qv eo.Term))" 
;        ($smt_builtin_and 
;          ($smt_builtin_= ($eo_typeof ($smt_apply_0 "$eo_qv")) T)
;          ($smt_builtin_= 
;            ($smtx_model_eval ($smtx_model_substitute ($eo_Var s T) ($smt_apply_0 "$eo_qv") F))
;            $vsm_true))))))
;  ; not a variable, fail
;  (($smtx_model_eval_exists2 v F) $vsm_not_value)
;  )
;)
  
; Recurses over the domain of the type of the variable.
; Constructs a map where each input/output pair is computed.
(program $smtx_eval_lambda_rec
  ((s $smt_builtin_String) (T $eo_Term) (v $eo_Term) (F $eo_Term) (i $smt_builtin_Int) (acc $smt_Value))
  :signature ($eo_Term $eo_Term $smt_builtin_Int $smt_Value) $smt_Value
  (
  (($smtx_eval_lambda_rec ($eo_Var s T) F i acc)
    ; Get the next enumerated input.
    (eo::define ((input ($smtx_model_type_enum T i)))
    ; If out of values, return the accumulated value
    ($smt_builtin_ite ($smt_builtin_is_ok input)
      acc
      ; compute the output of the body
      (eo::define ((Fsubs ($smtx_model_substitute ($eo_Var s T) input F)))
      (eo::define ((output ($smtx_model_eval Fsubs)))
      ; if we fail to evalue the body, we fail to evaluate
      ($smt_builtin_ite ($smt_builtin_veq output $vsm_not_value)
        $vsm_not_value
        ; recurse, updating the accumulated value.
        ($smtx_eval_lambda_rec ($eo_Var s T) F ($smt_builtin_z_inc i)
          ($smt_builtin_ite ($smt_builtin_veq acc $vsm_not_value)
            ; if the first value, we store as default
            ($vsm_map ($msm_default output))
            ; otherwise, we update.
            ($smtx_map_store acc ($smtx_model_eval input) output)))))))))
  ; not a variable, fail
  (($smtx_eval_lambda_rec v F i acc) $vsm_not_value)
  )
)

(define $smtx_model_eval_lambda ((v $eo_Term) (F $eo_Term))
  ; use routine above, starting from first enumeration, not-value accumulator.
  ($smtx_eval_lambda_rec v F $smt_builtin_z_zero $vsm_not_value))

;;; Datatypes

(program $smtx_eval_dt_head ((f $smt_Value) (a $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_eval_dt_head ($vsm_apply f $vsm_not_value)) f)
  (($smtx_eval_dt_head ($vsm_apply f a))              ($smtx_eval_dt_head f))
  )
)

(program $smtx_eval_dt_selector_rec ((s $eo_Term) (ss $eo_List) (s2 $eo_Term) (f $smt_Value) (a $smt_Value))
  :signature ($smt_Value $eo_List $eo_Term) $smt_Value
  (
  (($smtx_eval_dt_selector_rec ($vsm_apply f a) ($eo_List_cons s ss) s)  a)
  (($smtx_eval_dt_selector_rec ($vsm_apply f a) ($eo_List_cons s2 ss) s)
    ($smtx_eval_dt_selector_rec f ss s))
  ; wrongly applied selector? should axiomatize it?
  (($smtx_eval_dt_selector_rec a ss s) ($smtx_model_eval s))
  )
)

; TODO: handle reverse list??
;(define $smtx_eval_selector

;;; Other model evaluation functions

(program $smtx_model_eval_not
  ((x1 $smt_builtin_Bool) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_not ($vsm_term ($eo_bool x1))) ($vsm_term ($eo_bool ($smt_apply_1 "not" x1))))
  (($smtx_model_eval_not t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_or
  ((x1 $smt_builtin_Bool) (x2 $smt_builtin_Bool) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_or ($vsm_term ($eo_bool x1)) ($vsm_term ($eo_bool x2))) ($vsm_term ($eo_bool ($smt_apply_2 "or" x1 x2))))
  (($smtx_model_eval_or t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_and
  ((x1 $smt_builtin_Bool) (x2 $smt_builtin_Bool) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_and ($vsm_term ($eo_bool x1)) ($vsm_term ($eo_bool x2))) ($vsm_term ($eo_bool ($smt_apply_2 "and" x1 x2))))
  (($smtx_model_eval_and t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_=>
  ((x1 $smt_builtin_Bool) (x2 $smt_builtin_Bool) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_=> ($vsm_term ($eo_bool x1)) ($vsm_term ($eo_bool x2))) ($vsm_term ($eo_bool ($smt_apply_2 "=>" x1 x2))))
  (($smtx_model_eval_=> t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_xor
  ((x1 $smt_builtin_Bool) (x2 $smt_builtin_Bool) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_xor ($vsm_term ($eo_bool x1)) ($vsm_term ($eo_bool x2))) ($vsm_term ($eo_bool ($smt_apply_2 "xor" x1 x2))))
  (($smtx_model_eval_xor t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_+
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_+ ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2))) ($vsm_term ($eo_numeral ($smt_apply_2 "+" x1 x2))))
  (($smtx_model_eval_+ ($vsm_term ($eo_rational x3)) ($vsm_term ($eo_rational x4))) ($vsm_term ($eo_rational ($smt_apply_2 "+" x3 x4))))
  (($smtx_model_eval_+ t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_-
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_- ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2))) ($vsm_term ($eo_numeral ($smt_apply_2 "-" x1 x2))))
  (($smtx_model_eval_- ($vsm_term ($eo_rational x3)) ($vsm_term ($eo_rational x4))) ($vsm_term ($eo_rational ($smt_apply_2 "-" x3 x4))))
  (($smtx_model_eval_- t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_*
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_* ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2))) ($vsm_term ($eo_numeral ($smt_apply_2 "*" x1 x2))))
  (($smtx_model_eval_* ($vsm_term ($eo_rational x3)) ($vsm_term ($eo_rational x4))) ($vsm_term ($eo_rational ($smt_apply_2 "*" x3 x4))))
  (($smtx_model_eval_* t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_<
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_< ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2))) ($vsm_term ($eo_bool ($smt_apply_2 "<" x1 x2))))
  (($smtx_model_eval_< ($vsm_term ($eo_rational x3)) ($vsm_term ($eo_rational x4))) ($vsm_term ($eo_bool ($smt_apply_2 "<" x3 x4))))
  (($smtx_model_eval_< t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_<=
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_<= ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2))) ($vsm_term ($eo_bool ($smt_apply_2 "<=" x1 x2))))
  (($smtx_model_eval_<= ($vsm_term ($eo_rational x3)) ($vsm_term ($eo_rational x4))) ($vsm_term ($eo_bool ($smt_apply_2 "<=" x3 x4))))
  (($smtx_model_eval_<= t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_>
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_> ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2))) ($vsm_term ($eo_bool ($smt_apply_2 ">" x1 x2))))
  (($smtx_model_eval_> ($vsm_term ($eo_rational x3)) ($vsm_term ($eo_rational x4))) ($vsm_term ($eo_bool ($smt_apply_2 ">" x3 x4))))
  (($smtx_model_eval_> t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_>=
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_>= ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2))) ($vsm_term ($eo_bool ($smt_apply_2 ">=" x1 x2))))
  (($smtx_model_eval_>= ($vsm_term ($eo_rational x3)) ($vsm_term ($eo_rational x4))) ($vsm_term ($eo_bool ($smt_apply_2 ">=" x3 x4))))
  (($smtx_model_eval_>= t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_to_real
  ((x1 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_to_real ($vsm_term ($eo_numeral x1))) ($vsm_term ($eo_rational ($smt_apply_1 "to_real" x1))))
  (($smtx_model_eval_to_real t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_to_int
  ((x1 $smt_builtin_Real) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_to_int ($vsm_term ($eo_rational x1))) ($vsm_term ($eo_numeral ($smt_apply_1 "to_int" x1))))
  (($smtx_model_eval_to_int t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_is_int
  ((x1 $smt_builtin_Real) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_is_int ($vsm_term ($eo_rational x1))) ($vsm_term ($eo_bool ($smt_apply_1 "is_int" x1))))
  (($smtx_model_eval_is_int t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_abs
  ((x1 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_abs ($vsm_term ($eo_numeral x1))) ($vsm_term ($eo_numeral ($smt_apply_1 "abs" x1))))
  (($smtx_model_eval_abs t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_div
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_div ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2))) ($vsm_term ($eo_numeral ($smt_apply_2 "div" x1 x2))))
  (($smtx_model_eval_div t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_mod
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_mod ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2))) ($vsm_term ($eo_numeral ($smt_apply_2 "mod" x1 x2))))
  (($smtx_model_eval_mod t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_int.pow2
  ((x1 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_int.pow2 ($vsm_term ($eo_numeral x1))) ($vsm_term ($eo_numeral ($smt_apply_1 "int.pow2" x1))))
  (($smtx_model_eval_int.pow2 t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_int.log2
  ((x1 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_int.log2 ($vsm_term ($eo_numeral x1))) ($vsm_term ($eo_numeral ($smt_apply_1 "int.log2" x1))))
  (($smtx_model_eval_int.log2 t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_@bvsize
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_@bvsize ($vsm_term ($eo_binary x1 x2))) ($vsm_term ($eo_numeral x1)))
  (($smtx_model_eval_@bvsize t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_concat
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_concat ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) ($vsm_term ($eo_binary_mod_w ($smt_apply_2 "+" x1 x3) ($smtx_binary_concat x1 x2 x3 x4))))
  (($smtx_model_eval_concat t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_extract
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_extract ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2)) ($vsm_term ($eo_binary x3 x4))) ($smt_builtin_ite ($smt_apply_2 "and" ($smt_apply_2 ">=" x1 x2) ($smt_apply_2 "and" ($smt_apply_2 ">=" x2 $smt_builtin_z_zero) ($smt_apply_2 ">" x3 x1))) ($vsm_term ($eo_binary_mod_w ($smt_apply_2 "-" ($smt_apply_2 "+" x1 $smt_builtin_z_one) x2) ($smtx_binary_extract x3 x4 x1 x2))) $vsm_not_value))
  (($smtx_model_eval_extract t1 t2 t3) $vsm_not_value)
  )
)
(program $smtx_model_eval_repeat
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_repeat ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_binary x2 x3))) ($smt_builtin_ite ($smt_apply_2 ">=" x1 $smt_builtin_z_one) ($smt_builtin_ite ($smt_builtin_z_eq x1 $smt_builtin_z_one) ($vsm_term ($eo_binary x2 x3)) ($smtx_model_eval (concat (repeat (- ($eo_numeral x1) 1) ($eo_mk_binary x2 x3)) ($eo_mk_binary x2 x3)))) $vsm_not_value))
  (($smtx_model_eval_repeat t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvnot
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvnot ($vsm_term ($eo_binary x1 x2))) ($vsm_term ($eo_binary_mod_w x1 ($smtx_binary_not x1 x2))))
  (($smtx_model_eval_bvnot t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvand
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvand ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) ($smt_builtin_ite ($smt_builtin_z_eq x1 x3) ($vsm_term ($eo_binary_mod_w x1 ($smtx_binary_and x1 x2 x4))) $vsm_not_value))
  (($smtx_model_eval_bvand t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvor
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvor ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) ($smt_builtin_ite ($smt_builtin_z_eq x1 x3) ($vsm_term ($eo_binary_mod_w x1 ($smtx_binary_or x1 x2 x4))) $vsm_not_value))
  (($smtx_model_eval_bvor t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvxor
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvxor ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) ($smt_builtin_ite ($smt_builtin_z_eq x1 x3) ($vsm_term ($eo_binary_mod_w x1 ($smtx_binary_xor x1 x2 x4))) $vsm_not_value))
  (($smtx_model_eval_bvxor t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvneg
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvneg ($vsm_term ($eo_binary x1 x2))) ($vsm_term ($eo_binary_mod_w x1 ($smt_builtin_z_neg x2))))
  (($smtx_model_eval_bvneg t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvadd
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvadd ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) ($smt_builtin_ite ($smt_builtin_z_eq x1 x3) ($vsm_term ($eo_binary_mod_w x1 ($smt_builtin_z_add x2 x4))) $vsm_not_value))
  (($smtx_model_eval_bvadd t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvmul
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvmul ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) ($smt_builtin_ite ($smt_builtin_z_eq x1 x3) ($vsm_term ($eo_binary_mod_w x1 ($smt_builtin_z_mul x2 x4))) $vsm_not_value))
  (($smtx_model_eval_bvmul t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvudiv
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvudiv ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) ($smt_builtin_ite ($smt_builtin_z_eq x1 x3) ($vsm_term ($eo_binary_mod_w x1 ($smt_builtin_ite ($smt_builtin_z_eq x3 $smt_builtin_z_zero) ($smtx_binary_max x1) ($smt_builtin_div x2 x4)))) $vsm_not_value))
  (($smtx_model_eval_bvudiv t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvurem
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvurem ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) ($smt_builtin_ite ($smt_builtin_z_eq x1 x3) ($vsm_term ($eo_binary_mod_w x1 ($smt_builtin_ite ($smt_builtin_z_eq x3 $smt_builtin_z_zero) x2 ($smt_builtin_mod x2 x4)))) $vsm_not_value))
  (($smtx_model_eval_bvurem t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvugt
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvugt ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) ($smt_builtin_ite ($smt_builtin_z_eq x1 x3) ($vsm_term ($eo_bool ($smt_apply_2 ">" x2 x4))) $vsm_not_value))
  (($smtx_model_eval_bvugt t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvsgt
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvsgt ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) (eo::define ((s ($eo_mk_binary x1 x2))) (eo::define ((t ($eo_mk_binary x3 x4))) (eo::define ((msb_s ($eo_bool ($smtx_msb x1 x2)))) (eo::define ((msb_t ($eo_bool ($smtx_msb x3 x4)))) ($smtx_model_eval (or (and (not msb_s) msb_t) (and (= msb_s msb_t) (bvugt s t)))))))))
  (($smtx_model_eval_bvsgt t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvshl
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvshl ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) ($smt_builtin_ite ($smt_builtin_z_eq x1 x3) ($vsm_term ($eo_binary_mod_w x1 ($smt_builtin_z_mul x2 ($smtx_pow2 x4)))) $vsm_not_value))
  (($smtx_model_eval_bvshl t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvlshr
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvlshr ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) ($smt_builtin_ite ($smt_builtin_z_eq x1 x3) ($vsm_term ($eo_binary_mod_w x1 ($smt_builtin_div x2 ($smtx_pow2 x4)))) $vsm_not_value))
  (($smtx_model_eval_bvlshr t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvashr
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvashr ($vsm_term ($eo_binary x1 x2)) ($vsm_term ($eo_binary x3 x4))) (eo::define ((s ($eo_mk_binary x1 x2))) (eo::define ((t ($eo_mk_binary x3 x4))) (eo::define ((wm1 (- ($eo_numeral x1) 1))) ($smtx_model_eval (ite (= (extract wm1 wm1 s) #b0) (bvlshr s t) (bvnot (bvlshr (bvnot s) t))))))))
  (($smtx_model_eval_bvashr t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_zero_extend
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_zero_extend ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_binary x2 x3))) ($smt_builtin_ite ($smt_apply_2 ">=" x1 $smt_builtin_z_zero) ($vsm_term ($eo_binary ($smt_builtin_z_add x1 x2) x3)) $vsm_not_value))
  (($smtx_model_eval_zero_extend t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_sign_extend
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_sign_extend ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_binary x2 x3))) ($smt_builtin_ite ($smt_apply_2 ">=" x1 $smt_builtin_z_zero) ($smt_builtin_ite ($smt_builtin_z_eq x1 $smt_builtin_z_zero) ($vsm_term ($eo_binary x2 x3)) (eo::define ((wm1 (- ($eo_numeral x2) 1))) (eo::define ((t ($eo_mk_binary x2 x3))) ($smtx_model_eval (concat (repeat ($eo_numeral x1) (extract wm1 wm1 t)) t))))) $vsm_not_value))
  (($smtx_model_eval_sign_extend t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_@bv
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_@bv ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2))) ($smtx_model_eval ($eo_mk_binary x2 x1)))
  (($smtx_model_eval_@bv t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.len
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.len ($vsm_term ($eo_string x1))) ($vsm_term ($eo_numeral ($smt_apply_1 "str.len" x1))))
  (($smtx_model_eval_str.len t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.++
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.++ ($vsm_term ($eo_string x1)) ($vsm_term ($eo_string x2))) ($vsm_term ($eo_string ($smt_apply_2 "str.++" x1 x2))))
  (($smtx_model_eval_str.++ t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.substr
  ((x1 $smt_builtin_String) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.substr ($vsm_term ($eo_string x1)) ($vsm_term ($eo_numeral x2)) ($vsm_term ($eo_numeral x3))) ($vsm_term ($eo_string ($smt_apply_3 "str.substr" x1 x2 x3))))
  (($smtx_model_eval_str.substr t1 t2 t3) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.contains
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.contains ($vsm_term ($eo_string x1)) ($vsm_term ($eo_string x2))) ($vsm_term ($eo_bool ($smt_apply_2 "str.contains" x1 x2))))
  (($smtx_model_eval_str.contains t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.replace
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (x3 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.replace ($vsm_term ($eo_string x1)) ($vsm_term ($eo_string x2)) ($vsm_term ($eo_string x3))) ($vsm_term ($eo_string ($smt_apply_3 "str.replace" x1 x2 x3))))
  (($smtx_model_eval_str.replace t1 t2 t3) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.indexof
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (x3 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.indexof ($vsm_term ($eo_string x1)) ($vsm_term ($eo_string x2)) ($vsm_term ($eo_numeral x3))) ($vsm_term ($eo_numeral ($smt_apply_3 "str.indexof" x1 x2 x3))))
  (($smtx_model_eval_str.indexof t1 t2 t3) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.at
  ((x1 $smt_builtin_String) (x2 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.at ($vsm_term ($eo_string x1)) ($vsm_term ($eo_numeral x2))) ($vsm_term ($eo_string ($smt_apply_2 "str.at" x1 x2))))
  (($smtx_model_eval_str.at t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.prefixof
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.prefixof ($vsm_term ($eo_string x1)) ($vsm_term ($eo_string x2))) ($vsm_term ($eo_bool ($smt_apply_2 "str.prefixof" x1 x2))))
  (($smtx_model_eval_str.prefixof t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.suffixof
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.suffixof ($vsm_term ($eo_string x1)) ($vsm_term ($eo_string x2))) ($vsm_term ($eo_bool ($smt_apply_2 "str.suffixof" x1 x2))))
  (($smtx_model_eval_str.suffixof t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.rev
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.rev ($vsm_term ($eo_string x1))) ($vsm_term ($eo_string ($smt_apply_1 "str.rev" x1))))
  (($smtx_model_eval_str.rev t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.update
  ((x1 $smt_builtin_String) (x2 $smt_builtin_Int) (x3 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.update ($vsm_term ($eo_string x1)) ($vsm_term ($eo_numeral x2)) ($vsm_term ($eo_string x3))) ($vsm_term ($eo_string ($smt_apply_3 "str.update" x1 x2 x3))))
  (($smtx_model_eval_str.update t1 t2 t3) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.to_lower
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.to_lower ($vsm_term ($eo_string x1))) ($vsm_term ($eo_string ($smt_apply_1 "str.to_lower" x1))))
  (($smtx_model_eval_str.to_lower t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.to_upper
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.to_upper ($vsm_term ($eo_string x1))) ($vsm_term ($eo_string ($smt_apply_1 "str.to_upper" x1))))
  (($smtx_model_eval_str.to_upper t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.to_code
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.to_code ($vsm_term ($eo_string x1))) ($vsm_term ($eo_numeral ($smt_apply_1 "str.to_code" x1))))
  (($smtx_model_eval_str.to_code t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.from_code
  ((x1 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.from_code ($vsm_term ($eo_numeral x1))) ($vsm_term ($eo_string ($smt_apply_1 "str.from_code" x1))))
  (($smtx_model_eval_str.from_code t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.to_int
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.to_int ($vsm_term ($eo_string x1))) ($vsm_term ($eo_numeral ($smt_apply_1 "str.to_int" x1))))
  (($smtx_model_eval_str.to_int t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.from_int
  ((x1 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.from_int ($vsm_term ($eo_numeral x1))) ($vsm_term ($eo_string ($smt_apply_1 "str.from_int" x1))))
  (($smtx_model_eval_str.from_int t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.<=
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.<= ($vsm_term ($eo_string x1)) ($vsm_term ($eo_string x2))) ($vsm_term ($eo_bool ($smt_apply_2 "str.<=" x1 x2))))
  (($smtx_model_eval_str.<= t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.replace_all
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (x3 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.replace_all ($vsm_term ($eo_string x1)) ($vsm_term ($eo_string x2)) ($vsm_term ($eo_string x3))) ($vsm_term ($eo_string ($smt_apply_3 "str.replace_all" x1 x2 x3))))
  (($smtx_model_eval_str.replace_all t1 t2 t3) $vsm_not_value)
  )
)
(program $smtx_model_eval_/
  ((x1 $smt_builtin_Real) (x2 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_/ ($vsm_term ($eo_rational x1)) ($vsm_term ($eo_rational x2))) ($vsm_term ($eo_rational ($smt_apply_2 "/" x1 x2))))
  (($smtx_model_eval_/ t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_int_to_bv
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_int_to_bv ($vsm_term ($eo_numeral x1)) ($vsm_term ($eo_numeral x2))) ($smtx_model_eval ($eo_mk_binary x1 x2)))
  (($smtx_model_eval_int_to_bv t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_ubv_to_int
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_ubv_to_int ($vsm_term ($eo_binary x1 x2))) ($vsm_term ($eo_numeral x2)))
  (($smtx_model_eval_ubv_to_int t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_sbv_to_int
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_sbv_to_int ($vsm_term ($eo_binary x1 x2))) ($vsm_term ($eo_numeral ($smtx_binary_uts x1 x2))))
  (($smtx_model_eval_sbv_to_int t1) $vsm_not_value)
  )
)


; An evaluator for all terms that we can reason about models.
; This is a recursive call.
; invariant: this must be a total function
; invariant: unless this method returns $vsm_not_value, it must be such that
;            it represents a unique SMT-LIB value, i.e. ($vsm_term t) is
;            forbidden unless t denotes a value.
(program $smtx_model_eval
  ((f $eo_Term) (y $eo_Term) (z $eo_Term) (val $smt_Value) (T $eo_Term)
   ; generic parameters that may appear in terms to pattern match
   (x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term) (x4 $eo_Term) (x5 $eo_Term))
  :signature ($eo_Term) $smt_Value
  (
  ; evaluation of standard SMT symbols
  ; These calls will reference helper methods above, e.g. of the form
  ; $smtx_model_eval_*, or call builtin methods e.g. $smtx_eval_exists_rec.
  (($smtx_model_eval (ite x1 x2 x3)) ($smtx_model_eval_ite ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  (($smtx_model_eval (not x1)) ($smtx_model_eval_not ($smtx_model_eval x1)))
  (($smtx_model_eval (or x1 x2)) ($smtx_model_eval_or ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (and x1 x2)) ($smtx_model_eval_and ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (=> x1 x2)) ($smtx_model_eval_=> ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (xor x1 x2)) ($smtx_model_eval_xor ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (= x1 x2)) ($smtx_model_eval_= ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (+ x1 x2)) ($smtx_model_eval_+ ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (- x1 x2)) ($smtx_model_eval_- ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (* x1 x2)) ($smtx_model_eval_* ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (< x1 x2)) ($smtx_model_eval_< ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (<= x1 x2)) ($smtx_model_eval_<= ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (> x1 x2)) ($smtx_model_eval_> ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (>= x1 x2)) ($smtx_model_eval_>= ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (to_real x1)) ($smtx_model_eval_to_real ($smtx_model_eval x1)))
  (($smtx_model_eval (to_int x1)) ($smtx_model_eval_to_int ($smtx_model_eval x1)))
  (($smtx_model_eval (is_int x1)) ($smtx_model_eval_is_int ($smtx_model_eval x1)))
  (($smtx_model_eval (abs x1)) ($smtx_model_eval_abs ($smtx_model_eval x1)))
  (($smtx_model_eval (div x1 x2)) ($smtx_model_eval_div ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (mod x1 x2)) ($smtx_model_eval_mod ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (int.pow2 x1)) ($smtx_model_eval_int.pow2 ($smtx_model_eval x1)))
  (($smtx_model_eval (int.log2 x1)) ($smtx_model_eval_int.log2 ($smtx_model_eval x1)))
  (($smtx_model_eval (int.ispow2 x1)) ($smtx_model_eval (and (>= x1 0) (= x1 (int.pow2 (int.log2 x1))))))
  (($smtx_model_eval (div_total x1 x2)) ($smtx_model_eval (ite (= x2 0) 0 (div x1 x2))))
  (($smtx_model_eval (mod_total x1 x2)) ($smtx_model_eval (ite (= x2 0) x1 (mod x1 x2))))
  (($smtx_model_eval (@bvsize x1)) ($smtx_model_eval_@bvsize ($smtx_model_eval x1)))
  (($smtx_model_eval (concat x1 x2)) ($smtx_model_eval_concat ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (extract x1 x2 x3)) ($smtx_model_eval_extract ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  (($smtx_model_eval (repeat x1 x2)) ($smtx_model_eval_repeat ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvnot x1)) ($smtx_model_eval_bvnot ($smtx_model_eval x1)))
  (($smtx_model_eval (bvand x1 x2)) ($smtx_model_eval_bvand ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvor x1 x2)) ($smtx_model_eval_bvor ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvxor x1 x2)) ($smtx_model_eval_bvxor ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvneg x1)) ($smtx_model_eval_bvneg ($smtx_model_eval x1)))
  (($smtx_model_eval (bvadd x1 x2)) ($smtx_model_eval_bvadd ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvmul x1 x2)) ($smtx_model_eval_bvmul ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvudiv x1 x2)) ($smtx_model_eval_bvudiv ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvurem x1 x2)) ($smtx_model_eval_bvurem ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvsub x1 x2)) ($smtx_model_eval (bvadd x1 (bvneg x2))))
  (($smtx_model_eval (bvult x1 x2)) ($smtx_model_eval (bvugt x2 x1)))
  (($smtx_model_eval (bvule x1 x2)) ($smtx_model_eval (bvuge x2 x1)))
  (($smtx_model_eval (bvugt x1 x2)) ($smtx_model_eval_bvugt ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvuge x1 x2)) ($smtx_model_eval (or (bvugt x1 x2) (= x1 x2))))
  (($smtx_model_eval (bvslt x1 x2)) ($smtx_model_eval (bvsgt x2 x1)))
  (($smtx_model_eval (bvsle x1 x2)) ($smtx_model_eval (bvsge x2 x1)))
  (($smtx_model_eval (bvsgt x1 x2)) ($smtx_model_eval_bvsgt ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvsge x1 x2)) ($smtx_model_eval (or (bvsgt x1 x2) (= x1 x2))))
  (($smtx_model_eval (bvshl x1 x2)) ($smtx_model_eval_bvshl ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvlshr x1 x2)) ($smtx_model_eval_bvlshr ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvashr x1 x2)) ($smtx_model_eval_bvashr ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (zero_extend x1 x2)) ($smtx_model_eval_zero_extend ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (sign_extend x1 x2)) ($smtx_model_eval_sign_extend ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (@bv x1 x2)) ($smtx_model_eval_@bv ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (as seq.empty (Seq Char))) ($vsm_term ($eo_string $smt_builtin_str_empty)))
  (($smtx_model_eval (as seq.empty x1)) $smtx_empty_seq)
  (($smtx_model_eval (str.len x1)) ($smtx_model_eval_str.len ($smtx_model_eval x1)))
  (($smtx_model_eval (str.++ x1 x2)) ($smtx_model_eval_str.++ ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.substr x1 x2 x3)) ($smtx_model_eval_str.substr ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  (($smtx_model_eval (str.contains x1 x2)) ($smtx_model_eval_str.contains ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.replace x1 x2 x3)) ($smtx_model_eval_str.replace ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  (($smtx_model_eval (str.indexof x1 x2 x3)) ($smtx_model_eval_str.indexof ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  (($smtx_model_eval (str.at x1 x2)) ($smtx_model_eval_str.at ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.prefixof x1 x2)) ($smtx_model_eval_str.prefixof ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.suffixof x1 x2)) ($smtx_model_eval_str.suffixof ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.rev x1)) ($smtx_model_eval_str.rev ($smtx_model_eval x1)))
  (($smtx_model_eval (str.update x1 x2 x3)) ($smtx_model_eval_str.update ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  (($smtx_model_eval (str.to_lower x1)) ($smtx_model_eval_str.to_lower ($smtx_model_eval x1)))
  (($smtx_model_eval (str.to_upper x1)) ($smtx_model_eval_str.to_upper ($smtx_model_eval x1)))
  (($smtx_model_eval (str.to_code x1)) ($smtx_model_eval_str.to_code ($smtx_model_eval x1)))
  (($smtx_model_eval (str.from_code x1)) ($smtx_model_eval_str.from_code ($smtx_model_eval x1)))
  (($smtx_model_eval (str.to_int x1)) ($smtx_model_eval_str.to_int ($smtx_model_eval x1)))
  (($smtx_model_eval (str.from_int x1)) ($smtx_model_eval_str.from_int ($smtx_model_eval x1)))
  (($smtx_model_eval (str.<= x1 x2)) ($smtx_model_eval_str.<= ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.replace_all x1 x2 x3)) ($smtx_model_eval_str.replace_all ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  (($smtx_model_eval (/ x1 x2)) ($smtx_model_eval_/ ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (/_total x1 x2)) ($smtx_model_eval (ite (= x2 0/1) 0/1 (/ x1 x2))))
  (($smtx_model_eval (int_to_bv x1 x2)) ($smtx_model_eval_int_to_bv ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (ubv_to_int x1)) ($smtx_model_eval_ubv_to_int ($smtx_model_eval x1)))
  (($smtx_model_eval (sbv_to_int x1)) ($smtx_model_eval_sbv_to_int ($smtx_model_eval x1)))

  
  ; Apply case. We evaluate f and y separately and then call the
  ; $smtx_model_eval_apply above. We expect f to be an uninterpreted
  ; function whose model evaluation is an SMT-LIB map in this case.
  ; All interpreted f should be handled in the evaluation cases above.
  (($smtx_model_eval (f y))
    ($smtx_model_eval_apply ($smtx_model_eval f) ($smtx_model_eval y)))
  ; Otherwise, it may be a term value (e.g. if z is a Boolean or numeral constant).
  ; We call the utility method which will either generate an SMT-LIB term value or
  ; a SMT-LIB non-value error term.
  (($smtx_model_eval z)                           ($smt_mk_value_term z))
  )
)

;;;;;;;;;;;;;;;;;;;;;;

; program: $eo_model_sat
; note: F is satisfied by the model if F evaluates to the SMT-LIB value denoting true.
; We expect the input to this method to be a Eunoia term denoting an SMT-LIB formula
; (term of Boolean type).
(program $eo_model_sat ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_sat F) ($smt_builtin_ite ($smt_builtin_veq ($smtx_model_eval F) $vsm_true) true false))
  )
)
(program $eo_model_unsat ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_unsat F) ($smt_builtin_ite ($smt_builtin_veq ($smtx_model_eval F) $vsm_false) true false))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_end
(program $eovc_evaluate ((U Type) (t U))
  :signature (U) Bool
  (
  (($eovc_evaluate t) (eo::define ((_v0 ($eo_prog_evaluate t))) (eo::requires ($eo_typeof _v0) Bool (eo::requires ($eo_model_unsat _v0) true true))))
  )
)
(echo "smt-meta $eovc_evaluate :deps $eo_proven $smtx_hash $eo_reverse_hash $smtx_value_hash $smtx_reverse_value_hash $eo_Bool $eo_Type $eo_fun_type $eo_apply $eo_mk_apply ")
