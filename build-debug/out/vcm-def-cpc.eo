; trim-defs: $eovc_evaluate
; #trim-defs: 380
(declare-const Int Type)
(declare-consts <numeral> Int)
(declare-const Real Type)
(declare-consts <rational> Real)
(declare-const Char Type)
(declare-const Seq (-> Type Type))
(declare-consts <string> (Seq Char))
(define $eo_Numeral () Int)
(define $eo_Rational () Real)
(define $eo_String () (Seq Char))
(define $eo_Binary () Type)
(program $eo_nil ((T Type) (U Type) (V Type) (W Type))
  :signature ((-> T U V) (eo::quote W)) W)
(program $eo_typeof ((T Type))
  :signature (T) Type)
(program $eo_fail_prog ()
  :signature (Bool) Bool
  (
  (($eo_fail_prog true) true)
  )
)
(define $eo_fail () ($eo_fail_prog false))
(program $eo_if_both ((b1 Bool) (b2 Bool))
  :signature (Bool Bool) Bool
  (
  (($eo_if_both true true)  true)
  (($eo_if_both b1 b2)      false)
  )
)
(program $eo_requires_eq ((T Type) (U Type) (x1 T) (x3 U))
  :signature (T T U) U
  (
  (($eo_requires_eq x1 x1 x3) x3)
  )
)
; This file defines a deep embedding of SMT-LIB into Eunoia.
; It is used for two purposes:
; 1. To give an SMT-LIB specific bootstrapping of the SMT-LIB inspired builtin Eunoia functions, e.g. $eo_add.
; 2. It is used to define the end signature for defining the model semantics of SMT-LIB.

; All of the functions in this file will be handled by smt_meta.

;;; declarations to define literal types

; The type of $smt_apply_* terms.
; If a term has this type, we know it is an SMT-LIB type,
; but we don't know which one from ordinary type checking.
(declare-const $smt_BuiltinType Type)

; The operator of $smt_apply_* terms
(define $smt_id () $eo_String)

; note: decimal and hexadecimal omitted for now.

;;; Deep embedding of SMT-LIB operator applications into Eunoia

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_type_0
  ((op $smt_id :opaque))
  Type)
(declare-parameterized-const $smt_type_1
  ((W1 Type :implicit) (op $smt_id :opaque) (x1 W1 :opaque))
  Type)
(declare-parameterized-const $smt_apply_0
  ((op $smt_id :opaque))
  $smt_BuiltinType)
(declare-parameterized-const $smt_apply_1
  ((W1 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_2
  ((W1 Type :implicit) (W2 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_3
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_4
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque)) $smt_BuiltinType)
(declare-parameterized-const $smt_apply_5
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit)
   (op $smt_id :opaque) (x1 W1 :opaque) (x2 W2 :opaque) (x3 W3 :opaque) (x4 W4 :opaque) (x5 W5 :opaque)) $smt_BuiltinType)

; Handles the corner case of SMT-LIB equality, which we use for Eunoia terms as well.
(declare-parameterized-const $smt_apply_=
  ((W Type :implicit) (x1 W :opaque) (x2 W :opaque))
  $smt_BuiltinType)

; builtin types, which print as e.g. "sm.Int".
(declare-parameterized-const $smt_builtin_type_0
  ((op $smt_id :opaque))
  Type)
; NOTE: the fact that x1 is not opaque indicates that
; bitvectors print as (_ BitVec w) not (BitVec w).
(declare-parameterized-const $smt_builtin_type_1
  ((W1 Type :implicit) (op $smt_id :opaque) (x1 W1))
  Type)

(define $smt_builtin_Bool () ($smt_type_0 "Bool"))
(define $smt_builtin_Int () ($smt_type_0 "Int"))
(define $smt_builtin_Real () ($smt_type_0 "Real"))
(define $smt_builtin_String () ($smt_type_0 "String"))
(define $smt_builtin_true () ($smt_apply_0 "true"))
(define $smt_builtin_false () ($smt_apply_0 "false"))
(define $smt_builtin_= ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_= x1 x2))
(define $smt_builtin_ite ((W Type :implicit) (b $smt_builtin_Bool) (x1 W) (x2 W)) ($smt_apply_3 "ite" b x1 x2))
(define $smt_builtin_z_zero () ($smt_apply_0 "0"))
(define $smt_builtin_z_one () ($smt_apply_0 "1"))
(define $smt_builtin_z_two () ($smt_apply_0 "2"))
(define $smt_builtin_add ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "+" x1 x2))
(define $smt_builtin_mul ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "*" x1 x2))
(define $smt_builtin_neg ((W Type :implicit) (x1 W)) ($smt_apply_1 "-" x1))
(define $smt_builtin_div ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "div" x1 x2))
(define $smt_builtin_mod ((W Type :implicit) (x1 W) (x2 W)) ($smt_apply_2 "mod" x1 x2))
(define $smt_builtin_not ((b $smt_builtin_Bool)) ($smt_apply_1 "not" b))
(define $smt_builtin_and ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "and" b1 b2))
(define $smt_builtin_or ((b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool)) ($smt_apply_2 "or" b1 b2))

; TODO: ite

; In this signature, we heavily use references to the Datatypes corresponding
; to the final deep embeddings of Eunoia terms (eo.Term) and SMT-LIB terms
; (sm.Term), where the latter is a subfield type of the former.
; Opaque arguments of a symbol X will be an argument of the constructor eo.X
; (respectively sm.X). Symbols with no

; We introduce datatype constructors for these datatypes ($smd_eo.X and $smd_sm.X)
; respectively. It is important that we mark their arguments as :opaque, as this
; correctly models the pattern matching in the smt-meta later.

; Note that these datatypes will be renamed and replaced by their definitions
; which is hardcoded into smt_meta.smt2.
; We could also have these auto-generated, but leads to complications when it
; comes to printing the argument types, as e.g. the argument to sm.Numeral is
; an SMT-LIB numeral, not a symbolic SMT term.

;;; Final deep embedding datatypes

; Now, we introduce placeholders for the final deep embedding.
; - $smt_Term, $smt_Type, $smt_Value are introduced as placeholders for the final datatypes in the deep embedding.
; - The SMT-like literals are declared for $smt_Term.
; - 

; A Eunoia term.
; This will be replaced by the datatype eo.Term in the final encoding.
(declare-const $eo_Term Type)

; An atomic SMT-LIB type.
; This will be replaced by the datatype tsm.Type in the final encoding.
(declare-const $smt_Type Type)

; An atomic SMT-LIB term.
; This will be replaced by the datatype sm.Term in the final encoding.
(declare-const $smt_Term Type)

; An SMT-LIB value.
; This will be replaced by the datatype vsm.Value in the final encoding.
(declare-const $smt_Value Type)

; The type of values for functions in SMT-LIB.
(declare-const $smt_Map Type)

;;; SMT type datatype constructors

; The Boolean type
(declare-const $smd_tsm.Bool $smt_Type)
(define $tsm_Bool () $smd_tsm.Bool)

; Uninterpreted sorts
(declare-parameterized-const $smd_tsm.USort
  ((id $smt_builtin_Int :opaque)) $smt_Type)
(define $tsm_USort ((id $smt_builtin_Int)) ($smd_tsm.USort id))

; The sort of a term that doesn't have an SMT-LIB type.
; This is used as an error condition
(declare-parameterized-const $smd_tsm.NullSort
  ((id $smt_builtin_Int :opaque)) $smt_Type)
(define $tsm_NullSort ((id $smt_builtin_Int)) ($smd_tsm.NullSort id))

;;; SMT term datatype constructors

; the literal types
(declare-parameterized-const $smd_sm.Bool
  ((b $smt_builtin_Bool :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Numeral
  ((n $smt_builtin_Int :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Rational
  ((r $smt_builtin_Real :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.String
  ((s ($smt_type_0 "String") :opaque)) $smt_Term)
(declare-parameterized-const $smd_sm.Binary
  ((w $smt_builtin_Int :opaque) (v $smt_builtin_Int :opaque)) $smt_Term)

; Free constants
(declare-parameterized-const $smd_sm.Const ((v $smt_Value :opaque)) $smt_Term)
(define $sm_Const ((v $smt_Value)) ($smd_sm.Const v))

;;; SMT value datatype constructors

; A value denoting a map.
; note: Similar to $eo_Var we store the hash of its type.
(declare-parameterized-const $smd_vsm.Map
  ((T $smt_builtin_Int :opaque) (m $smt_Map :opaque))
  $smt_Value)
(define $vsm_map ((T $smt_builtin_Int) (m $smt_Map))
  ($smd_vsm.Map T m))

; A value denoting an uninterpreted constant.
; note: Similar to $eo_Var we store the hash of its type.
(declare-parameterized-const $smd_vsm.UConst
  ((T $smt_builtin_Int :opaque) (id $smt_builtin_Int :opaque))
  $smt_Value)
(define $vsm_uconst ((T $smt_builtin_Int) (id $smt_builtin_Int))
  ($smd_vsm.UConst T id))

; A value represented by an SMT-LIB term. This is used for types
; where terms are used to denote the values of that type, e.g.
; SMT-LIB numerals for Int.
(declare-parameterized-const $smd_vsm.Term
  ((t $smt_Term :opaque))
  $smt_Value)
(define $vsm_term ((t $smt_Term)) ($smd_vsm.Term t))

; Apply values (for Herbrand interpretations).
(declare-parameterized-const $smd_vsm.Apply
  ((f $smt_Value :opaque) (a $smt_Value :opaque))
  $smt_Value)
(define $vsm_apply ((f $smt_Value) (a $smt_Value))
  ($smd_vsm.Apply f a))

; Denotes a failure case for values.
(declare-const $smd_vsm.NotValue $smt_Value)
(define $vsm_not_value () $smd_vsm.NotValue)

;;; SMT map value datatype constructors

; Constructs a map value where i is mapped to e.
(declare-parameterized-const $smd_msm.Map.cons
  ((i $smt_Value :opaque) (e $smt_Value :opaque) (m $smt_Map :opaque))
  $smt_Map)
(define $msm_cons ((i $smt_Value) (e $smt_Value) (m $smt_Map))
  ($smd_msm.Map.cons i e m))

; Constructs a map value where all indices are mapped to e.
(declare-parameterized-const $smd_msm.Map.default
  ((e $smt_Value :opaque))
  $smt_Map)
(define $msm_default ((e $smt_Value)) ($smd_msm.Map.default e))

;;; Eunoia datatype constructors

; The type of types
(declare-const $smd_eo.Type $eo_Term)
(define $eo_type () $smd_eo.Type)

; The Eunoia representation of "stuckness".
(declare-const $smd_eo.Stuck $eo_Term)
(define $eo_stuck () $smd_eo.Stuck)

; An application of a Eunoia term
(declare-parameterized-const $smd_eo.Apply
  ((f $eo_Term :opaque) (a $eo_Term :opaque))
  $eo_Term)
(define $eo_apply ((x $eo_Term) (y $eo_Term)) ($smd_eo.Apply x y))

; Function type, which Eunoia function type reduces to
(declare-parameterized-const $smd_eo.FunType () $eo_Term)
(define $eo_fun_type () $smd_eo.FunType)

; The Eunoia representation of an SMT-LIB term.
(declare-parameterized-const $smd_eo.SmtTerm ((t $smt_Term :opaque)) $eo_Term)
(define $eo_smt_term ((t $smt_Term)) ($smd_eo.SmtTerm t))

; The Eunoia representation of an SMT-LIB type.
(declare-parameterized-const $smd_eo.SmtType ((t $smt_Type :opaque)) $eo_Term)
(define $eo_smt_type ((T $smt_Type)) ($smd_eo.SmtType T))

; Represents a Eunoia variable in the final deep embedding.
; Note that we embed only the *hash* of its type. This simplifies the
; Eunoia datatype in the final embedding.
(declare-parameterized-const $smd_eo.Var
  ((s $smt_builtin_String :opaque) (T $smt_builtin_Int :opaque))
  $eo_Term)
(define $eo_Var ((s $smt_builtin_String) (T $smt_builtin_Int)) 
  ($smd_eo.Var s T))

;;; External datatype access

(define $sm_mk_true () ($smd_sm.Bool $smt_builtin_true))
(define $sm_mk_false () ($smd_sm.Bool $smt_builtin_false))
(define $sm_mk_bool ((c $smt_builtin_Bool))
  ($smd_sm.Bool c))
(define $sm_mk_z ((n $smt_builtin_Int))
  ($smd_sm.Numeral n))
(define $sm_mk_q ((r $smt_builtin_Real))
  ($smd_sm.Rational r))
(define $sm_mk_str ((s $smt_builtin_String))
  ($smd_sm.String s))
(define $sm_mk_binary ((w $smt_builtin_Int) (n $smt_builtin_Int))
  ($smd_sm.Binary w n))

;(define $smt_Int () ($smt_builtin_type_0 "Int"))
;(define $smt_Real () ($smt_builtin_type_0 "Real"))
;(define $smt_BitVec ((w $smt_builtin_Int)) (_ ($smt_builtin_type_1 "BitVec") w))
;(define $smt_String () ($smt_builtin_type_0 "String"))

(define $vsm_true () ($vsm_term $sm_mk_true))
(define $vsm_false () ($vsm_term $sm_mk_false))

; return: The embedding of (-> T1 T2).
; note: Since the Eunoia function type is an atomic term, this becomes a
;       curried apply.
(define $eo_mk_fun_type ((T1 $eo_Term) (T2 $eo_Term)) 
  ($eo_apply ($eo_apply $eo_fun_type T1) T2))

(define $eo_null_type ()
  ($eo_smt_type ($tsm_NullSort $smt_builtin_z_zero)))

;;; Defining parametric bitvector operators

; The operators in this section are needed to reason about the parametric
; operations on the Eunoia binary literal type.

; program: $smtx_pow2
; return: >
;   The integer value of 2 raised to the i^th power.
; note: We expect i to be non-negative.
(program $smtx_pow2 ((i $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_pow2 i)
    ($smt_apply_3 "ite" ($smt_apply_2 "<=" i $smt_builtin_z_zero)
      $smt_builtin_z_one
      ($smt_builtin_mul $smt_builtin_z_two
        ($smtx_pow2 ($smt_apply_2 "-" i $smt_builtin_z_one)))))
  )
)

; program: $smtx_bit
; return: >
;   true iff the i^th bit of a binary with integer value x is set. Note this
;   method is agnostic to bitwidth. 
(program $smtx_bit ((x $smt_builtin_Int) (i $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Bool
  (
  (($smtx_bit x i) ($smt_apply_1 "= 1" ($smt_builtin_mod ($smt_builtin_div x ($smtx_pow2 i)) $smt_builtin_z_two)))
  )
)

; program: $smtx_binary_and
; return: >
;   The integer value of the binary value obtained by taking the bitwise and of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This value will be
;   taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w.
(program $smtx_binary_and ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_and w n1 n2)
     ($smt_apply_3 "ite" ($smt_apply_= w $smt_builtin_z_zero) $smt_builtin_z_zero
     ($smt_apply_3 "ite" ($smt_apply_= w $smt_builtin_z_one)
       ($smt_apply_3 "ite"
        ($smt_builtin_and
          ($smt_apply_= n1 $smt_builtin_z_one)
          ($smt_apply_= n2 $smt_builtin_z_one))
        $smt_builtin_z_one $smt_builtin_z_zero)
       ($smt_builtin_add
         ($smtx_binary_and ($smt_apply_2 "-" w $smt_builtin_z_one) n1 n2)
         ($smt_builtin_mul ($smtx_pow2 w)
            ($smt_apply_3 "ite" ($smt_builtin_and ($smtx_bit n1 w) ($smtx_bit n2 w)) $smt_builtin_z_one $smt_builtin_z_zero))))))
  )
)

; program: $smtx_binary_or
; return: >
;   The integer value of the binary value obtained by taking the bitwise or of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This is equal to
;   n1+n2-($smtx_binary_and w n1 n2). This value will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w.
(program $smtx_binary_or ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_or w n1 n2)
    ($smt_apply_3 "+" n1 n2 ($smt_builtin_neg ($smtx_binary_and w n1 n2))))
  )
)

; program: $smtx_binary_xor
; return: >
;   The integer value of the binary value obtained by taking the bitwise xor of
;   binary literals ($eo_binary w n1) and ($eo_binary w n2). This is equal to
;   n1+n2-(2*($smtx_binary_and w n1 n2)). This value will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n1 < 2^w, 0 <= n2 < 2^w.
(program $smtx_binary_xor ((w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_xor w n1 n2)
    ($smt_apply_3 "+" n1 n2 ($smt_builtin_neg ($smt_apply_1 "* 2" ($smtx_binary_and w n1 n2)))))
  )
)

; program: $smtx_binary_not
; return: >
;   The integer value of the binary value obtained by taking bitwise not of
;   the binary literal ($eo_binary w n). This is equal to 2^w-(1+n). This value
;   will be taken modulo 2^w.
; note: >
;   Assumes that 0 <= n < 2^w.
(program $smtx_binary_not ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_not w n)
    ($smt_apply_2 "-" ($smtx_pow2 w) ($smt_apply_1 "+ 1" n)))
  )
)

; program: $smtx_binary_max
; return: >
;   The integer value of the maximum unsigned binary value of width w. This is
;   equal to 1-2^w. This value will be taken modulo 2^w.
(program $smtx_binary_max ((w $smt_builtin_Int))
  :signature ($smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_max w) ($smt_apply_1 "- 1" ($smtx_pow2 w)))
  )
)

; program: $smtx_binary_concat
; return: >
;   The integer value of the binary value obtained by concatenating binary
;   literals ($eo_binary w1 n1) and ($eo_binary w2 n2). This is equal to
;   n1*2^w2 + n2. Note the return value does not depend on w1. This value will
;   be taken modulo 2^(w1+w2).
; note: >
;   Assumes that 0 <= n1 < 2^w1, 0 <= n2 < 2^w2.
(program $smtx_binary_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_concat w1 n1 w2 n2)
    ($smt_builtin_add ($smt_builtin_mul n1 ($smtx_pow2 w2)) n2))
  )
)

; program: $smtx_binary_extract
; return: >
;   The integer value of the binary value obtained by extracting bits x1
;   through x2 (inclusive) of binary literal ($eo_binary w n). This is equal
;   to (div n 2^x1). This value will be taken modulo 2^(1+x2-x1).
; note: >
;   Assumes that 0 <= n < 2^w, 0 <= x1 <= x2.
(program $smtx_binary_extract
  ((w $smt_builtin_Int) (n $smt_builtin_Int) (x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int $smt_builtin_Int $smt_builtin_Int) $smt_builtin_Int
  (
  (($smtx_binary_extract w n x1 x2) ($smt_builtin_div n ($smtx_pow2 x1)))
  )
)

;;; Utilities

(define $eo_mk_bool ((x $smt_builtin_Bool))
  ($eo_smt_term ($sm_mk_bool x)))
(define $eo_mk_numeral ((x $smt_builtin_Int))
  ($eo_smt_term ($sm_mk_z x)))
(define $eo_mk_rational ((x $smt_builtin_Real))
  ($eo_smt_term ($sm_mk_q x)))
(define $eo_mk_string ((x $smt_builtin_String))
  ($eo_smt_term ($sm_mk_str x)))

; define: $eo_binary
; note: >
;   This should be used in pattern matching only, where it is assume that
;   it will match "legal" binary values only.
(define $eo_binary ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int))
  ($eo_smt_term ($sm_mk_binary x1 x2)))

; define: $eo_empty_binary
(define $eo_empty_binary ()
  ($eo_binary $smt_builtin_z_zero $smt_builtin_z_zero))

; program: $eo_mk_binary
; return: >
;   A "legal" binary value ($eo_mk_binary w n1), where 0 <= n1 < 2^w, n1 is
;   congruent mod 2^w to n if w is a 32-bit numeral value, or stuck otherwise.
; note: >
;   All binaries considered by Eunoia should run through this method to ensure
;   they are legal.
(program $eo_mk_binary ((w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($smt_builtin_Int $smt_builtin_Int) $eo_Term
  (
  (($eo_mk_binary w n)
    ($smt_apply_3 "ite"
      ($smt_builtin_and ($smt_apply_1 "<= 0" w) ($smt_apply_1 ">= 4294967296" w))
      ($eo_binary w ($smt_builtin_mod n ($smtx_pow2 w)))
      $eo_stuck))
  )
)

;;;;;; Eunoia builtin

; We are now ready to define the builtins of Eunoia.
; We define all the Eunoia builtins here that are best to
; define in terms of SMT-LIB operators.

;;; Is okay

; Returns SMT-LIB builtin true/false if x is stuck
(define $smt_builtin_is_ok ((x $eo_Term))
  ($smt_apply_1 "not" ($smt_apply_= x $eo_stuck)))

; program: $eo_is_ok
; implements: $eo_is_ok
(define $eo_is_ok ((x $eo_Term))
  ($eo_mk_bool ($smt_builtin_is_ok x)))

; program: $eo_ite
; implements: $eo_ite
; note: This definition is only used if we are not eagerly flattening evaluation
(define $eo_ite ((x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term))
  ($smt_apply_3 "ite" ($smt_apply_= x1 true)
    x2
  ($smt_apply_3 "ite" ($smt_apply_= x1 false)
    x3
    $eo_stuck)))

; program: $eo_requires
; implements: $eo_requires
; note: This definition is only used if we are not eagerly flattening evaluation
(define $eo_requires ((x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term))
  ($smt_apply_3 "ite" ($smt_apply_= x1 x2)
    ($smt_apply_3 "ite" ($smt_builtin_is_ok x1) x3 x1)
    $eo_stuck))

; note: This definition is only used if we are not eagerly flattening evaluation
; This ensures that stuckness "propagates" through ordinary constant applications.
(program $eo_mk_apply ((x1 $eo_Term) (x2 $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_mk_apply x1 x2) ($eo_apply x1 x2))
  )
)

;;; Boolean operators

; program: $eo_not
; implements: $eo_not
(program $eo_not ((T Type) (b $smt_builtin_Bool) (w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature (T) T
  (
  (($eo_not ($eo_mk_bool b))   ($eo_mk_bool ($smt_apply_1 "not" b)))
  (($eo_not ($eo_binary w n))  ($eo_mk_binary w ($smtx_binary_not w n)))
  )
)

; program: $eo_and
; implements: $eo_and
(program $eo_and
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool) (w $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_and ($eo_mk_bool b1) ($eo_mk_bool b2))
     ($eo_mk_bool ($smt_apply_2 "and" b1 b2)))
  (($eo_and ($eo_binary w n1) ($eo_binary w n2))
     ($eo_mk_binary w ($smtx_binary_and w n1 n2)))
  )
)

; program: $eo_or
; implements: $eo_or
(program $eo_or
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool) (w $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_or ($eo_mk_bool b1) ($eo_mk_bool b2))
     ($eo_mk_bool ($smt_apply_2 "or" b1 b2)))
  (($eo_or ($eo_binary w n1) ($eo_binary w n2))
     ($eo_mk_binary w ($smtx_binary_or w n1 n2)))
  )
)

; program: $eo_xor
; implements: $eo_xor
(program $eo_xor
  ((T Type) (b1 $smt_builtin_Bool) (b2 $smt_builtin_Bool) (w $smt_builtin_Int)
   (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_xor ($eo_mk_bool b1) ($eo_mk_bool b2))
     ($eo_mk_bool ($smt_apply_2 "xor" b1 b2)))
  (($eo_xor ($eo_binary w n1) ($eo_binary w n2))
     ($eo_mk_binary w ($smtx_binary_or w n1 n2)))
  )
)

;;; Arithmetic operators

; program: $eo_add
; implements: $eo_add
(program $eo_add
  ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (r1 $smt_builtin_Real) (r2 $smt_builtin_Real))
  :signature (T T) T
  (
  (($eo_add ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($eo_mk_numeral ($smt_builtin_add n1 n2)))
  (($eo_add ($eo_mk_rational r1) ($eo_mk_rational r2))
    ($eo_mk_rational ($smt_builtin_add r1 r2)))
  (($eo_add ($eo_binary w n1) ($eo_binary w n2))
    ($eo_mk_binary w ($smt_builtin_add n1 n2)))
  )
)

(program $eo_mul
  ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (r1 $smt_builtin_Real) (r2 $smt_builtin_Real))
  :signature (T T) T
  (
  (($eo_mul ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($eo_mk_numeral ($smt_builtin_mul n1 n2)))
  (($eo_mul ($eo_mk_rational r1) ($eo_mk_rational r2))
    ($eo_mk_rational ($smt_builtin_mul r1 r2)))
  (($eo_mul ($eo_binary w n1) ($eo_binary w n2))
    ($eo_mk_binary w ($smt_builtin_mul n1 n2)))
  )
)

(program $eo_qdiv
  ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int)
   (r1 $smt_builtin_Real) (r2 $smt_builtin_Real))
  :signature (T T) $eo_Rational
  (
  (($eo_qdiv ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    (eo::define ((r1 ($smt_apply_1 "to_real" n1)))
    (eo::define ((r2 ($smt_apply_1 "to_real" n2)))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $eo_stuck
      ($eo_mk_rational ($smt_apply_2 "/" r1 r2))))))
  (($eo_qdiv ($eo_mk_rational r1) ($eo_mk_rational r2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0/1" r2)
      $eo_stuck
      ($eo_mk_rational ($smt_apply_2 "/" r1 r2))))
  )
)


(program $eo_zdiv ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_zdiv ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $eo_stuck
      ($eo_mk_numeral ($smt_builtin_div n1 n2))))
  (($eo_zdiv ($eo_binary w n1) ($eo_binary w n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      ($eo_mk_binary w ($smtx_binary_max w))
      ($eo_mk_binary w ($smt_builtin_div n1 n2))))
  )
)

(program $eo_zmod ((T Type) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int))
  :signature (T T) T
  (
  (($eo_zmod ($eo_mk_numeral n1) ($eo_mk_numeral n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      $eo_stuck
      ($eo_mk_numeral ($smt_builtin_mod n1 n2))))
  (($eo_zmod ($eo_binary w n1) ($eo_binary w n2))
    ($smt_apply_3 "ite" ($smt_apply_1 "= 0" n2)
      ($eo_binary w n1)
      ($eo_mk_binary w ($smt_builtin_mod n1 n2))))
  )
)

(program $eo_is_neg ((T Type) (n1 $smt_builtin_Int) (r1 $smt_builtin_Real))
  :signature (T) Bool
  (
  (($eo_is_neg ($eo_mk_numeral n1))
    ($eo_mk_bool ($smt_apply_1 "> 0" n1)))
  (($eo_is_neg ($eo_mk_rational r1))
    ($eo_mk_bool ($smt_apply_1 "> 0/1" r1)))
  )
)

; program: $eo_neg
; implements: $eo_neg
(program $eo_neg ((T Type) (n1 $smt_builtin_Int) (r1 $smt_builtin_Real))
  :signature (T) T
  (
  (($eo_neg ($eo_mk_numeral n1))
    ($eo_mk_numeral ($smt_builtin_neg n1)))
  (($eo_neg ($eo_mk_rational r1))
    ($eo_mk_rational ($smt_builtin_neg r1)))
  )
)


;;; String operators

; program: $eo_len
; implements: $eo_len
(program $eo_len ((T Type) (s1 $smt_builtin_String) (w $smt_builtin_Int) (n1 $smt_builtin_Int))
  :signature (T) $eo_Numeral
  (
  (($eo_len ($eo_mk_string s1))
    ($eo_mk_numeral ($smt_apply_1 "str.len" s1)))
  (($eo_len ($eo_binary w n1))
    ($eo_mk_numeral w))
  )
)

; program: $eo_concat
; implements: $eo_concat
(program $eo_concat
  ((w1 $smt_builtin_Int) (n1 $smt_builtin_Int) (w2 $smt_builtin_Int) (n2 $smt_builtin_Int)
   (s1 $smt_builtin_String) (s2 $smt_builtin_String))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($eo_concat ($eo_mk_string s1) ($eo_mk_string s2))
     ($eo_mk_string ($smt_apply_2 "str.++" s1 s2)))
  (($eo_concat ($eo_binary w1 n1) ($eo_binary w2 n2))
     ($eo_mk_binary ($smt_builtin_add w1 w2) ($smtx_binary_concat w1 n1 w2 n2)))
  )
)

; program: $eo_extract
; implements: $eo_extract
(program $eo_extract
  ((s1 $smt_builtin_String) (w $smt_builtin_Int) (n1 $smt_builtin_Int) (n2 $smt_builtin_Int) (n3 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($eo_extract ($eo_mk_string s1) ($eo_mk_numeral n2) ($eo_mk_numeral n3))
     ($eo_mk_string ($smt_apply_3 "str.substr" s1 n2 ($smt_apply_1 "+ 1" ($smt_apply_2 "-" n3 n2)))))
  (($eo_extract ($eo_binary w n1) ($eo_mk_numeral n2) ($eo_mk_numeral n3))
    (eo::define ((nw ($smt_apply_2 "-" n3 n2)))
    ($smt_apply_3 "ite" ($smt_builtin_or ($smt_apply_1 "> 0" n2) ($smt_apply_1 "> 0" nw))
      $eo_empty_binary
      ($eo_mk_binary
        ($smt_apply_1 "+ 1" nw)
        ($smtx_binary_extract w n1 n2 n3)))))
  )
)

; program: $eo_find
; implements: $eo_find
(program $eo_find ((s1 $smt_builtin_String) (s2 $smt_builtin_String))
  :signature ($eo_Term $eo_Term) $eo_Numeral
  (
  (($eo_find ($eo_mk_string s1) ($eo_mk_string s2))
     ($eo_mk_numeral ($smt_apply_3 "str.indexof" s1 s2 $smt_builtin_z_zero)))
  )
)

;;; Conversion operators

; program: $eo_to_z
; implements: $eo_to_z
(program $eo_to_z ((n1 $smt_builtin_Int) (r1 $smt_builtin_Real) (s1 $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Numeral
  (
  (($eo_to_z ($eo_mk_numeral n1))
    ($eo_mk_numeral n1))
  (($eo_to_z ($eo_mk_rational r1))
    ($eo_mk_numeral ($smt_apply_1 "to_int" r1)))
  (($eo_to_z ($eo_mk_string s1))
    ($smt_apply_3 "ite"
      ($smt_apply_1 "= 1" ($smt_apply_1 "str.len" s1))
      ($eo_mk_numeral ($smt_apply_1 "str.to_code" s1))
      $eo_stuck))
  (($eo_to_z ($eo_binary w n1))
    ($eo_mk_numeral n1))
  )
)

; program: $eo_to_q
; implements: $eo_to_q
(program $eo_to_q ((n1 $smt_builtin_Int) (r1 $smt_builtin_Real) (s1 $smt_builtin_String) (w $smt_builtin_Int))
  :signature ($eo_Term) $eo_Rational
  (
  (($eo_to_q ($eo_mk_numeral n1))
    ($eo_mk_rational ($smt_apply_1 "to_real" n1)))
  (($eo_to_q ($eo_mk_rational r1))
    ($eo_mk_rational r1))
  )
)

; program: $eo_to_bin
; implements: $eo_to_bin
(program $eo_to_bin ((w $smt_builtin_Int) (w1 $smt_builtin_Int) (n1 $smt_builtin_Int))
  :signature ($eo_Term $eo_Term) $eo_Binary
  (
  (($eo_to_bin ($eo_mk_numeral w) ($eo_mk_numeral n1))
    ($eo_mk_binary w n1))
  (($eo_to_bin ($eo_mk_numeral w) ($eo_binary w1 n1))
    ($eo_mk_binary w n1))
  )
)

; program: $eo_to_str
; implements: $eo_to_str
(program $eo_to_str ((n1 $smt_builtin_Int) (s1 $smt_builtin_String))
  :signature ($eo_Term) $eo_String
  (
  (($eo_to_str ($eo_mk_numeral n1))
    ($smt_apply_3 "ite"
      ($smt_builtin_and ($smt_apply_1 "<= 0" n1) ($smt_apply_1 "> 196608" n1))
      ($eo_mk_string ($smt_apply_1 "str.from_code" n1))
      $eo_stuck))
  (($eo_to_str ($eo_mk_string s1)) ($eo_mk_string s1))
  ; TODO: technically others here
  )
)

;;; $eo_is_eq

; Returns true if t and s are equivalent values (ground and fully evaluated).
; define: $eo_is_eq
; implements: $eo_is_eq
(define $eo_is_eq ((t $eo_Term) (s $eo_Term))
  ($eo_mk_bool ($smt_apply_3 "and"
    ($smt_builtin_is_ok t)
    ($smt_builtin_is_ok s)
    ($smt_apply_= s t))))

;;; $eo_is_bool

; Returns true if x is a Boolean literal.
; define: $eo_is_bool
; implements: $eo_is_bool
(program $eo_is_bool ((x $eo_Term) (b $smt_builtin_Bool))
  :signature ($eo_Term) Bool
  (
  (($eo_is_bool ($eo_mk_bool b))  true)
  (($eo_is_bool x)                false)
  )
)

;;; Conversion operators

;;; $eo_is_z

; Returns true if x is a numeral literal.
; define: $eo_is_z
; implements: $eo_is_z
(program $eo_is_z ((x $eo_Term) (n $smt_builtin_Int))
  :signature ($eo_Term) Bool
  (
  (($eo_is_z ($eo_mk_numeral n))  true)
  (($eo_is_z x)                   false)
  )
)

;;; $eo_is_q

; Returns true if x is a rational literal.
; define: $eo_is_q
; implements: $eo_is_q
(program $eo_is_q ((x $eo_Term) (r $smt_builtin_Real))
  :signature ($eo_Term) Bool
  (
  (($eo_is_q ($eo_mk_rational r))  true)
  (($eo_is_q x)                   false)
  )
)

;;; $eo_is_bin

; Returns true if x is a binary literal.
; define: $eo_is_bin
; implements: $eo_is_bin
(program $eo_is_bin ((x $eo_Term) (w $smt_builtin_Int) (n $smt_builtin_Int))
  :signature ($eo_Term) Bool
  (
  (($eo_is_bin ($eo_binary w n))  true)
  (($eo_is_bin x)                 false)
  )
)

;;; $eo_is_str

; Returns true if x is a string literal.
; define: $eo_is_str
; implements: $eo_is_str
(program $eo_is_str ((x $eo_Term) (s $smt_builtin_String))
  :signature ($eo_Term) Bool
  (
  (($eo_is_str ($eo_mk_string s)) true)
  (($eo_is_str x)                 false)
  )
)

;;; Derived arithmetic

; fwd-decl: $eo_hash
; Note: $eo_hash is defined axiomatically in the final smt2 encoding.
(program $eo_hash () :signature ($eo_Term) $eo_Term)

; fwd-decl: $eo_reverse_hash
(program $eo_reverse_hash () :signature ($eo_Term) $eo_Term)

;;; $eo_gt

; Compare arithmetic greater than. Assumes x and y are values.
; Returns true if x > y.
; define: $eo_gt
; implements: $eo_gt
(define $eo_gt ((x $eo_Term) (y $eo_Term))
  ($eo_is_neg ($eo_add ($eo_neg x) y)))


;;; $eo_cmp

; An arbitrary deterministic comparison of terms. Returns true if a > b based
; on this ordering.
; define: $eo_cmp
; implements: $eo_cmp
(define $eo_cmp ((a $eo_Term) (b $eo_Term))
  ($eo_is_neg ($eo_add ($eo_hash b) ($eo_neg ($eo_hash a)))))

;;; since eo_typeof depends on literal predicates, typeof is only now ready.

; program: $eo_var
; implements: $eo_var
(program $eo_var ((s $smt_builtin_String) (T $eo_Term))
  :signature ($eo_String $eo_Term) $eo_Term
  (
  (($eo_var ($eo_mk_string s) T)
    ; we use the hash of the type T to identify the variable
    ($eo_requires_eq ($eo_typeof T) Type ($eo_Var s ($eo_hash T))))
  )
)

; program: $eo_nameof
; implements: $eo_nameof
(program $eo_nameof ((s $smt_builtin_String) (T $eo_Term))
  :signature ($eo_Term) $eo_String
  (
  (($eo_nameof ($eo_Var s T)) ($eo_mk_string s))
  )
)

; Returns true if x is a variable.
; define: $eo_is_var
; implements: $eo_is_var
(define $eo_is_var ((x $eo_Term))
  ($eo_is_eq ($eo_var ($eo_nameof x) ($eo_typeof x)) x))

; fwd-decl: $eo_typeof_main
; note: This method returns the type for all user defined terms.
(program $eo_typeof_main () :signature ($eo_Term) Type)

; program: $eo_typeof
; implements: $eo_typeof
(program $eo_typeof
  ((t $eo_Term) (T $eo_Term) (b $smt_builtin_Bool) (n $smt_builtin_Int) (r $smt_builtin_Real)
   (s $smt_builtin_String) (w $smt_builtin_Int) (val $smt_Value))
  :signature ($eo_Term) $eo_Term
  (
  ; TODO: auto-generate these?
  (($eo_typeof ($eo_mk_bool b))                 Bool)
  (($eo_typeof ($eo_mk_numeral n))              $eo_Numeral)
  (($eo_typeof ($eo_mk_rational r))             $eo_Rational)
  (($eo_typeof ($eo_mk_string s))               $eo_String)
  (($eo_typeof ($eo_binary w n))                $eo_Binary)
  (($eo_typeof ($eo_Var s n))                   ($eo_reverse_hash ($eo_mk_numeral n)))
  ; otherwise, invoke the routine for builtin types from the signature.
  ; Note that we do not include SMT-LIB specific constructs here, as these are
  ; not modelled in Eunoia's builtin typeof method.
  (($eo_typeof t)                               ($eo_typeof_main t))
  )
)
(declare-const $eo_List Type)
(declare-const $eo_List_nil $eo_List)
(declare-parameterized-const $eo_List_cons ((T Type :implicit))
  (-> T $eo_List $eo_List)
  :right-assoc-nil $eo_List_nil)
(define $eo_Option_null () $eo_List_nil)
(define $eo_Option_some ((T Type :implicit) (t T)) ($eo_List_cons t $eo_List_nil))
(define $eo_Option () $eo_List)
(program $eo_eq ((T Type) (S Type) (t T) (s S))
  :signature (T S) Bool
  (
  (($eo_eq t t) true)
  (($eo_eq t s) false)
  )
)
(program $eo_is_list_rec
  ((T Type) (U Type) (V Type) (W Type) (X Type)
   (f (-> T U V)) (x T) (y U) (nil W) (z X))
  :signature ((-> T U V) W X) Bool
  (
  (($eo_is_list_rec f nil (f x y)) ($eo_is_list_rec f nil y))
  (($eo_is_list_rec f nil nil)     true)
  (($eo_is_list_rec f nil z)       false)
  )
)
(define $eo_is_list
  ((T Type :implicit) (U Type :implicit) (V Type :implicit) (W Type :implicit)
   (f (-> T U V)) (x W))
  ($eo_is_list_rec f ($eo_nil f ($eo_typeof x)) x))
(define $eo_cons
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (W1 Type :implicit) (W2 Type :implicit)
   (f (-> T U V)) (e W1) (a W2))
  ($eo_requires_eq ($eo_is_list f a) true (f e a)))
(program $eo_list_concat_rec
  ((T Type) (U Type) (V Type) (W Type) (f (-> T V V)) (x W) (y U) (z U) (nil U))
  :signature ((-> T V V) U U) U
  (
  (($eo_list_concat_rec f (f x y) z)  (f x ($eo_list_concat_rec f y z)))
  (($eo_list_concat_rec f nil z)      z)
  )
)
(define $eo_list_concat
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (f (-> T V V)) (a U) (b U))
  ($eo_requires_eq ($eo_is_list f a) true
  ($eo_requires_eq ($eo_is_list f b) true
    ($eo_list_concat_rec f a b))))
(program $eo_list_rev_rec
  ((T Type) (U Type) (V Type) (W Type)
   (f (-> T V V)) (x W) (y U) (nil U) (acc U))
  :signature ((-> T V V) U U) U
  (
    (($eo_list_rev_rec f (f x y) acc) ($eo_list_rev_rec f y (f x acc)))
    (($eo_list_rev_rec f nil acc)      acc)
  )
)
(define $eo_list_rev
  ((T Type :implicit) (U Type :implicit) (V Type :implicit)
   (f (-> T V V)) (a U))
  ($eo_requires_eq ($eo_is_list f a) true
    ($eo_list_rev_rec f a ($eo_nil f ($eo_typeof a)))))
(declare-const @Pair (-> Type (-> Type Type)))
(declare-parameterized-const @pair ((U Type :implicit) ($eo_x_1 U) (T Type :implicit) ($eo_x_2 T)) (_ (@Pair U) T))
(program $pair_first ((S Type) (T Type) (s S) (t T))
  :signature ((_ (@Pair T) S)) T
  (
  (($pair_first (_ (@pair t) s)) t)
  )
)
(program $pair_second ((T Type) (S Type) (t T) (s S))
  :signature ((_ (@Pair T) S)) S
  (
  (($pair_second (_ (@pair t) s)) s)
  )
)
(declare-parameterized-const ite (($eo_x_1 Bool) (A Type :implicit) ($eo_x_2 A) ($eo_x_3 A)) A)
(declare-const not (-> Bool Bool))
(declare-const or (-> Bool (-> Bool Bool)))
(declare-const and (-> Bool (-> Bool Bool)))
(declare-const => (-> Bool (-> Bool Bool)))
(declare-const xor (-> Bool (-> Bool Bool)))
(declare-parameterized-const = ((A Type :implicit) ($eo_x_1 A) ($eo_x_2 A)) Bool)
(program $arith_typeunion ()
  :signature (Type Type) Type
  (
  (($arith_typeunion Int Int) Int)
  (($arith_typeunion Real Real) Real)
  (($arith_typeunion Real Int) Real)
  (($arith_typeunion Int Real) Real)
  )
)
(program $is_arith_type ()
  :signature (Type) Bool
  (
  (($is_arith_type Int) true)
  (($is_arith_type Real) true)
  )
)
(declare-parameterized-const + ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) ($arith_typeunion T U))
(declare-parameterized-const - ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) ($arith_typeunion T U))
(declare-parameterized-const * ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) ($arith_typeunion T U))
(declare-parameterized-const < ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
(declare-parameterized-const <= ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
(declare-parameterized-const > ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
(declare-parameterized-const >= ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Bool)
(declare-parameterized-const to_real ((T Type :implicit) ($eo_x_1 T)) Real)
(declare-parameterized-const to_int ((T Type :implicit) ($eo_x_1 T)) Int)
(declare-parameterized-const is_int ((T Type :implicit) ($eo_x_1 T)) Bool)
(declare-parameterized-const abs ((T Type :implicit) ($eo_x_1 T)) T)
(declare-parameterized-const $eoo_-.2 ((T Type :implicit) ($eo_x_1 T)) T)
(declare-const div (-> Int (-> Int Int)))
(declare-const mod (-> Int (-> Int Int)))
(declare-const int.pow2 (-> Int Int))
(declare-const int.log2 (-> Int Int))
(declare-const int.ispow2 (-> Int Bool))
(declare-const div_total (-> Int (-> Int Int)))
(declare-const mod_total (-> Int (-> Int Int)))
(declare-parameterized-const / ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Real)
(declare-parameterized-const /_total ((T Type :implicit) ($eo_x_1 T) (U Type :implicit) ($eo_x_2 U)) Real)
(program $arith_eval_int_log_2_rec ((x Int))
  :signature (Int) Int
  (
  (($arith_eval_int_log_2_rec 1) 0)
  (($arith_eval_int_log_2_rec x) ($eo_add 1 ($arith_eval_int_log_2_rec ($eo_zdiv x 2))))
  )
)
(program $arith_eval_int_pow_2_rec ((x Int))
  :signature (Int) Int
  (
  (($arith_eval_int_pow_2_rec 0) 1)
  (($arith_eval_int_pow_2_rec x) ($eo_mul 2 ($arith_eval_int_pow_2_rec ($eo_add x -1))))
  )
)
(program $arith_eval_int_is_pow_2_rec ()
  :signature (Int) Bool
)
(program $arith_eval_int_is_pow_2_rec.fev1 ((x Int))
  :signature (Int Bool) Bool
  (
  (($arith_eval_int_is_pow_2_rec.fev1 x true) ($arith_eval_int_is_pow_2_rec ($eo_zdiv x 2)))
  (($arith_eval_int_is_pow_2_rec.fev1 x false) false)
  )
)
(program $arith_eval_int_is_pow_2_rec ((x Int))
  :signature (Int) Bool
  (
  (($arith_eval_int_is_pow_2_rec 1) true)
  (($arith_eval_int_is_pow_2_rec x) ($arith_eval_int_is_pow_2_rec.fev1 x ($eo_eq ($eo_zmod x 2) 0)))
  )
)
(declare-const BitVec (-> Int Type))
(program $bv_bitwidth ((n Int))
  :signature (Type) Int
  (
  (($bv_bitwidth (BitVec n)) n)
  )
)
(declare-parameterized-const @bvsize ((m Int :implicit) ($eo_x_1 (BitVec m))) Int)
(declare-parameterized-const concat ((n Int :implicit) ($eo_x_1 (BitVec n)) (m Int :implicit) ($eo_x_2 (BitVec m))) (BitVec ($eo_add n m)))
(declare-parameterized-const extract ((h Int) (l Int) (n Int :implicit) ($eo_x_1 (BitVec n))) (BitVec ($eo_add 1 ($eo_neg l))))
(declare-parameterized-const repeat ((i Int) (n Int :implicit) ($eo_x_1 (BitVec n))) (BitVec ($eo_mul i n)))
(declare-parameterized-const bvnot ((m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec m))
(declare-parameterized-const bvand ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvor ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvxor ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvneg ((m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec m))
(declare-parameterized-const bvadd ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvmul ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvudiv ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvurem ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvsub ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvult ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvule ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvugt ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvuge ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvslt ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvsle ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvsgt ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvsge ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) Bool)
(declare-parameterized-const bvshl ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvlshr ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const bvashr ((m Int :implicit) ($eo_x_1 (BitVec m)) ($eo_x_2 (BitVec m))) (BitVec m))
(declare-parameterized-const zero_extend ((i Int) (m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec ($eo_add m i)))
(declare-parameterized-const sign_extend ((i Int) (m Int :implicit) ($eo_x_1 (BitVec m))) (BitVec ($eo_add m i)))
(declare-parameterized-const @bv ((value Int) (w Int)) (BitVec w))
(program $bv_unfold_repeat_rec.fev1 ((m Int) (n Int) ($eo_1 Int))
  :signature (Int Int Int) Type
  (
  (($bv_unfold_repeat_rec.fev1 m n $eo_1) (BitVec $eo_1))
  )
)
(program $bv_unfold_repeat_rec ((m Int) (n Int) (b (BitVec m)))
  :signature ((eo::quote n) (BitVec m)) ($bv_unfold_repeat_rec.fev1 m n ($eo_mul n m))
  (
  (($bv_unfold_repeat_rec 0 b) ($eo_to_bin 0 0))
  (($bv_unfold_repeat_rec n b) ($eo_cons concat b ($bv_unfold_repeat_rec ($eo_add n -1) b)))
  )
)
(declare-parameterized-const seq.empty ((T Type :implicit)) (Seq T))
(program $seq_empty ((T Type))
  :signature ((eo::quote T)) T
  (
  (($seq_empty (Seq Char)) "")
  (($seq_empty T) (as seq.empty T))
  )
)
(declare-parameterized-const str.len ((T Type :implicit) ($eo_x_1 (Seq T))) Int)
(declare-parameterized-const str.++ ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) (Seq T))
(declare-parameterized-const str.substr ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 Int) ($eo_x_3 Int)) (Seq T))
(declare-parameterized-const str.contains ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) Bool)
(declare-parameterized-const str.replace ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T)) ($eo_x_3 (Seq T))) (Seq T))
(declare-parameterized-const str.indexof ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T)) ($eo_x_3 Int)) Int)
(declare-parameterized-const str.at ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 Int)) (Seq T))
(declare-parameterized-const str.prefixof ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) Bool)
(declare-parameterized-const str.suffixof ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T))) Bool)
(declare-parameterized-const str.rev ((T Type :implicit) ($eo_x_1 (Seq T))) (Seq T))
(declare-parameterized-const str.update ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 Int) ($eo_x_3 (Seq T))) (Seq T))
(declare-const str.to_lower (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
(declare-const str.to_upper (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
(declare-const str.to_code (-> (Seq Char) Int))
(declare-const str.from_code (-> Int (Seq Char)))
(declare-const str.to_int (-> (Seq Char) Int))
(declare-const str.from_int (-> Int (Seq Char)))
(declare-const str.<= (eo::define ((_v0 (Seq Char))) (-> _v0 (-> _v0 Bool))))
(declare-parameterized-const str.replace_all ((T Type :implicit) ($eo_x_1 (Seq T)) ($eo_x_2 (Seq T)) ($eo_x_3 (Seq T))) (Seq T))
(program $str_nary_intro.fev1 ((T Type) (t (Seq T)))
  :signature ((Seq T) Bool) (Seq T)
  (
  (($str_nary_intro.fev1 t true) t)
  (($str_nary_intro.fev1 t false) ($eo_cons str.++ t ($seq_empty ($eo_typeof t))))
  )
)
(program $str_nary_intro ((T Type) (ss (Seq T)) (t (Seq T)))
  :signature ((Seq T)) (Seq T)
  (
  (($str_nary_intro (_ (str.++ t) ss)) (_ (str.++ t) ss))
  (($str_nary_intro t) ($str_nary_intro.fev1 t ($eo_eq t ($seq_empty ($eo_typeof t)))))
  )
)
(program $str_nary_elim.fev2 ((T Type) ($eo_3 (Seq T)) (t (Seq T)))
  :signature ((Seq T) (Seq T) (Seq T)) (Seq T)
  (
  (($str_nary_elim.fev2 t $eo_3 $eo_3) t)
  )
)
(program $str_nary_elim.fev1 ((T Type) (t (Seq T)) (ss (Seq T)))
  :signature ((Seq T) (Seq T) Bool) (Seq T)
  (
  (($str_nary_elim.fev1 ss t true) t)
  (($str_nary_elim.fev1 ss t false) (_ (str.++ t) ss))
  )
)
(program $str_nary_elim ((T Type) (ss (Seq T)) (t (Seq T)))
  :signature ((Seq T)) (Seq T)
  (
  (($str_nary_elim (_ (str.++ t) ss)) ($str_nary_elim.fev1 ss t ($eo_eq ss ($seq_empty ($eo_typeof t)))))
  (($str_nary_elim t) ($str_nary_elim.fev2 t t ($seq_empty ($eo_typeof t))))
  )
)
(program $str_flatten_word ((U Type) (t (Seq U)))
  :signature ((Seq U)) (Seq U)
  (
  (($str_flatten_word "") "")
  (($str_flatten_word t) ($eo_cons str.++ ($eo_extract t 0 0) ($str_flatten_word ($eo_extract t 1 ($eo_len t)))))
  )
)
(program $str_flatten ((U Type))
  :signature ((Seq U)) (Seq U)
)
(program $str_flatten.fev2 ((U Type) ($eo_3 (Seq U)) (t (Seq U)))
  :signature ((Seq U) (Seq U) (Seq U)) (Seq U)
  (
  (($str_flatten.fev2 t $eo_3 $eo_3) t)
  )
)
(program $str_flatten.fev1 ((U Type) (t (Seq U)) (tail (Seq U)))
  :signature ((Seq U) (Seq U) Bool) (Seq U)
  (
  (($str_flatten.fev1 tail t true) ($eo_list_concat str.++ ($str_flatten_word t) ($str_flatten tail)))
  (($str_flatten.fev1 tail t false) ($eo_cons str.++ t ($str_flatten tail)))
  )
)
(program $str_flatten ((U Type) (tail (Seq U)) (t (Seq U)))
  :signature ((Seq U)) (Seq U)
  (
  (($str_flatten (_ (str.++ t) tail)) ($str_flatten.fev1 tail t ($eo_is_eq ($eo_is_neg ($eo_add 1 ($eo_neg ($eo_len t)))) true)))
  (($str_flatten t) ($str_flatten.fev2 t t ($seq_empty ($eo_typeof t))))
  )
)
(program $str_collect_acc ((U Type))
  :signature ((Seq U)) (eo::define ((_v0 (Seq U))) (_ (@Pair _v0) _v0))
)
(program $str_collect_acc.fev4 ((U Type) (tail (Seq U)) (t (Seq U)) ($eo_5 (Seq U)) ($eo_4 (Seq U)))
  :signature ((Seq U) (Seq U) (Seq U) (Seq U)) (eo::define ((_v0 (Seq U))) (_ (@Pair _v0) _v0))
  (
  (($str_collect_acc.fev4 tail t $eo_4 $eo_5) (_ (@pair $eo_5) $eo_4))
  )
)
(program $str_collect_acc.fev3 ((U Type) (tail (Seq U)) (t (Seq U)) ($eo_3 (Seq U)))
  :signature ((Seq U) (Seq U) (Seq U)) (eo::define ((_v0 (Seq U))) (_ (@Pair _v0) _v0))
  (
  (($str_collect_acc.fev3 tail t $eo_3) (_ (@pair t) $eo_3))
  )
)
(program $str_collect_acc.fev2 ((U Type) (t (Seq U)) (tail (Seq U)))
  :signature ((Seq U) (Seq U) Bool) (eo::define ((_v0 (Seq U))) (_ (@Pair _v0) _v0))
  (
  (($str_collect_acc.fev2 tail t true) ($str_collect_acc.fev3 tail t ($pair_second ($str_collect_acc tail))))
  (($str_collect_acc.fev2 tail t false) (eo::define ((_v0 ($str_collect_acc tail))) ($str_collect_acc.fev4 tail t ($pair_second _v0) ($eo_concat t ($pair_first _v0)))))
  )
)
(program $str_collect_acc.fev1 ((U Type) (t (Seq U)) (tail (Seq U)))
  :signature ((Seq U) (Seq U) Bool) (eo::define ((_v0 (Seq U))) (_ (@Pair _v0) _v0))
  (
  (($str_collect_acc.fev1 tail t true) ($str_collect_acc.fev2 tail t ($eo_eq ($pair_first ($str_collect_acc tail)) "")))
  (($str_collect_acc.fev1 tail t false) (_ (@pair "") (_ (str.++ t) tail)))
  )
)
(program $str_collect_acc ((U Type) (tail (Seq U)) (t (Seq U)))
  :signature ((Seq U)) (eo::define ((_v0 (Seq U))) (_ (@Pair _v0) _v0))
  (
  (($str_collect_acc (_ (str.++ t) tail)) ($str_collect_acc.fev1 tail t ($eo_is_eq ($eo_len t) 1)))
  (($str_collect_acc "") (_ (@pair "") ""))
  )
)
(program $str_collect ((U Type))
  :signature ((Seq U)) (Seq U)
)
(program $str_collect.fev2 ((U Type) ($eo_3 (Seq U)) (t (Seq U)))
  :signature ((Seq U) (Seq U) (Seq U)) (Seq U)
  (
  (($str_collect.fev2 t $eo_3 $eo_3) t)
  )
)
(program $str_collect.fev1 ((U Type) (t (Seq U)) (s (Seq U)))
  :signature ((Seq U) (Seq U) Bool) (Seq U)
  (
  (($str_collect.fev1 s t true) ($eo_cons str.++ t ($str_collect s)))
  (($str_collect.fev1 s t false) (eo::define ((_v0 ($str_collect_acc (_ (str.++ t) s)))) ($eo_cons str.++ ($pair_first _v0) ($str_collect ($pair_second _v0)))))
  )
)
(program $str_collect ((U Type) (s (Seq U)) (t (Seq U)))
  :signature ((Seq U)) (Seq U)
  (
  (($str_collect (_ (str.++ t) s)) ($str_collect.fev1 s t ($eo_eq ($pair_first ($str_collect_acc (_ (str.++ t) s))) "")))
  (($str_collect t) ($str_collect.fev2 t t ($seq_empty ($eo_typeof t))))
  )
)
(program $str_from_int_eval_rec ()
  :signature (Int (Seq Char)) (Seq Char)
)
(program $str_from_int_eval_rec.fev2 ((s (Seq Char)))
  :signature ((Seq Char) Bool) (Seq Char)
  (
  (($str_from_int_eval_rec.fev2 s true) "0")
  (($str_from_int_eval_rec.fev2 s false) s)
  )
)
(program $str_from_int_eval_rec.fev1 ((n Int) (s (Seq Char)))
  :signature ((Seq Char) Int Bool) (Seq Char)
  (
  (($str_from_int_eval_rec.fev1 s n true) ($str_from_int_eval_rec.fev2 s ($eo_eq s "")))
  (($str_from_int_eval_rec.fev1 s n false) ($str_from_int_eval_rec ($eo_zdiv n 10) ($eo_concat ($eo_to_str ($eo_add 48 ($eo_zmod n 10))) s)))
  )
)
(program $str_from_int_eval_rec ((s (Seq Char)) (n Int))
  :signature (Int (Seq Char)) (Seq Char)
  (
  (($str_from_int_eval_rec n s) ($str_from_int_eval_rec.fev1 s n ($eo_eq n 0)))
  )
)
(program $str_to_int_eval_rec ()
  :signature ((Seq Char) Int Int) Int
)
(program $str_to_int_eval_rec.fev1 ((n Int) (e Int) (s1 (Seq Char)) (s2 (Seq Char)))
  :signature (Int Int (Seq Char) (Seq Char) Bool) Int
  (
  (($str_to_int_eval_rec.fev1 n e s1 s2 true) ($str_to_int_eval_rec s2 ($eo_mul e 10) ($eo_add ($eo_mul ($eo_add ($eo_to_z s1) -48) e) n)))
  (($str_to_int_eval_rec.fev1 n e s1 s2 false) -1)
  )
)
(program $str_to_int_eval_rec ((s2 (Seq Char)) (s1 (Seq Char)) (e Int) (n Int))
  :signature ((Seq Char) Int Int) Int
  (
  (($str_to_int_eval_rec (_ (str.++ s1) s2) e n) (eo::define ((_v0 ($eo_add ($eo_to_z s1) -48))) ($str_to_int_eval_rec.fev1 n e s1 s2 ($eo_and ($eo_gt 10 _v0) ($eo_not ($eo_is_neg _v0))))))
  (($str_to_int_eval_rec "" e n) n)
  )
)
(program $str_case_conv_rec ()
  :signature ((Seq Char) Bool) (Seq Char)
)
(program $str_case_conv_rec.fev4 ((s2 (Seq Char)) (s1 (Seq Char)))
  :signature ((Seq Char) (Seq Char) Bool) Int
  (
  (($str_case_conv_rec.fev4 s2 s1 true) -32)
  (($str_case_conv_rec.fev4 s2 s1 false) 0)
  )
)
(program $str_case_conv_rec.fev3 ((s2 (Seq Char)) (s1 (Seq Char)) ($eo_6 Int) ($eo_5 Int) ($eo_4 (Seq Char)))
  :signature ((Seq Char) (Seq Char) (Seq Char) Int Int) (Seq Char)
  (
  (($str_case_conv_rec.fev3 s2 s1 $eo_4 $eo_5 $eo_6) ($eo_concat ($eo_to_str ($eo_add $eo_6 $eo_5)) $eo_4))
  )
)
(program $str_case_conv_rec.fev2 ((s2 (Seq Char)) (s1 (Seq Char)))
  :signature ((Seq Char) (Seq Char) Bool) Int
  (
  (($str_case_conv_rec.fev2 s2 s1 true) 32)
  (($str_case_conv_rec.fev2 s2 s1 false) 0)
  )
)
(program $str_case_conv_rec.fev1 ((s2 (Seq Char)) (s1 (Seq Char)) ($eo_3 Int) ($eo_2 Int) ($eo_1 (Seq Char)))
  :signature ((Seq Char) (Seq Char) (Seq Char) Int Int) (Seq Char)
  (
  (($str_case_conv_rec.fev1 s2 s1 $eo_1 $eo_2 $eo_3) ($eo_concat ($eo_to_str ($eo_add $eo_3 $eo_2)) $eo_1))
  )
)
(program $str_case_conv_rec ((s2 (Seq Char)) (s1 (Seq Char)) (isLower Bool))
  :signature ((Seq Char) Bool) (Seq Char)
  (
  (($str_case_conv_rec (_ (str.++ s1) s2) true) (eo::define ((_v0 ($eo_to_z s1))) ($str_case_conv_rec.fev1 s2 s1 ($str_case_conv_rec s2 true) ($str_case_conv_rec.fev2 s2 s1 ($eo_and ($eo_gt 91 _v0) ($eo_gt _v0 64))) _v0)))
  (($str_case_conv_rec (_ (str.++ s1) s2) false) (eo::define ((_v0 ($eo_to_z s1))) ($str_case_conv_rec.fev3 s2 s1 ($str_case_conv_rec s2 false) ($str_case_conv_rec.fev4 s2 s1 ($eo_and ($eo_gt 123 _v0) ($eo_gt _v0 96))) _v0)))
  (($str_case_conv_rec "" isLower) "")
  )
)
(program $str_leq_eval_rec ()
  :signature ((Seq Char) (Seq Char)) Bool
)
(program $str_leq_eval_rec.fev1 ((t2 (Seq Char)) (s2 (Seq Char)) (t1 (Seq Char)) (s1 (Seq Char)))
  :signature ((Seq Char) (Seq Char) (Seq Char) (Seq Char) Bool) Bool
  (
  (($str_leq_eval_rec.fev1 s1 t1 t2 s2 true) ($str_leq_eval_rec s2 t2))
  (($str_leq_eval_rec.fev1 s1 t1 t2 s2 false) ($eo_gt ($eo_to_z t1) ($eo_to_z s1)))
  )
)
(program $str_leq_eval_rec ((t2 (Seq Char)) (s2 (Seq Char)) (s1 (Seq Char)) (t1 (Seq Char)))
  :signature ((Seq Char) (Seq Char)) Bool
  (
  (($str_leq_eval_rec (_ (str.++ s1) s2) (_ (str.++ t1) t2)) ($str_leq_eval_rec.fev1 s1 t1 t2 s2 ($eo_eq s1 t1)))
  (($str_leq_eval_rec "" t1) true)
  (($str_leq_eval_rec s1 t1) false)
  )
)
(program $str_eval_replace_all_rec ((n Int) (s (Seq Char)) (t (Seq Char)) (lent Int) (u (Seq Char)))
  :signature ((Seq Char) (Seq Char) (Seq Char) Int Int) (Seq Char)
  (
  (($str_eval_replace_all_rec s t u -1 lent) s)
  (($str_eval_replace_all_rec s t u n lent) (eo::define ((_v0 ($eo_extract s ($eo_add n lent) ($eo_len s)))) ($eo_concat ($str_eval_replace_all_rec _v0 t u ($eo_find _v0 t) lent) u)))
  )
)
(declare-parameterized-const int_to_bv ((w Int) ($eo_x_1 Int)) (BitVec w))
(declare-parameterized-const ubv_to_int ((m Int :implicit) ($eo_x_1 (BitVec m))) Int)
(declare-parameterized-const sbv_to_int ((m Int :implicit) ($eo_x_1 (BitVec m))) Int)
(program $run_evaluate ((S Type))
  :signature (S) S
)
(program $run_evaluate.fev47 ((m Int) (xb (BitVec m)) ($eo_55 Int))
  :signature ((BitVec m) Int) Int
  (
  (($run_evaluate.fev47 xb $eo_55) (int.pow2 $eo_55))
  )
)
(program $run_evaluate.fev46 ((m Int) (xb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev46 xb true) 0)
  (($run_evaluate.fev46 xb false) ($arith_eval_int_pow_2_rec ($bv_bitwidth ($eo_typeof xb))))
  )
)
(program $run_evaluate.fev45 ((m Int) (xb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev45 xb true) ($run_evaluate.fev46 xb ($eo_is_neg ($bv_bitwidth ($eo_typeof xb)))))
  (($run_evaluate.fev45 xb false) ($run_evaluate.fev47 xb ($bv_bitwidth ($eo_typeof xb))))
  )
)
(program $run_evaluate.fev44 ((m Int) (xb (BitVec m)) ($eo_53 Int) ($eo_52 Int))
  :signature ((BitVec m) Int Int) Int
  (
  (($run_evaluate.fev44 xb $eo_52 $eo_53) ($eo_add $eo_53 ($eo_neg $eo_52)))
  )
)
(program $run_evaluate.fev43 ((m Int) (xb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev43 xb true) ($eo_to_z ($run_evaluate xb)))
  (($run_evaluate.fev43 xb false) ($run_evaluate.fev44 xb ($run_evaluate.fev45 xb ($eo_is_z ($bv_bitwidth ($eo_typeof xb)))) ($eo_to_z ($run_evaluate xb))))
  )
)
(program $run_evaluate.fev48 (($eoT.fev57 Type) (n Int) ($eo_56 Int))
  :signature (Int Int) $eoT.fev57
  (
  (($run_evaluate.fev48 n $eo_56) (_ (repeat $eo_56) #b0))
  )
)
(program $run_evaluate.fev42 ((m Int) ($eoT.fev50 Type) (xb (BitVec m)) (n Int))
  :signature ((BitVec m) Int Bool) $eoT.fev50
  (
  (($run_evaluate.fev42 xb n true) ($bv_unfold_repeat_rec ($run_evaluate n) #b0))
  (($run_evaluate.fev42 xb n false) ($run_evaluate.fev48 n ($run_evaluate n)))
  )
)
(program $run_evaluate.fev41 ((m Int) ($eoT.fev48 Type) (xb (BitVec m)) (n Int) ($eo_49 $eoT.fev48) ($eo_47 (BitVec m)))
  :signature ((BitVec m) Int (BitVec m) $eoT.fev48) $eoT.fev48
  (
  (($run_evaluate.fev41 xb n $eo_47 $eo_49) ($eo_concat ($run_evaluate $eo_49) $eo_47))
  )
)
(program $run_evaluate.fev49 ((m Int) ($eoT.fev60 Type) (xb (BitVec m)) (n Int) ($eo_59 Int) ($eo_58 (BitVec m)))
  :signature ((BitVec m) Int (BitVec m) Int) $eoT.fev60
  (
  (($run_evaluate.fev49 xb n $eo_58 $eo_59) (_ (repeat $eo_59) $eo_58))
  )
)
(program $run_evaluate.fev40 ((m Int) ($eoT.fev46 Type) (xb (BitVec m)) (n Int))
  :signature ((BitVec m) Int Bool) $eoT.fev46
  (
  (($run_evaluate.fev40 xb n true) (eo::define ((_v0 ($run_evaluate xb))) (eo::define ((_v1 ($eo_add ($bv_bitwidth ($eo_typeof _v0)) -1))) ($bv_unfold_repeat_rec ($run_evaluate n) ($eo_extract _v0 _v1 _v1)))))
  (($run_evaluate.fev40 xb n false) (eo::define ((_v0 ($run_evaluate xb))) (eo::define ((_v1 ($eo_add ($bv_bitwidth ($eo_typeof _v0)) -1))) ($run_evaluate.fev49 xb n ($eo_extract _v0 _v1 _v1) ($run_evaluate n)))))
  )
)
(program $run_evaluate.fev39 ((m Int) ($eoT.fev44 Type) (xb (BitVec m)) (n Int) ($eo_45 $eoT.fev44) ($eo_43 (BitVec m)))
  :signature ((BitVec m) Int (BitVec m) $eoT.fev44) $eoT.fev44
  (
  (($run_evaluate.fev39 xb n $eo_43 $eo_45) ($eo_concat ($run_evaluate $eo_45) $eo_43))
  )
)
(program $run_evaluate.fev50 ((m Int) ($eoT.fev63 Type) (xb (BitVec m)) (n Int) ($eo_62 Int) ($eo_61 (BitVec m)))
  :signature ((BitVec m) Int (BitVec m) Int) $eoT.fev63
  (
  (($run_evaluate.fev50 xb n $eo_61 $eo_62) (_ (repeat $eo_62) $eo_61))
  )
)
(program $run_evaluate.fev38 ((m Int) ($eoT.fev42 Type) (xb (BitVec m)) (n Int))
  :signature ((BitVec m) Int Bool) $eoT.fev42
  (
  (($run_evaluate.fev38 xb n true) ($bv_unfold_repeat_rec ($run_evaluate n) ($run_evaluate xb)))
  (($run_evaluate.fev38 xb n false) ($run_evaluate.fev50 xb n ($run_evaluate xb) ($run_evaluate n)))
  )
)
(program $run_evaluate.fev37 ((m Int) ($eoT.fev40 Type) (xb (BitVec m)) (n Int) ($eo_41 $eoT.fev40))
  :signature ((BitVec m) Int $eoT.fev40) $eoT.fev40
  (
  (($run_evaluate.fev37 xb n $eo_41) ($run_evaluate $eo_41))
  )
)
(program $run_evaluate.fev52 ((m Int) (yb (BitVec m)) (xb (BitVec m)) ($eo_67 (BitVec m)) ($eo_66 (BitVec m)))
  :signature ((BitVec m) (BitVec m) (BitVec m) (BitVec m)) (BitVec m)
  (
  (($run_evaluate.fev52 yb xb $eo_66 $eo_67) ($run_evaluate (bvnot (_ (bvlshr (bvnot $eo_67)) $eo_66))))
  )
)
(program $run_evaluate.fev51 ((m Int) (yb (BitVec m)) (xb (BitVec m)) ($eo_65 (BitVec m)) ($eo_64 (BitVec m)))
  :signature ((BitVec m) (BitVec m) (BitVec m) (BitVec m)) (BitVec m)
  (
  (($run_evaluate.fev51 yb xb $eo_64 $eo_65) ($run_evaluate (_ (bvlshr $eo_65) $eo_64)))
  )
)
(program $run_evaluate.fev36 ((m Int) (yb (BitVec m)) (xb (BitVec m)))
  :signature ((BitVec m) (BitVec m) Bool) (BitVec m)
  (
  (($run_evaluate.fev36 yb xb true) ($run_evaluate.fev51 yb xb ($run_evaluate yb) ($run_evaluate xb)))
  (($run_evaluate.fev36 yb xb false) ($run_evaluate.fev52 yb xb ($run_evaluate yb) ($run_evaluate xb)))
  )
)
(program $run_evaluate.fev56 ((m Int) (yb (BitVec m)) ($eo_73 Int))
  :signature ((BitVec m) Int) Int
  (
  (($run_evaluate.fev56 yb $eo_73) (int.pow2 $eo_73))
  )
)
(program $run_evaluate.fev55 ((m Int) (yb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev55 yb true) 0)
  (($run_evaluate.fev55 yb false) ($arith_eval_int_pow_2_rec ($eo_to_z ($run_evaluate yb))))
  )
)
(program $run_evaluate.fev54 ((m Int) (xb (BitVec m)) (yb (BitVec m)))
  :signature ((BitVec m) (BitVec m) Bool) Int
  (
  (($run_evaluate.fev54 yb xb true) ($run_evaluate.fev55 yb ($eo_is_neg ($eo_to_z ($run_evaluate yb)))))
  (($run_evaluate.fev54 yb xb false) ($run_evaluate.fev56 yb ($eo_to_z ($run_evaluate yb))))
  )
)
(program $run_evaluate.fev53 ((m Int) ($eoT.fev71 Type) (yb (BitVec m)) (xb (BitVec m)) ($eo_70 Int) ($eo_69 Int) ($eo_68 Int))
  :signature ((BitVec m) (BitVec m) Int Int Int) $eoT.fev71
  (
  (($run_evaluate.fev53 yb xb $eo_68 $eo_69 $eo_70) ($eo_to_bin $eo_70 ($eo_zdiv $eo_69 $eo_68)))
  )
)
(program $run_evaluate.fev35 ((m Int) ($eoT.fev38 Type) (yb (BitVec m)) (xb (BitVec m)))
  :signature ((BitVec m) (BitVec m) Bool) $eoT.fev38
  (
  (($run_evaluate.fev35 yb xb true) ($eo_to_bin ($bv_bitwidth ($eo_typeof xb)) 0))
  (($run_evaluate.fev35 yb xb false) ($run_evaluate.fev53 yb xb ($run_evaluate.fev54 yb xb ($eo_is_z ($eo_to_z ($run_evaluate yb)))) ($eo_to_z ($run_evaluate xb)) ($bv_bitwidth ($eo_typeof xb))))
  )
)
(program $run_evaluate.fev60 ((m Int) (yb (BitVec m)) ($eo_79 Int))
  :signature ((BitVec m) Int) Int
  (
  (($run_evaluate.fev60 yb $eo_79) (int.pow2 $eo_79))
  )
)
(program $run_evaluate.fev59 ((m Int) (yb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev59 yb true) 0)
  (($run_evaluate.fev59 yb false) ($arith_eval_int_pow_2_rec ($eo_to_z ($run_evaluate yb))))
  )
)
(program $run_evaluate.fev58 ((m Int) (xb (BitVec m)) (yb (BitVec m)))
  :signature ((BitVec m) (BitVec m) Bool) Int
  (
  (($run_evaluate.fev58 yb xb true) ($run_evaluate.fev59 yb ($eo_is_neg ($eo_to_z ($run_evaluate yb)))))
  (($run_evaluate.fev58 yb xb false) ($run_evaluate.fev60 yb ($eo_to_z ($run_evaluate yb))))
  )
)
(program $run_evaluate.fev57 ((m Int) ($eoT.fev77 Type) (yb (BitVec m)) (xb (BitVec m)) ($eo_76 Int) ($eo_75 Int) ($eo_74 Int))
  :signature ((BitVec m) (BitVec m) Int Int Int) $eoT.fev77
  (
  (($run_evaluate.fev57 yb xb $eo_74 $eo_75 $eo_76) ($eo_to_bin $eo_76 ($eo_mul $eo_75 $eo_74)))
  )
)
(program $run_evaluate.fev34 ((m Int) ($eoT.fev35 Type) (yb (BitVec m)) (xb (BitVec m)))
  :signature ((BitVec m) (BitVec m) Bool) $eoT.fev35
  (
  (($run_evaluate.fev34 yb xb true) ($eo_to_bin ($bv_bitwidth ($eo_typeof xb)) 0))
  (($run_evaluate.fev34 yb xb false) ($run_evaluate.fev57 yb xb ($run_evaluate.fev58 yb xb ($eo_is_z ($eo_to_z ($run_evaluate yb)))) ($eo_to_z ($run_evaluate xb)) ($bv_bitwidth ($eo_typeof xb))))
  )
)
(program $run_evaluate.fev64 ((m Int) (xb (BitVec m)) ($eo_83 Int))
  :signature ((BitVec m) Int) Int
  (
  (($run_evaluate.fev64 xb $eo_83) (int.pow2 $eo_83))
  )
)
(program $run_evaluate.fev63 ((m Int) (xb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev63 xb true) 0)
  (($run_evaluate.fev63 xb false) ($arith_eval_int_pow_2_rec ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate xb))) -1)))
  )
)
(program $run_evaluate.fev62 ((m Int) (xb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev62 xb true) ($run_evaluate.fev63 xb ($eo_is_neg ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate xb))) -1))))
  (($run_evaluate.fev62 xb false) ($run_evaluate.fev64 xb ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate xb))) -1)))
  )
)
(program $run_evaluate.fev61 ((m Int) (xb (BitVec m)) ($eo_81 Int) ($eo_80 Int))
  :signature ((BitVec m) Int Int) Int
  (
  (($run_evaluate.fev61 xb $eo_80 $eo_81) ($eo_add ($eo_neg $eo_81) $eo_80))
  )
)
(program $run_evaluate.fev33 ((m Int) (yb (BitVec m)) (xb (BitVec m)))
  :signature ((BitVec m) (BitVec m) Bool) Int
  (
  (($run_evaluate.fev33 yb xb true) (eo::define ((_v0 ($run_evaluate xb))) (eo::define ((_v1 ($bv_bitwidth ($eo_typeof _v0)))) ($run_evaluate.fev61 xb ($eo_to_z ($eo_extract _v0 0 ($eo_add _v1 -2))) ($run_evaluate.fev62 xb ($eo_is_z ($eo_add _v1 -1)))))))
  (($run_evaluate.fev33 yb xb false) (eo::define ((_v0 ($run_evaluate xb))) ($eo_to_z ($eo_extract _v0 0 ($eo_add ($bv_bitwidth ($eo_typeof _v0)) -2)))))
  )
)
(program $run_evaluate.fev68 ((m Int) (yb (BitVec m)) ($eo_87 Int))
  :signature ((BitVec m) Int) Int
  (
  (($run_evaluate.fev68 yb $eo_87) (int.pow2 $eo_87))
  )
)
(program $run_evaluate.fev67 ((m Int) (yb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev67 yb true) 0)
  (($run_evaluate.fev67 yb false) ($arith_eval_int_pow_2_rec ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate yb))) -1)))
  )
)
(program $run_evaluate.fev66 ((m Int) (yb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev66 yb true) ($run_evaluate.fev67 yb ($eo_is_neg ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate yb))) -1))))
  (($run_evaluate.fev66 yb false) ($run_evaluate.fev68 yb ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate yb))) -1)))
  )
)
(program $run_evaluate.fev65 ((m Int) (yb (BitVec m)) ($eo_85 Int) ($eo_84 Int))
  :signature ((BitVec m) Int Int) Int
  (
  (($run_evaluate.fev65 yb $eo_84 $eo_85) ($eo_add ($eo_neg $eo_85) $eo_84))
  )
)
(program $run_evaluate.fev32 ((m Int) (xb (BitVec m)) (yb (BitVec m)))
  :signature ((BitVec m) (BitVec m) Bool) Int
  (
  (($run_evaluate.fev32 yb xb true) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($bv_bitwidth ($eo_typeof _v0)))) ($run_evaluate.fev65 yb ($eo_to_z ($eo_extract _v0 0 ($eo_add _v1 -2))) ($run_evaluate.fev66 yb ($eo_is_z ($eo_add _v1 -1)))))))
  (($run_evaluate.fev32 yb xb false) (eo::define ((_v0 ($run_evaluate yb))) ($eo_to_z ($eo_extract _v0 0 ($eo_add ($bv_bitwidth ($eo_typeof _v0)) -2)))))
  )
)
(program $run_evaluate.fev31 ((m Int) (yb (BitVec m)) (xb (BitVec m)) ($eo_32 Int) ($eo_31 Int))
  :signature ((BitVec m) (BitVec m) Int Int) Bool
  (
  (($run_evaluate.fev31 yb xb $eo_31 $eo_32) ($eo_or ($eo_gt $eo_32 $eo_31) ($eo_eq $eo_32 $eo_31)))
  )
)
(program $run_evaluate.fev72 ((m Int) (xb (BitVec m)) ($eo_91 Int))
  :signature ((BitVec m) Int) Int
  (
  (($run_evaluate.fev72 xb $eo_91) (int.pow2 $eo_91))
  )
)
(program $run_evaluate.fev71 ((m Int) (xb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev71 xb true) 0)
  (($run_evaluate.fev71 xb false) ($arith_eval_int_pow_2_rec ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate xb))) -1)))
  )
)
(program $run_evaluate.fev70 ((m Int) (xb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev70 xb true) ($run_evaluate.fev71 xb ($eo_is_neg ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate xb))) -1))))
  (($run_evaluate.fev70 xb false) ($run_evaluate.fev72 xb ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate xb))) -1)))
  )
)
(program $run_evaluate.fev69 ((m Int) (xb (BitVec m)) ($eo_89 Int) ($eo_88 Int))
  :signature ((BitVec m) Int Int) Int
  (
  (($run_evaluate.fev69 xb $eo_88 $eo_89) ($eo_add ($eo_neg $eo_89) $eo_88))
  )
)
(program $run_evaluate.fev30 ((m Int) (yb (BitVec m)) (xb (BitVec m)))
  :signature ((BitVec m) (BitVec m) Bool) Int
  (
  (($run_evaluate.fev30 yb xb true) (eo::define ((_v0 ($run_evaluate xb))) (eo::define ((_v1 ($bv_bitwidth ($eo_typeof _v0)))) ($run_evaluate.fev69 xb ($eo_to_z ($eo_extract _v0 0 ($eo_add _v1 -2))) ($run_evaluate.fev70 xb ($eo_is_z ($eo_add _v1 -1)))))))
  (($run_evaluate.fev30 yb xb false) (eo::define ((_v0 ($run_evaluate xb))) ($eo_to_z ($eo_extract _v0 0 ($eo_add ($bv_bitwidth ($eo_typeof _v0)) -2)))))
  )
)
(program $run_evaluate.fev76 ((m Int) (yb (BitVec m)) ($eo_95 Int))
  :signature ((BitVec m) Int) Int
  (
  (($run_evaluate.fev76 yb $eo_95) (int.pow2 $eo_95))
  )
)
(program $run_evaluate.fev75 ((m Int) (yb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev75 yb true) 0)
  (($run_evaluate.fev75 yb false) ($arith_eval_int_pow_2_rec ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate yb))) -1)))
  )
)
(program $run_evaluate.fev74 ((m Int) (yb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev74 yb true) ($run_evaluate.fev75 yb ($eo_is_neg ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate yb))) -1))))
  (($run_evaluate.fev74 yb false) ($run_evaluate.fev76 yb ($eo_add ($bv_bitwidth ($eo_typeof ($run_evaluate yb))) -1)))
  )
)
(program $run_evaluate.fev73 ((m Int) (yb (BitVec m)) ($eo_93 Int) ($eo_92 Int))
  :signature ((BitVec m) Int Int) Int
  (
  (($run_evaluate.fev73 yb $eo_92 $eo_93) ($eo_add ($eo_neg $eo_93) $eo_92))
  )
)
(program $run_evaluate.fev29 ((m Int) (xb (BitVec m)) (yb (BitVec m)))
  :signature ((BitVec m) (BitVec m) Bool) Int
  (
  (($run_evaluate.fev29 yb xb true) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($bv_bitwidth ($eo_typeof _v0)))) ($run_evaluate.fev73 yb ($eo_to_z ($eo_extract _v0 0 ($eo_add _v1 -2))) ($run_evaluate.fev74 yb ($eo_is_z ($eo_add _v1 -1)))))))
  (($run_evaluate.fev29 yb xb false) (eo::define ((_v0 ($run_evaluate yb))) ($eo_to_z ($eo_extract _v0 0 ($eo_add ($bv_bitwidth ($eo_typeof _v0)) -2)))))
  )
)
(program $run_evaluate.fev28 ((m Int) (yb (BitVec m)) (xb (BitVec m)) ($eo_30 Int) ($eo_29 Int))
  :signature ((BitVec m) (BitVec m) Int Int) Bool
  (
  (($run_evaluate.fev28 yb xb $eo_29 $eo_30) ($eo_gt $eo_30 $eo_29))
  )
)
(program $run_evaluate.fev27 ((m Int) (xb (BitVec m)) (yb (BitVec m)))
  :signature ((BitVec m) (BitVec m) Bool) (BitVec m)
  (
  (($run_evaluate.fev27 yb xb true) ($run_evaluate xb))
  (($run_evaluate.fev27 yb xb false) ($eo_zmod ($run_evaluate xb) ($run_evaluate yb)))
  )
)
(program $run_evaluate.fev80 ((m Int) (xb (BitVec m)) ($eo_100 Int))
  :signature ((BitVec m) Int) Int
  (
  (($run_evaluate.fev80 xb $eo_100) (int.pow2 $eo_100))
  )
)
(program $run_evaluate.fev79 ((m Int) (xb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev79 xb true) 0)
  (($run_evaluate.fev79 xb false) ($arith_eval_int_pow_2_rec ($bv_bitwidth ($eo_typeof xb))))
  )
)
(program $run_evaluate.fev78 ((m Int) (xb (BitVec m)))
  :signature ((BitVec m) Bool) Int
  (
  (($run_evaluate.fev78 xb true) ($run_evaluate.fev79 xb ($eo_is_neg ($bv_bitwidth ($eo_typeof xb)))))
  (($run_evaluate.fev78 xb false) ($run_evaluate.fev80 xb ($bv_bitwidth ($eo_typeof xb))))
  )
)
(program $run_evaluate.fev77 ((m Int) ($eoT.fev98 Type) (xb (BitVec m)) ($eo_97 Int) ($eo_96 Int))
  :signature ((BitVec m) Int Int) $eoT.fev98
  (
  (($run_evaluate.fev77 xb $eo_96 $eo_97) ($eo_to_bin $eo_97 ($eo_add $eo_96 -1)))
  )
)
(program $run_evaluate.fev26 ((m Int) ($eoT.fev27 Type) (xb (BitVec m)) (yb (BitVec m)))
  :signature ((BitVec m) (BitVec m) Bool) $eoT.fev27
  (
  (($run_evaluate.fev26 yb xb true) (eo::define ((_v0 ($bv_bitwidth ($eo_typeof xb)))) ($run_evaluate.fev77 xb ($run_evaluate.fev78 xb ($eo_is_z _v0)) _v0)))
  (($run_evaluate.fev26 yb xb false) ($eo_zdiv ($run_evaluate xb) ($run_evaluate yb)))
  )
)
(program $run_evaluate.fev25 ((T Type) (sy (Seq T)) (n Int) (sx (Seq T)))
  :signature ((Seq T) Int (Seq T) Bool) (Seq T)
  (
  (($run_evaluate.fev25 sx n sy true) ($run_evaluate sx))
  (($run_evaluate.fev25 sx n sy false) (eo::define ((_v0 ($run_evaluate sx))) (eo::define ((_v1 ($eo_len _v0))) (eo::define ((_v2 ($run_evaluate n))) (eo::define ((_v3 ($run_evaluate sy))) ($eo_concat ($eo_extract _v0 ($eo_add _v2 ($eo_len _v3)) _v1) ($eo_extract _v3 0 ($eo_add ($eo_add ($eo_neg _v2) _v1) -1))))))))
  )
)
(program $run_evaluate.fev81 ((T Type) (sx (Seq T)) ($eo_101 (Seq T)))
  :signature ((Seq T) (Seq T)) (Seq T)
  (
  (($run_evaluate.fev81 sx $eo_101) (str.rev $eo_101))
  )
)
(program $run_evaluate.fev24 ((T Type) (sx (Seq T)))
  :signature ((Seq T) Bool) (Seq T)
  (
  (($run_evaluate.fev24 sx true) ($str_nary_elim ($str_collect ($eo_list_rev str.++ ($str_flatten ($str_nary_intro ($run_evaluate sx)))))))
  (($run_evaluate.fev24 sx false) ($run_evaluate.fev81 sx ($run_evaluate sx)))
  )
)
(program $run_evaluate.fev82 ((ssx (Seq Char)) ($eo_102 (Seq Char)))
  :signature ((Seq Char) (Seq Char)) (Seq Char)
  (
  (($run_evaluate.fev82 ssx $eo_102) (str.to_upper $eo_102))
  )
)
(program $run_evaluate.fev23 ((ssx (Seq Char)))
  :signature ((Seq Char) Bool) (Seq Char)
  (
  (($run_evaluate.fev23 ssx true) ($str_case_conv_rec ($str_flatten ($str_nary_intro ($run_evaluate ssx))) false))
  (($run_evaluate.fev23 ssx false) ($run_evaluate.fev82 ssx ($run_evaluate ssx)))
  )
)
(program $run_evaluate.fev83 ((ssx (Seq Char)) ($eo_103 (Seq Char)))
  :signature ((Seq Char) (Seq Char)) (Seq Char)
  (
  (($run_evaluate.fev83 ssx $eo_103) (str.to_lower $eo_103))
  )
)
(program $run_evaluate.fev22 ((ssx (Seq Char)))
  :signature ((Seq Char) Bool) (Seq Char)
  (
  (($run_evaluate.fev22 ssx true) ($str_case_conv_rec ($str_flatten ($str_nary_intro ($run_evaluate ssx))) true))
  (($run_evaluate.fev22 ssx false) ($run_evaluate.fev83 ssx ($run_evaluate ssx)))
  )
)
(program $run_evaluate.fev84 ((ssy (Seq Char)) (ssx (Seq Char)) ($eo_105 (Seq Char)) ($eo_104 (Seq Char)))
  :signature ((Seq Char) (Seq Char) (Seq Char) (Seq Char)) Bool
  (
  (($run_evaluate.fev84 ssy ssx $eo_104 $eo_105) (_ (str.<= $eo_105) $eo_104))
  )
)
(program $run_evaluate.fev21 ((ssy (Seq Char)) (ssx (Seq Char)))
  :signature ((Seq Char) (Seq Char) Bool) Bool
  (
  (($run_evaluate.fev21 ssy ssx true) ($str_leq_eval_rec ($str_flatten ($str_nary_intro ($run_evaluate ssx))) ($str_flatten ($str_nary_intro ($run_evaluate ssy)))))
  (($run_evaluate.fev21 ssy ssx false) ($run_evaluate.fev84 ssy ssx ($run_evaluate ssy) ($run_evaluate ssx)))
  )
)
(program $run_evaluate.fev86 ((n Int) ($eo_107 Int))
  :signature (Int Int) (Seq Char)
  (
  (($run_evaluate.fev86 n $eo_107) (str.from_int $eo_107))
  )
)
(program $run_evaluate.fev85 ((n Int))
  :signature (Int Bool) (Seq Char)
  (
  (($run_evaluate.fev85 n true) "")
  (($run_evaluate.fev85 n false) ($str_from_int_eval_rec ($run_evaluate n) ""))
  )
)
(program $run_evaluate.fev20 ((n Int))
  :signature (Int Bool) (Seq Char)
  (
  (($run_evaluate.fev20 n true) ($run_evaluate.fev85 n ($eo_is_neg ($run_evaluate n))))
  (($run_evaluate.fev20 n false) ($run_evaluate.fev86 n ($run_evaluate n)))
  )
)
(program $run_evaluate.fev88 ((ssx (Seq Char)) ($eo_109 (Seq Char)))
  :signature ((Seq Char) (Seq Char)) Int
  (
  (($run_evaluate.fev88 ssx $eo_109) (str.to_int $eo_109))
  )
)
(program $run_evaluate.fev87 ((ssx (Seq Char)))
  :signature ((Seq Char) Bool) Int
  (
  (($run_evaluate.fev87 ssx true) -1)
  (($run_evaluate.fev87 ssx false) ($str_to_int_eval_rec ($eo_list_rev str.++ ($str_flatten ($str_nary_intro ($run_evaluate ssx)))) 1 0))
  )
)
(program $run_evaluate.fev19 ((ssx (Seq Char)))
  :signature ((Seq Char) Bool) Int
  (
  (($run_evaluate.fev19 ssx true) ($run_evaluate.fev87 ssx ($eo_eq ($run_evaluate ssx) "")))
  (($run_evaluate.fev19 ssx false) ($run_evaluate.fev88 ssx ($run_evaluate ssx)))
  )
)
(program $run_evaluate.fev90 ((n Int))
  :signature (Int Bool) Bool
  (
  (($run_evaluate.fev90 n true) true)
  (($run_evaluate.fev90 n false) ($eo_gt 196608 ($run_evaluate n)))
  )
)
(program $run_evaluate.fev91 ((n Int) ($eo_110 Bool))
  :signature (Int Bool Bool) Bool
  (
  (($run_evaluate.fev91 n $eo_110 true) ($eo_not ($eo_is_neg ($run_evaluate n))))
  (($run_evaluate.fev91 n $eo_110 false) false)
  )
)
(program $run_evaluate.fev89 ((n Int) ($eo_110 Bool))
  :signature (Int Bool) Bool
  (
  (($run_evaluate.fev89 n $eo_110) ($run_evaluate.fev91 n $eo_110 $eo_110))
  )
)
(program $run_evaluate.fev18 ((n Int))
  :signature (Int Bool) Bool
  (
  (($run_evaluate.fev18 n true) ($run_evaluate.fev89 n ($run_evaluate.fev90 n ($eo_eq 196608 ($run_evaluate n)))))
  (($run_evaluate.fev18 n false) false)
  )
)
(program $run_evaluate.fev92 ((n Int) ($eo_17 Bool))
  :signature (Int Bool Bool) (Seq Char)
  (
  (($run_evaluate.fev92 n $eo_17 true) ($eo_to_str n))
  (($run_evaluate.fev92 n $eo_17 false) "")
  )
)
(program $run_evaluate.fev17 ((n Int) ($eo_17 Bool))
  :signature (Int Bool) (Seq Char)
  (
  (($run_evaluate.fev17 n $eo_17) ($run_evaluate.fev92 n $eo_17 $eo_17))
  )
)
(program $run_evaluate.fev94 ((ssx (Seq Char)) ($eo_114 (Seq Char)))
  :signature ((Seq Char) (Seq Char)) Int
  (
  (($run_evaluate.fev94 ssx $eo_114) (str.to_code $eo_114))
  )
)
(program $run_evaluate.fev93 ((ssx (Seq Char)))
  :signature ((Seq Char) Bool) Int
  (
  (($run_evaluate.fev93 ssx true) -1)
  (($run_evaluate.fev93 ssx false) ($run_evaluate.fev94 ssx ($run_evaluate ssx)))
  )
)
(program $run_evaluate.fev16 ((ssx (Seq Char)))
  :signature ((Seq Char) Bool) Int
  (
  (($run_evaluate.fev16 ssx true) ($eo_to_z ($run_evaluate ssx)))
  (($run_evaluate.fev16 ssx false) ($run_evaluate.fev93 ssx ($eo_is_z ($eo_len ($run_evaluate ssx)))))
  )
)
(program $run_evaluate.fev96 ((T Type) (n Int) (sx (Seq T)) (sy (Seq T)))
  :signature ((Seq T) (Seq T) Int Bool) Int
  (
  (($run_evaluate.fev96 sy sx n true) (eo::define ((_v0 ($run_evaluate sx))) ($eo_find ($eo_to_str ($eo_extract _v0 n ($eo_len _v0))) ($eo_to_str ($run_evaluate sy)))))
  (($run_evaluate.fev96 sy sx n false) (eo::define ((_v0 ($run_evaluate sx))) ($eo_add n ($eo_find ($eo_to_str ($eo_extract _v0 n ($eo_len _v0))) ($eo_to_str ($run_evaluate sy))))))
  )
)
(program $run_evaluate.fev95 ((T Type) (n Int) (sx (Seq T)) (sy (Seq T)))
  :signature ((Seq T) (Seq T) Int Bool) Int
  (
  (($run_evaluate.fev95 sy sx n true) -1)
  (($run_evaluate.fev95 sy sx n false) (eo::define ((_v0 ($run_evaluate sx))) ($run_evaluate.fev96 sy sx n ($eo_is_neg ($eo_find ($eo_to_str ($eo_extract _v0 n ($eo_len _v0))) ($eo_to_str ($run_evaluate sy)))))))
  )
)
(program $run_evaluate.fev15 ((T Type) (sy (Seq T)) (n Int) (sx (Seq T)))
  :signature ((Seq T) (Seq T) Int Bool) Int
  (
  (($run_evaluate.fev15 sy sx n true) -1)
  (($run_evaluate.fev15 sy sx n false) ($run_evaluate.fev95 sy sx n ($eo_gt ($run_evaluate n) ($eo_len ($run_evaluate sx)))))
  )
)
(program $run_evaluate.fev97 ((ssz (Seq Char)) (ssx (Seq Char)) (ssy (Seq Char)))
  :signature ((Seq Char) (Seq Char) (Seq Char) Bool) (Seq Char)
  (
  (($run_evaluate.fev97 ssy ssx ssz true) ssx)
  (($run_evaluate.fev97 ssy ssx ssz false) ($str_eval_replace_all_rec ssx ssy ssz ($eo_find ssx ssy) ($eo_len ssy)))
  )
)
(program $run_evaluate.fev14 ((ssx (Seq Char)) (ssy (Seq Char)) (ssz (Seq Char)))
  :signature ((Seq Char) (Seq Char) (Seq Char) Bool) (Seq Char)
  (
  (($run_evaluate.fev14 ssz ssy ssx true) ($run_evaluate.fev97 ssy ssx ssz ($eo_eq ssy "")))
  (($run_evaluate.fev14 ssz ssy ssx false) (_ (_ (str.replace_all ssx) ssy) ssz))
  )
)
(program $run_evaluate.fev13 ((T Type) (sy (Seq T)) (sx (Seq T)) (sz (Seq T)))
  :signature ((Seq T) (Seq T) (Seq T) Bool) (Seq T)
  (
  (($run_evaluate.fev13 sz sx sy true) ($run_evaluate sx))
  (($run_evaluate.fev13 sz sx sy false) (eo::define ((_v0 ($run_evaluate sx))) (eo::define ((_v1 ($run_evaluate sy))) ($eo_concat ($eo_extract _v0 ($eo_add ($eo_find ($eo_to_str _v0) ($eo_to_str _v1)) ($eo_len _v1)) ($eo_len _v0)) ($run_evaluate sz)))))
  )
)
(program $run_evaluate.fev99 ((i1 Int) ($eo_119 Int))
  :signature (Int Int) Bool
  (
  (($run_evaluate.fev99 i1 $eo_119) (int.ispow2 $eo_119))
  )
)
(program $run_evaluate.fev98 ((i1 Int))
  :signature (Int Bool) Bool
  (
  (($run_evaluate.fev98 i1 true) false)
  (($run_evaluate.fev98 i1 false) ($arith_eval_int_is_pow_2_rec ($run_evaluate i1)))
  )
)
(program $run_evaluate.fev12 ((i1 Int))
  :signature (Int Bool) Bool
  (
  (($run_evaluate.fev12 i1 true) ($run_evaluate.fev98 i1 ($eo_is_neg ($run_evaluate i1))))
  (($run_evaluate.fev12 i1 false) ($run_evaluate.fev99 i1 ($run_evaluate i1)))
  )
)
(program $run_evaluate.fev101 ((i1 Int) ($eo_121 Int))
  :signature (Int Int) Int
  (
  (($run_evaluate.fev101 i1 $eo_121) (int.pow2 $eo_121))
  )
)
(program $run_evaluate.fev100 ((i1 Int))
  :signature (Int Bool) Int
  (
  (($run_evaluate.fev100 i1 true) 0)
  (($run_evaluate.fev100 i1 false) ($arith_eval_int_pow_2_rec ($run_evaluate i1)))
  )
)
(program $run_evaluate.fev11 ((i1 Int))
  :signature (Int Bool) Int
  (
  (($run_evaluate.fev11 i1 true) ($run_evaluate.fev100 i1 ($eo_is_neg ($run_evaluate i1))))
  (($run_evaluate.fev11 i1 false) ($run_evaluate.fev101 i1 ($run_evaluate i1)))
  )
)
(program $run_evaluate.fev102 ((i1 Int) ($eo_122 Int))
  :signature (Int Int) Int
  (
  (($run_evaluate.fev102 i1 $eo_122) (int.log2 $eo_122))
  )
)
(program $run_evaluate.fev10 ((i1 Int))
  :signature (Int Bool) Int
  (
  (($run_evaluate.fev10 i1 true) ($arith_eval_int_log_2_rec ($run_evaluate i1)))
  (($run_evaluate.fev10 i1 false) ($run_evaluate.fev102 i1 ($run_evaluate i1)))
  )
)
(program $run_evaluate.fev9 ((T Type) (x T))
  :signature (T Bool) T
  (
  (($run_evaluate.fev9 x true) ($eo_neg ($run_evaluate x)))
  (($run_evaluate.fev9 x false) ($run_evaluate x))
  )
)
(program $run_evaluate.fev8 ((i1 Int) (i2 Int))
  :signature (Int Int Bool) Int
  (
  (($run_evaluate.fev8 i2 i1 true) ($run_evaluate i1))
  (($run_evaluate.fev8 i2 i1 false) ($eo_zmod ($run_evaluate i1) ($run_evaluate i2)))
  )
)
(program $run_evaluate.fev7 ((i1 Int) (i2 Int))
  :signature (Int Int Bool) Int
  (
  (($run_evaluate.fev7 i2 i1 true) 0)
  (($run_evaluate.fev7 i2 i1 false) ($eo_zdiv ($run_evaluate i1) ($run_evaluate i2)))
  )
)
(program $run_evaluate.fev6 ((T Type) (x T) (y T))
  :signature (T T Bool) Real
  (
  (($run_evaluate.fev6 y x true) 0/1)
  (($run_evaluate.fev6 y x false) ($eo_qdiv ($eo_to_q ($run_evaluate x)) ($eo_to_q ($run_evaluate y))))
  )
)
(program $run_evaluate.fev103 ((S Type) (T Type) (x T) (ys S))
  :signature (S T Bool) Real
  (
  (($run_evaluate.fev103 ys x true) ($eo_mul ($eo_to_q ($run_evaluate x)) ($eo_to_q ($run_evaluate ys))))
  (($run_evaluate.fev103 ys x false) ($eo_mul ($run_evaluate x) ($run_evaluate ys)))
  )
)
(program $run_evaluate.fev5 ((S Type) (T Type) (x T) (ys S))
  :signature (S T Bool) Real
  (
  (($run_evaluate.fev5 ys x true) ($eo_mul ($eo_to_q ($run_evaluate x)) ($eo_to_q ($run_evaluate ys))))
  (($run_evaluate.fev5 ys x false) (eo::define ((_v0 ($run_evaluate ys))) ($run_evaluate.fev103 ys x ($eo_eq _v0 ($eo_to_q _v0)))))
  )
)
(program $run_evaluate.fev104 ((S Type) (T Type) (x T) (z S))
  :signature (S T Bool) Real
  (
  (($run_evaluate.fev104 z x true) ($eo_add ($eo_to_q ($run_evaluate x)) ($eo_to_q ($eo_neg ($run_evaluate z)))))
  (($run_evaluate.fev104 z x false) ($eo_add ($run_evaluate x) ($eo_neg ($run_evaluate z))))
  )
)
(program $run_evaluate.fev4 ((S Type) (T Type) (x T) (z S))
  :signature (S T Bool) Real
  (
  (($run_evaluate.fev4 z x true) ($eo_add ($eo_to_q ($run_evaluate x)) ($eo_to_q ($eo_neg ($run_evaluate z)))))
  (($run_evaluate.fev4 z x false) (eo::define ((_v0 ($eo_neg ($run_evaluate z)))) ($run_evaluate.fev104 z x ($eo_eq _v0 ($eo_to_q _v0)))))
  )
)
(program $run_evaluate.fev105 ((S Type) (T Type) (x T) (ys S))
  :signature (S T Bool) Real
  (
  (($run_evaluate.fev105 ys x true) ($eo_add ($eo_to_q ($run_evaluate x)) ($eo_to_q ($run_evaluate ys))))
  (($run_evaluate.fev105 ys x false) ($eo_add ($run_evaluate x) ($run_evaluate ys)))
  )
)
(program $run_evaluate.fev3 ((S Type) (T Type) (x T) (ys S))
  :signature (S T Bool) Real
  (
  (($run_evaluate.fev3 ys x true) ($eo_add ($eo_to_q ($run_evaluate x)) ($eo_to_q ($run_evaluate ys))))
  (($run_evaluate.fev3 ys x false) (eo::define ((_v0 ($run_evaluate ys))) ($run_evaluate.fev105 ys x ($eo_eq _v0 ($eo_to_q _v0)))))
  )
)
(program $run_evaluate.fev2 ((T Type) (x T) (b Bool) (y T))
  :signature (T T Bool Bool) T
  (
  (($run_evaluate.fev2 y x b true) ($run_evaluate x))
  (($run_evaluate.fev2 y x b false) ($run_evaluate y))
  )
)
(program $run_evaluate.fev110 ((T Type) (y T) (x T) ($eo_131 T) ($eo_130 T))
  :signature (T T T T) Bool
  (
  (($run_evaluate.fev110 y x $eo_130 $eo_131) (_ (= $eo_131) $eo_130))
  )
)
(program $run_evaluate.fev109 ((T Type) (y T) (x T))
  :signature (T T Bool) Bool
  (
  (($run_evaluate.fev109 y x true) ($eo_eq ($run_evaluate x) ($run_evaluate y)))
  (($run_evaluate.fev109 y x false) ($run_evaluate.fev110 y x ($run_evaluate y) ($run_evaluate x)))
  )
)
(program $run_evaluate.fev108 ((T Type) (x T) (y T))
  :signature (T T Bool) Bool
  (
  (($run_evaluate.fev108 y x true) ($eo_eq ($run_evaluate x) ($run_evaluate y)))
  (($run_evaluate.fev108 y x false) ($run_evaluate.fev109 y x ($eo_and ($eo_is_bool ($run_evaluate x)) ($eo_is_bool ($run_evaluate y)))))
  )
)
(program $run_evaluate.fev107 ((T Type) (x T) (y T))
  :signature (T T Bool) Bool
  (
  (($run_evaluate.fev107 y x true) ($eo_eq ($run_evaluate x) ($run_evaluate y)))
  (($run_evaluate.fev107 y x false) ($run_evaluate.fev108 y x ($eo_and ($eo_is_str ($run_evaluate x)) ($eo_is_str ($run_evaluate y)))))
  )
)
(program $run_evaluate.fev106 ((T Type) (x T) (y T))
  :signature (T T Bool) Bool
  (
  (($run_evaluate.fev106 y x true) ($eo_eq ($run_evaluate x) ($run_evaluate y)))
  (($run_evaluate.fev106 y x false) ($run_evaluate.fev107 y x ($eo_and ($eo_is_bin ($run_evaluate x)) ($eo_is_bin ($run_evaluate y)))))
  )
)
(program $run_evaluate.fev1 ((T Type) (x T) (y T))
  :signature (T T Bool) Bool
  (
  (($run_evaluate.fev1 y x true) ($eo_eq ($run_evaluate x) ($run_evaluate y)))
  (($run_evaluate.fev1 y x false) ($run_evaluate.fev106 y x ($eo_and ($eo_is_z ($run_evaluate x)) ($eo_is_z ($run_evaluate y)))))
  )
)
(program $run_evaluate ((S Type) (bs Bool) (b Bool) (b2 Bool) (ys S) (T Type) (y T) (i2 Int) (x T) (i1 Int) (sys (Seq T)) (sz (Seq T)) (ssz (Seq Char)) (ssy (Seq Char)) (ssx (Seq Char)) (sy (Seq T)) (sx (Seq T)) (m Int) (ybs (BitVec m)) (n Int) (zbs (BitVec n)) (yb (BitVec m)) (xb (BitVec m)) (z S))
  :signature (S) S
  (
  (($run_evaluate (_ (= x) y)) ($run_evaluate.fev1 y x ($eo_and ($eo_is_q ($run_evaluate x)) ($eo_is_q ($run_evaluate y)))))
  (($run_evaluate (not b)) ($eo_not ($run_evaluate b)))
  (($run_evaluate (_ (_ (ite b) x) y)) ($run_evaluate.fev2 y x b ($run_evaluate b)))
  (($run_evaluate (_ (or b) bs)) ($eo_or ($run_evaluate b) ($run_evaluate bs)))
  (($run_evaluate (_ (=> b) b2)) ($eo_or ($eo_not ($run_evaluate b)) ($run_evaluate b2)))
  (($run_evaluate (_ (and b) bs)) ($eo_and ($run_evaluate b) ($run_evaluate bs)))
  (($run_evaluate (_ (xor b) b2)) ($eo_xor ($run_evaluate b) ($run_evaluate b2)))
  (($run_evaluate (_ (< x) z)) ($eo_is_neg ($eo_add ($eo_to_q ($run_evaluate x)) ($eo_neg ($eo_to_q ($run_evaluate z))))))
  (($run_evaluate (_ (<= x) z)) (eo::define ((_v0 ($eo_add ($eo_to_q ($run_evaluate x)) ($eo_neg ($eo_to_q ($run_evaluate z)))))) ($eo_or ($eo_is_neg _v0) ($eo_eq _v0 0/1))))
  (($run_evaluate (_ (> x) z)) ($eo_is_neg ($eo_add ($eo_to_q ($run_evaluate z)) ($eo_neg ($eo_to_q ($run_evaluate x))))))
  (($run_evaluate (_ (>= x) z)) (eo::define ((_v0 ($eo_add ($eo_to_q ($run_evaluate z)) ($eo_neg ($eo_to_q ($run_evaluate x)))))) ($eo_or ($eo_is_neg _v0) ($eo_eq _v0 0/1))))
  (($run_evaluate (_ (+ x) ys)) (eo::define ((_v0 ($run_evaluate x))) ($run_evaluate.fev3 ys x ($eo_eq _v0 ($eo_to_q _v0)))))
  (($run_evaluate (_ (- x) z)) (eo::define ((_v0 ($run_evaluate x))) ($run_evaluate.fev4 z x ($eo_eq _v0 ($eo_to_q _v0)))))
  (($run_evaluate (_ (* x) ys)) (eo::define ((_v0 ($run_evaluate x))) ($run_evaluate.fev5 ys x ($eo_eq _v0 ($eo_to_q _v0)))))
  (($run_evaluate ($eoo_-.2 x)) ($eo_neg ($run_evaluate x)))
  (($run_evaluate (_ (/ x) y)) ($eo_qdiv ($eo_to_q ($run_evaluate x)) ($eo_to_q ($run_evaluate y))))
  (($run_evaluate (_ (/_total x) y)) ($run_evaluate.fev6 y x ($eo_eq ($eo_to_q ($run_evaluate y)) 0/1)))
  (($run_evaluate (_ (div i1) i2)) ($eo_zdiv ($run_evaluate i1) ($run_evaluate i2)))
  (($run_evaluate (_ (div_total i1) i2)) ($run_evaluate.fev7 i2 i1 ($eo_eq ($run_evaluate i2) 0)))
  (($run_evaluate (_ (mod i1) i2)) ($eo_zmod ($run_evaluate i1) ($run_evaluate i2)))
  (($run_evaluate (_ (mod_total i1) i2)) ($run_evaluate.fev8 i2 i1 ($eo_eq ($run_evaluate i2) 0)))
  (($run_evaluate (to_real x)) ($eo_to_q ($run_evaluate x)))
  (($run_evaluate (to_int x)) ($eo_to_z ($run_evaluate x)))
  (($run_evaluate (is_int x)) (eo::define ((_v0 ($run_evaluate x))) ($eo_eq ($eo_to_q ($eo_to_z _v0)) ($eo_to_q _v0))))
  (($run_evaluate (abs x)) ($run_evaluate.fev9 x ($eo_is_neg ($run_evaluate x))))
  (($run_evaluate (int.log2 i1)) ($run_evaluate.fev10 i1 ($eo_is_neg ($eo_neg ($run_evaluate i1)))))
  (($run_evaluate (int.pow2 i1)) ($run_evaluate.fev11 i1 ($eo_is_z ($run_evaluate i1))))
  (($run_evaluate (int.ispow2 i1)) ($run_evaluate.fev12 i1 ($eo_is_z ($run_evaluate i1))))
  (($run_evaluate (_ (str.++ sx) sys)) ($eo_concat ($run_evaluate sx) ($run_evaluate sys)))
  (($run_evaluate (str.len sx)) ($eo_len ($run_evaluate sx)))
  (($run_evaluate (_ (_ (str.substr sx) n) m)) ($eo_extract ($run_evaluate sx) ($run_evaluate n) ($eo_add -1 ($run_evaluate m))))
  (($run_evaluate (_ (str.at sx) n)) (eo::define ((_v0 ($run_evaluate n))) ($eo_extract ($run_evaluate sx) _v0 _v0)))
  (($run_evaluate (_ (str.contains sx) sy)) ($eo_not ($eo_is_neg ($eo_find ($run_evaluate sx) ($run_evaluate sy)))))
  (($run_evaluate (_ (_ (str.replace sx) sy) sz)) ($run_evaluate.fev13 sz sx sy ($eo_is_neg ($eo_find ($eo_to_str ($run_evaluate sx)) ($eo_to_str ($run_evaluate sy))))))
  (($run_evaluate (_ (_ (str.replace_all ssx) ssy) ssz)) ($run_evaluate.fev14 ssz ssy ssx ($eo_and ($eo_is_str ssz) ($eo_is_str ssy))))
  (($run_evaluate (_ (str.prefixof sx) sy)) (eo::define ((_v0 ($run_evaluate sx))) ($eo_eq _v0 ($eo_extract ($run_evaluate sy) 0 ($eo_add ($eo_len _v0) -1)))))
  (($run_evaluate (_ (str.suffixof sx) sy)) (eo::define ((_v0 ($run_evaluate sy))) (eo::define ((_v1 ($eo_len _v0))) (eo::define ((_v2 ($run_evaluate sx))) ($eo_eq _v2 ($eo_extract _v0 ($eo_add _v1 ($eo_neg ($eo_len _v2))) ($eo_add _v1 -1)))))))
  (($run_evaluate (_ (_ (str.indexof sx) sy) n)) ($run_evaluate.fev15 sy sx n ($eo_is_neg ($run_evaluate n))))
  (($run_evaluate (str.to_code ssx)) ($run_evaluate.fev16 ssx ($eo_eq ($eo_len ($run_evaluate ssx)) 1)))
  (($run_evaluate (str.from_code n)) ($run_evaluate.fev17 n ($run_evaluate.fev18 n ($eo_is_z ($run_evaluate n)))))
  (($run_evaluate (str.to_int ssx)) ($run_evaluate.fev19 ssx ($eo_is_str ($run_evaluate ssx))))
  (($run_evaluate (str.from_int n)) ($run_evaluate.fev20 n ($eo_is_z ($run_evaluate n))))
  (($run_evaluate (_ (str.<= ssx) ssy)) ($run_evaluate.fev21 ssy ssx ($eo_and ($eo_is_str ($run_evaluate ssx)) ($eo_is_str ($run_evaluate ssy)))))
  (($run_evaluate (str.to_lower ssx)) ($run_evaluate.fev22 ssx ($eo_is_str ($run_evaluate ssx))))
  (($run_evaluate (str.to_upper ssx)) ($run_evaluate.fev23 ssx ($eo_is_str ($run_evaluate ssx))))
  (($run_evaluate (str.rev sx)) ($run_evaluate.fev24 sx ($eo_is_str ($run_evaluate sx))))
  (($run_evaluate (_ (_ (str.update sx) n) sy)) (eo::define ((_v0 ($run_evaluate n))) ($run_evaluate.fev25 sx n sy ($eo_or ($eo_gt 0 _v0) ($eo_gt _v0 ($eo_len ($run_evaluate sx)))))))
  (($run_evaluate (bvnot xb)) ($eo_not ($run_evaluate xb)))
  (($run_evaluate (bvneg xb)) ($eo_neg ($run_evaluate xb)))
  (($run_evaluate (_ (bvadd xb) ybs)) ($eo_add ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvmul xb) ybs)) ($eo_mul ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvudiv xb) yb)) ($run_evaluate.fev26 yb xb ($eo_eq ($eo_to_z ($run_evaluate yb)) 0)))
  (($run_evaluate (_ (bvurem xb) yb)) ($run_evaluate.fev27 yb xb ($eo_eq ($eo_to_z ($run_evaluate yb)) 0)))
  (($run_evaluate (_ (bvand xb) ybs)) ($eo_and ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvor xb) ybs)) ($eo_or ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (bvxor xb) ybs)) ($eo_xor ($run_evaluate xb) ($run_evaluate ybs)))
  (($run_evaluate (_ (concat xb) zbs)) ($eo_concat ($run_evaluate xb) ($run_evaluate zbs)))
  (($run_evaluate (_ (bvsub xb) yb)) ($eo_add ($run_evaluate xb) ($eo_neg ($run_evaluate yb))))
  (($run_evaluate (_ (_ (extract m) n) xb)) ($eo_extract ($run_evaluate xb) n m))
  (($run_evaluate (_ (bvult xb) yb)) ($run_evaluate (_ (bvugt yb) xb)))
  (($run_evaluate (_ (bvule xb) yb)) ($run_evaluate (_ (bvuge yb) xb)))
  (($run_evaluate (_ (bvugt xb) yb)) ($eo_gt ($eo_to_z ($run_evaluate xb)) ($eo_to_z ($run_evaluate yb))))
  (($run_evaluate (_ (bvuge xb) yb)) (eo::define ((_v0 ($run_evaluate yb))) (eo::define ((_v1 ($run_evaluate xb))) ($eo_or ($eo_gt _v1 _v0) ($eo_eq _v1 _v0)))))
  (($run_evaluate (_ (bvslt xb) yb)) ($run_evaluate (_ (bvsgt yb) xb)))
  (($run_evaluate (_ (bvsle xb) yb)) ($run_evaluate (_ (bvsge yb) xb)))
  (($run_evaluate (_ (bvsgt xb) yb)) (eo::define ((_v0 ($run_evaluate xb))) (eo::define ((_v1 ($eo_add ($bv_bitwidth ($eo_typeof _v0)) -1))) (eo::define ((_v2 ($run_evaluate yb))) (eo::define ((_v3 ($eo_add ($bv_bitwidth ($eo_typeof _v2)) -1))) ($run_evaluate.fev28 yb xb ($run_evaluate.fev29 yb xb ($eo_eq ($eo_extract _v2 _v3 _v3) #b1)) ($run_evaluate.fev30 yb xb ($eo_eq ($eo_extract _v0 _v1 _v1) #b1))))))))
  (($run_evaluate (_ (bvsge xb) yb)) (eo::define ((_v0 ($run_evaluate xb))) (eo::define ((_v1 ($eo_add ($bv_bitwidth ($eo_typeof _v0)) -1))) (eo::define ((_v2 ($run_evaluate yb))) (eo::define ((_v3 ($eo_add ($bv_bitwidth ($eo_typeof _v2)) -1))) ($run_evaluate.fev31 yb xb ($run_evaluate.fev32 yb xb ($eo_eq ($eo_extract _v2 _v3 _v3) #b1)) ($run_evaluate.fev33 yb xb ($eo_eq ($eo_extract _v0 _v1 _v1) #b1))))))))
  (($run_evaluate (_ (bvshl xb) yb)) ($run_evaluate.fev34 yb xb ($eo_gt ($eo_to_z ($run_evaluate yb)) ($bv_bitwidth ($eo_typeof xb)))))
  (($run_evaluate (_ (bvlshr xb) yb)) ($run_evaluate.fev35 yb xb ($eo_gt ($eo_to_z ($run_evaluate yb)) ($bv_bitwidth ($eo_typeof xb)))))
  (($run_evaluate (_ (bvashr xb) yb)) (eo::define ((_v0 ($run_evaluate xb))) (eo::define ((_v1 ($eo_add ($bv_bitwidth ($eo_typeof _v0)) -1))) ($run_evaluate.fev36 yb xb ($eo_eq ($eo_extract _v0 _v1 _v1) #b0)))))
  (($run_evaluate (_ (repeat n) xb)) (eo::define ((_v0 ($run_evaluate n))) ($run_evaluate.fev37 xb n ($run_evaluate.fev38 xb n ($eo_and ($eo_is_z _v0) ($eo_not ($eo_is_neg _v0)))))))
  (($run_evaluate (_ (sign_extend n) xb)) (eo::define ((_v0 ($run_evaluate n))) ($run_evaluate.fev39 xb n ($run_evaluate xb) ($run_evaluate.fev40 xb n ($eo_and ($eo_is_z _v0) ($eo_not ($eo_is_neg _v0)))))))
  (($run_evaluate (_ (zero_extend n) xb)) (eo::define ((_v0 ($run_evaluate n))) ($run_evaluate.fev41 xb n ($run_evaluate xb) ($run_evaluate.fev42 xb n ($eo_and ($eo_is_z _v0) ($eo_not ($eo_is_neg _v0)))))))
  (($run_evaluate (_ (@bv n) m)) ($eo_to_bin ($run_evaluate m) ($run_evaluate n)))
  (($run_evaluate (@bvsize xb)) ($bv_bitwidth ($eo_typeof xb)))
  (($run_evaluate (_ (int_to_bv n) m)) ($eo_to_bin ($run_evaluate n) ($run_evaluate m)))
  (($run_evaluate (ubv_to_int xb)) ($eo_to_z ($run_evaluate xb)))
  (($run_evaluate (sbv_to_int xb)) (eo::define ((_v0 ($eo_add ($bv_bitwidth ($eo_typeof xb)) -1))) ($run_evaluate.fev43 xb ($eo_eq ($eo_extract xb _v0 _v0) #b0))))
  (($run_evaluate z) z)
  )
)
(program $eo_typeof_apply ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_apply (-> T U) T) U)
  )
)
(program $eo_typeof_@pair ((U Type) (T Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_@pair U T) (_ (@Pair U) T))
  )
)
(program $eo_typeof_ite ((A Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_ite Bool A) (-> A A))
  )
)
(program $eo_typeof_= ((A Type))
  :signature (Type) Type
  (
  (($eo_typeof_= A) (-> A Bool))
  )
)
(program $eo_typeof_+ ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_+ T U) ($arith_typeunion T U))
  )
)
(program $eo_typeof_- ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_- T U) ($arith_typeunion T U))
  )
)
(program $eo_typeof_* ((T Type) (U Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_* T U) ($arith_typeunion T U))
  )
)
(program $eo_typeof_<.fev2 ((U Type) ($eo_4 Type))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_<.fev2 U $eo_4 $eo_4) Bool)
  )
)
(program $eo_typeof_<.fev1 ((T Type) ($eo_2 Type) (U Type))
  :signature (Type Type Type Type) Type
  (
  (($eo_typeof_<.fev1 U T $eo_2 $eo_2) ($eo_typeof_<.fev2 U ($is_arith_type U) true))
  )
)
(program $eo_typeof_< ((U Type) (T Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_< T U) ($eo_typeof_<.fev1 U T ($is_arith_type T) true))
  )
)
(program $eo_typeof_<=.fev2 ((U Type) ($eo_4 Type))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_<=.fev2 U $eo_4 $eo_4) Bool)
  )
)
(program $eo_typeof_<=.fev1 ((T Type) ($eo_2 Type) (U Type))
  :signature (Type Type Type Type) Type
  (
  (($eo_typeof_<=.fev1 U T $eo_2 $eo_2) ($eo_typeof_<=.fev2 U ($is_arith_type U) true))
  )
)
(program $eo_typeof_<= ((U Type) (T Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_<= T U) ($eo_typeof_<=.fev1 U T ($is_arith_type T) true))
  )
)
(program $eo_typeof_>.fev2 ((U Type) ($eo_4 Type))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_>.fev2 U $eo_4 $eo_4) Bool)
  )
)
(program $eo_typeof_>.fev1 ((T Type) ($eo_2 Type) (U Type))
  :signature (Type Type Type Type) Type
  (
  (($eo_typeof_>.fev1 U T $eo_2 $eo_2) ($eo_typeof_>.fev2 U ($is_arith_type U) true))
  )
)
(program $eo_typeof_> ((U Type) (T Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_> T U) ($eo_typeof_>.fev1 U T ($is_arith_type T) true))
  )
)
(program $eo_typeof_>=.fev2 ((U Type) ($eo_4 Type))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_>=.fev2 U $eo_4 $eo_4) Bool)
  )
)
(program $eo_typeof_>=.fev1 ((T Type) ($eo_2 Type) (U Type))
  :signature (Type Type Type Type) Type
  (
  (($eo_typeof_>=.fev1 U T $eo_2 $eo_2) ($eo_typeof_>=.fev2 U ($is_arith_type U) true))
  )
)
(program $eo_typeof_>= ((U Type) (T Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_>= T U) ($eo_typeof_>=.fev1 U T ($is_arith_type T) true))
  )
)
(program $eo_typeof_to_real.fev1 ((T Type) ($eo_2 Type))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_to_real.fev1 T $eo_2 $eo_2) Real)
  )
)
(program $eo_typeof_to_real ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_to_real T) ($eo_typeof_to_real.fev1 T ($is_arith_type T) true))
  )
)
(program $eo_typeof_to_int.fev1 ((T Type) ($eo_2 Type))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_to_int.fev1 T $eo_2 $eo_2) Int)
  )
)
(program $eo_typeof_to_int ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_to_int T) ($eo_typeof_to_int.fev1 T ($is_arith_type T) true))
  )
)
(program $eo_typeof_is_int.fev1 ((T Type) ($eo_2 Type))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_is_int.fev1 T $eo_2 $eo_2) Bool)
  )
)
(program $eo_typeof_is_int ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_is_int T) ($eo_typeof_is_int.fev1 T ($is_arith_type T) true))
  )
)
(program $eo_typeof_abs.fev1 (($eo_2 Type) (T Type))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_abs.fev1 T $eo_2 $eo_2) T)
  )
)
(program $eo_typeof_abs ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_abs T) ($eo_typeof_abs.fev1 T ($is_arith_type T) true))
  )
)
(program $eo_typeof_$eoo_-.2.fev1 (($eo_2 Type) (T Type))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_$eoo_-.2.fev1 T $eo_2 $eo_2) T)
  )
)
(program $eo_typeof_$eoo_-.2 ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_$eoo_-.2 T) ($eo_typeof_$eoo_-.2.fev1 T ($is_arith_type T) true))
  )
)
(program $eo_typeof_/.fev2 ((U Type) ($eo_4 Type))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_/.fev2 U $eo_4 $eo_4) Real)
  )
)
(program $eo_typeof_/.fev1 ((T Type) ($eo_2 Type) (U Type))
  :signature (Type Type Type Type) Type
  (
  (($eo_typeof_/.fev1 U T $eo_2 $eo_2) ($eo_typeof_/.fev2 U ($is_arith_type U) true))
  )
)
(program $eo_typeof_/ ((U Type) (T Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_/ T U) ($eo_typeof_/.fev1 U T ($is_arith_type T) true))
  )
)
(program $eo_typeof_/_total.fev2 ((U Type) ($eo_4 Type))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_/_total.fev2 U $eo_4 $eo_4) Real)
  )
)
(program $eo_typeof_/_total.fev1 ((T Type) ($eo_2 Type) (U Type))
  :signature (Type Type Type Type) Type
  (
  (($eo_typeof_/_total.fev1 U T $eo_2 $eo_2) ($eo_typeof_/_total.fev2 U ($is_arith_type U) true))
  )
)
(program $eo_typeof_/_total ((U Type) (T Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_/_total T U) ($eo_typeof_/_total.fev1 U T ($is_arith_type T) true))
  )
)
(program $eo_typeof_@bvsize ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_@bvsize (BitVec m)) Int)
  )
)
(program $eo_typeof_concat.fev1 ((m Int) (n Int) ($eo_1 Int))
  :signature (Int Int Int) Type
  (
  (($eo_typeof_concat.fev1 m n $eo_1) (BitVec $eo_1))
  )
)
(program $eo_typeof_concat ((n Int) (m Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_concat (BitVec n) (BitVec m)) ($eo_typeof_concat.fev1 m n ($eo_add n m)))
  )
)
(program $eo_typeof_extract.fev1 ((l Int) ($eo_1 Int))
  :signature (Int Int) Type
  (
  (($eo_typeof_extract.fev1 l $eo_1) (BitVec $eo_1))
  )
)
(program $eo_typeof_extract ((h Int) (n Int) (l Int))
  :signature (Type Type Type) Type
  (
  (($eo_typeof_extract h l (BitVec n)) ($eo_typeof_extract.fev1 l ($eo_add 1 ($eo_neg l))))
  )
)
(program $eo_typeof_repeat.fev1 ((n Int) (i Int) ($eo_1 Int))
  :signature (Int Int Int) Type
  (
  (($eo_typeof_repeat.fev1 n i $eo_1) (BitVec $eo_1))
  )
)
(program $eo_typeof_repeat ((i Int) (n Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_repeat i (BitVec n)) ($eo_typeof_repeat.fev1 n i ($eo_mul i n)))
  )
)
(program $eo_typeof_bvnot ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvnot (BitVec m)) (BitVec m))
  )
)
(program $eo_typeof_bvand ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvand (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvor ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvor (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvxor ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvxor (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvneg ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvneg (BitVec m)) (BitVec m))
  )
)
(program $eo_typeof_bvadd ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvadd (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvmul ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvmul (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvudiv ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvudiv (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvurem ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvurem (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvsub ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsub (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvult ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvult (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvule ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvule (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvugt ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvugt (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvuge ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvuge (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvslt ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvslt (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvsle ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsle (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvsgt ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsgt (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvsge ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvsge (BitVec m)) (-> (BitVec m) Bool))
  )
)
(program $eo_typeof_bvshl ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvshl (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvlshr ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvlshr (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_bvashr ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_bvashr (BitVec m)) (eo::define ((_v0 (BitVec m))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_zero_extend.fev1 ((i Int) (m Int) ($eo_1 Int))
  :signature (Int Int Int) Type
  (
  (($eo_typeof_zero_extend.fev1 i m $eo_1) (BitVec $eo_1))
  )
)
(program $eo_typeof_zero_extend ((m Int) (i Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_zero_extend i (BitVec m)) ($eo_typeof_zero_extend.fev1 i m ($eo_add m i)))
  )
)
(program $eo_typeof_sign_extend.fev1 ((i Int) (m Int) ($eo_1 Int))
  :signature (Int Int Int) Type
  (
  (($eo_typeof_sign_extend.fev1 i m $eo_1) (BitVec $eo_1))
  )
)
(program $eo_typeof_sign_extend ((m Int) (i Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_sign_extend i (BitVec m)) ($eo_typeof_sign_extend.fev1 i m ($eo_add m i)))
  )
)
(program $eo_typeof_@bv ((value Int) (w Int))
  :signature (Type Type) Type
  (
  (($eo_typeof_@bv value w) (BitVec w))
  )
)
(program $eo_typeof_seq.empty ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_seq.empty (Seq T)) (Seq T))
  )
)
(program $eo_typeof_str.len ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.len (Seq T)) Int)
  )
)
(program $eo_typeof_str.++ ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.++ (Seq T)) (eo::define ((_v0 (Seq T))) (-> _v0 _v0)))
  )
)
(program $eo_typeof_str.substr ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.substr (Seq T)) (-> Int (-> Int (Seq T))))
  )
)
(program $eo_typeof_str.contains ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.contains (Seq T)) (-> (Seq T) Bool))
  )
)
(program $eo_typeof_str.replace ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.replace (Seq T)) (eo::define ((_v0 (Seq T))) (-> _v0 (-> _v0 _v0))))
  )
)
(program $eo_typeof_str.indexof ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.indexof (Seq T)) (-> (Seq T) (-> Int Int)))
  )
)
(program $eo_typeof_str.at ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.at (Seq T)) (-> Int (Seq T)))
  )
)
(program $eo_typeof_str.prefixof ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.prefixof (Seq T)) (-> (Seq T) Bool))
  )
)
(program $eo_typeof_str.suffixof ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.suffixof (Seq T)) (-> (Seq T) Bool))
  )
)
(program $eo_typeof_str.rev ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.rev (Seq T)) (Seq T))
  )
)
(program $eo_typeof_str.update ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.update (Seq T)) (eo::define ((_v0 (Seq T))) (-> Int (-> _v0 _v0))))
  )
)
(program $eo_typeof_str.replace_all ((T Type))
  :signature (Type) Type
  (
  (($eo_typeof_str.replace_all (Seq T)) (eo::define ((_v0 (Seq T))) (-> _v0 (-> _v0 _v0))))
  )
)
(program $eo_typeof_int_to_bv ((w Int))
  :signature (Type) Type
  (
  (($eo_typeof_int_to_bv w) (-> Int (BitVec w)))
  )
)
(program $eo_typeof_ubv_to_int ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_ubv_to_int (BitVec m)) Int)
  )
)
(program $eo_typeof_sbv_to_int ((m Int))
  :signature (Type) Type
  (
  (($eo_typeof_sbv_to_int (BitVec m)) Int)
  )
)
(program $eo_typeof_fun_type ()
  :signature (Type Type) Type
  (
  (($eo_typeof_fun_type Type Type) Type)
  )
)
(program $eo_typeof_main
  ((T Type) (U Type) (V Type) (W Type) (f (-> U V T)) (x U) (t T)
   (W1 Type) (x1 W1) (W2 Type) (x2 W2) (W3 Type) (x3 W3)) 
  :signature (T) Type
  (
  (($eo_typeof_main Type)      Type)
  (($eo_typeof_main (-> T U))  ($eo_typeof_fun_type ($eo_typeof T) ($eo_typeof U))) 
  (($eo_typeof_main Bool)      Type)
  (($eo_typeof_main true)      Bool)
  (($eo_typeof_main false)     Bool)
  
  (($eo_typeof_main Int) Type)
  
  (($eo_typeof_main Real) Type)
  
  (($eo_typeof_main Char) Type)
  
  (($eo_typeof_main Seq) (-> Type Type))
  
  (($eo_typeof_main @Pair) (-> Type (-> Type Type)))
  
  (($eo_typeof_main (_ (@pair x1) x2)) ($eo_typeof_@pair ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main (_ (ite x1) x2)) ($eo_typeof_ite ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main not) (-> Bool Bool))
  
  (($eo_typeof_main or) (-> Bool (-> Bool Bool)))
  
  (($eo_typeof_main and) (-> Bool (-> Bool Bool)))
  
  (($eo_typeof_main =>) (-> Bool (-> Bool Bool)))
  
  (($eo_typeof_main xor) (-> Bool (-> Bool Bool)))
  
  (($eo_typeof_main (= x1)) ($eo_typeof_= ($eo_typeof x1)))
  
  (($eo_typeof_main (_ (+ x1) x2)) ($eo_typeof_+ ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main (_ (- x1) x2)) ($eo_typeof_- ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main (_ (* x1) x2)) ($eo_typeof_* ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main (_ (< x1) x2)) ($eo_typeof_< ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main (_ (<= x1) x2)) ($eo_typeof_<= ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main (_ (> x1) x2)) ($eo_typeof_> ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main (_ (>= x1) x2)) ($eo_typeof_>= ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main (to_real x1)) ($eo_typeof_to_real ($eo_typeof x1)))
  
  (($eo_typeof_main (to_int x1)) ($eo_typeof_to_int ($eo_typeof x1)))
  
  (($eo_typeof_main (is_int x1)) ($eo_typeof_is_int ($eo_typeof x1)))
  
  (($eo_typeof_main (abs x1)) ($eo_typeof_abs ($eo_typeof x1)))
  
  (($eo_typeof_main ($eoo_-.2 x1)) ($eo_typeof_$eoo_-.2 ($eo_typeof x1)))
  
  (($eo_typeof_main div) (-> Int (-> Int Int)))
  
  (($eo_typeof_main mod) (-> Int (-> Int Int)))
  
  (($eo_typeof_main int.pow2) (-> Int Int))
  
  (($eo_typeof_main int.log2) (-> Int Int))
  
  (($eo_typeof_main int.ispow2) (-> Int Bool))
  
  (($eo_typeof_main div_total) (-> Int (-> Int Int)))
  
  (($eo_typeof_main mod_total) (-> Int (-> Int Int)))
  
  (($eo_typeof_main (_ (/ x1) x2)) ($eo_typeof_/ ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main (_ (/_total x1) x2)) ($eo_typeof_/_total ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main BitVec) (-> Int Type))
  
  (($eo_typeof_main (@bvsize x1)) ($eo_typeof_@bvsize ($eo_typeof x1)))
  
  (($eo_typeof_main (_ (concat x1) x2)) ($eo_typeof_concat ($eo_typeof x1) ($eo_typeof x2)))
  
  (($eo_typeof_main (_ (_ (extract x1) x2) x3)) ($eo_typeof_extract x1 x2 ($eo_typeof x3)))
  
  (($eo_typeof_main (_ (repeat x1) x2)) ($eo_typeof_repeat x1 ($eo_typeof x2)))
  
  (($eo_typeof_main (bvnot x1)) ($eo_typeof_bvnot ($eo_typeof x1)))
  
  (($eo_typeof_main (bvand x1)) ($eo_typeof_bvand ($eo_typeof x1)))
  
  (($eo_typeof_main (bvor x1)) ($eo_typeof_bvor ($eo_typeof x1)))
  
  (($eo_typeof_main (bvxor x1)) ($eo_typeof_bvxor ($eo_typeof x1)))
  
  (($eo_typeof_main (bvneg x1)) ($eo_typeof_bvneg ($eo_typeof x1)))
  
  (($eo_typeof_main (bvadd x1)) ($eo_typeof_bvadd ($eo_typeof x1)))
  
  (($eo_typeof_main (bvmul x1)) ($eo_typeof_bvmul ($eo_typeof x1)))
  
  (($eo_typeof_main (bvudiv x1)) ($eo_typeof_bvudiv ($eo_typeof x1)))
  
  (($eo_typeof_main (bvurem x1)) ($eo_typeof_bvurem ($eo_typeof x1)))
  
  (($eo_typeof_main (bvsub x1)) ($eo_typeof_bvsub ($eo_typeof x1)))
  
  (($eo_typeof_main (bvult x1)) ($eo_typeof_bvult ($eo_typeof x1)))
  
  (($eo_typeof_main (bvule x1)) ($eo_typeof_bvule ($eo_typeof x1)))
  
  (($eo_typeof_main (bvugt x1)) ($eo_typeof_bvugt ($eo_typeof x1)))
  
  (($eo_typeof_main (bvuge x1)) ($eo_typeof_bvuge ($eo_typeof x1)))
  
  (($eo_typeof_main (bvslt x1)) ($eo_typeof_bvslt ($eo_typeof x1)))
  
  (($eo_typeof_main (bvsle x1)) ($eo_typeof_bvsle ($eo_typeof x1)))
  
  (($eo_typeof_main (bvsgt x1)) ($eo_typeof_bvsgt ($eo_typeof x1)))
  
  (($eo_typeof_main (bvsge x1)) ($eo_typeof_bvsge ($eo_typeof x1)))
  
  (($eo_typeof_main (bvshl x1)) ($eo_typeof_bvshl ($eo_typeof x1)))
  
  (($eo_typeof_main (bvlshr x1)) ($eo_typeof_bvlshr ($eo_typeof x1)))
  
  (($eo_typeof_main (bvashr x1)) ($eo_typeof_bvashr ($eo_typeof x1)))
  
  (($eo_typeof_main (_ (zero_extend x1) x2)) ($eo_typeof_zero_extend x1 ($eo_typeof x2)))
  
  (($eo_typeof_main (_ (sign_extend x1) x2)) ($eo_typeof_sign_extend x1 ($eo_typeof x2)))
  
  (($eo_typeof_main (_ (@bv x1) x2)) ($eo_typeof_@bv x1 x2))
  
  (($eo_typeof_main (as seq.empty x1)) ($eo_typeof_seq.empty x1))
  
  (($eo_typeof_main (str.len x1)) ($eo_typeof_str.len ($eo_typeof x1)))
  
  (($eo_typeof_main (str.++ x1)) ($eo_typeof_str.++ ($eo_typeof x1)))
  
  (($eo_typeof_main (str.substr x1)) ($eo_typeof_str.substr ($eo_typeof x1)))
  
  (($eo_typeof_main (str.contains x1)) ($eo_typeof_str.contains ($eo_typeof x1)))
  
  (($eo_typeof_main (str.replace x1)) ($eo_typeof_str.replace ($eo_typeof x1)))
  
  (($eo_typeof_main (str.indexof x1)) ($eo_typeof_str.indexof ($eo_typeof x1)))
  
  (($eo_typeof_main (str.at x1)) ($eo_typeof_str.at ($eo_typeof x1)))
  
  (($eo_typeof_main (str.prefixof x1)) ($eo_typeof_str.prefixof ($eo_typeof x1)))
  
  (($eo_typeof_main (str.suffixof x1)) ($eo_typeof_str.suffixof ($eo_typeof x1)))
  
  (($eo_typeof_main (str.rev x1)) ($eo_typeof_str.rev ($eo_typeof x1)))
  
  (($eo_typeof_main (str.update x1)) ($eo_typeof_str.update ($eo_typeof x1)))
  
  (($eo_typeof_main str.to_lower) (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
  
  (($eo_typeof_main str.to_upper) (eo::define ((_v0 (Seq Char))) (-> _v0 _v0)))
  
  (($eo_typeof_main str.to_code) (-> (Seq Char) Int))
  
  (($eo_typeof_main str.from_code) (-> Int (Seq Char)))
  
  (($eo_typeof_main str.to_int) (-> (Seq Char) Int))
  
  (($eo_typeof_main str.from_int) (-> Int (Seq Char)))
  
  (($eo_typeof_main str.<=) (eo::define ((_v0 (Seq Char))) (-> _v0 (-> _v0 Bool))))
  
  (($eo_typeof_main (str.replace_all x1)) ($eo_typeof_str.replace_all ($eo_typeof x1)))
  
  (($eo_typeof_main (int_to_bv x1)) ($eo_typeof_int_to_bv x1))
  
  (($eo_typeof_main (ubv_to_int x1)) ($eo_typeof_ubv_to_int ($eo_typeof x1)))
  
  (($eo_typeof_main (sbv_to_int x1)) ($eo_typeof_sbv_to_int ($eo_typeof x1)))

  (($eo_typeof_main (f x))     ($eo_typeof_apply ($eo_typeof f) ($eo_typeof x)))
  )
)
(program $eo_dt_constructors
  ((T Type))
  :signature (Type) $eo_List
  (

  (($eo_dt_constructors T) $eo_fail)
  )
)
(program $eo_dt_selectors ((T Type) (t T))
  :signature (T) $eo_List
  (

  (($eo_dt_selectors t) $eo_fail)
  )
)
(program $eo_nil_bvand (($eoT_3 Type) (m Int))
  :signature ((eo::quote $eoT_3)) $eoT_3
  (
  (($eo_nil_bvand (BitVec m)) ($eo_not ($eo_to_bin m 0)))
  )
)
(program $eo_nil_bvor (($eoT_4 Type) (m Int))
  :signature ((eo::quote $eoT_4)) $eoT_4
  (
  (($eo_nil_bvor (BitVec m)) ($eo_to_bin m 0))
  )
)
(program $eo_nil_bvxor (($eoT_5 Type) (m Int))
  :signature ((eo::quote $eoT_5)) $eoT_5
  (
  (($eo_nil_bvxor (BitVec m)) ($eo_to_bin m 0))
  )
)
(program $eo_nil_bvadd (($eoT_6 Type) (m Int))
  :signature ((eo::quote $eoT_6)) $eoT_6
  (
  (($eo_nil_bvadd (BitVec m)) ($eo_to_bin m 0))
  )
)
(program $eo_nil_bvmul (($eoT_7 Type) (m Int))
  :signature ((eo::quote $eoT_7)) $eoT_7
  (
  (($eo_nil_bvmul (BitVec m)) ($eo_to_bin m 1))
  )
)
(program $eo_nil_str.++ (($eoT_8 Type) (T Type))
  :signature ((eo::quote $eoT_8)) $eoT_8
  (
  (($eo_nil_str.++ (Seq T)) ($seq_empty (Seq T)))
  )
)
(program $eo_nil
  ((T Type) (U Type) (V Type) (W Type) (f (-> T U V)))
  :signature ((-> T U V) (eo::quote W)) W
  (
  (($eo_nil or T) false)
  (($eo_nil and T) true)
  (($eo_nil + T) 0)
  (($eo_nil * T) 1)
  (($eo_nil concat T) ($eo_to_bin 0 0))
  (($eo_nil bvand T) ($eo_nil_bvand T))
  (($eo_nil bvor T) ($eo_nil_bvor T))
  (($eo_nil bvxor T) ($eo_nil_bvxor T))
  (($eo_nil bvadd T) ($eo_nil_bvadd T))
  (($eo_nil bvmul T) ($eo_nil_bvmul T))
  (($eo_nil str.++ T) ($eo_nil_str.++ T))

  (($eo_nil f T) $eo_fail)
  )
)
(program $eo_model_sat () :signature (Bool) $eo_Option)
(program $eo_model_typeof () :signature (Bool) Type)
(program $eo_model_is_input () :signature (Bool) Bool)
; This file defines SMT-LIB model semantics in Eunoia.
; It has exception handling utilities to call Eunoia programs in
; a safe way that ensures that all programs in this signature are total.

; The programs in this file operate on datatypes that correspond to
; a deep embedding of Eunoia and SMT-LIB terms, types and values.
; In particular, we use the following types:
; 1. $eo_Term, the type of Eunoia terms.
; 2. $smt_Term, the type of SMT-LIB terms.
; 3. $smt_Type, the type of SMT-LIB types.
; 4. $smt_Value, the type of SMT-LIB values.
; 5. Further types defining specific SMT-LIB values, e.g. $smt_Map.
; 6. $smt_builtin_X, the builtin SMT-LIB type X.
; Note that the last type allows us to define symbols whose type
; will be a native SMT-LIB type in the final embedding generated
; by the smt-meta plugin.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Exception handling

; Invariant: all programs in this signature should be well-founded and never
; never get stuck unless otherwise stated.

; Utilities to ensure that programs are total.
; Takes
; - A $eo_Term t where we are not sure if it gets stuck.
; - A $eo_Term elseTerm where we are sure it does not get stuck.
; Returns the SMT term corresponding to the evaluation of t, if possible,
; or elseTerm otherwise. This always successfully evaluates.
(define $smt_try ((t $eo_Term) (elseTerm $eo_Term))
  ($smt_apply_3 "ite" ($smt_builtin_is_ok t)
    t
    elseTerm))

; Guarded execution of $eo_typeof.
(define $smt_try_typeof ((T Type :implicit) (t T))
  ($smt_try ($eo_typeof t) $eo_null_type))

;;;;;; SMT values

; forward declaration
; This method classifies SMT terms as being values.
; The invariant of this method is that if v1 and v2
; return true where v1 and v2 have the same type ($smtx_typeof),
; and are distinct, then they denote semantically distinct
; values.
(program $smtx_is_value ()
  :signature ($smt_Value) $smt_builtin_Bool)

;;; Functions and array values.

; $smt_Map is recursive and thus defined above.

; Get the default for the map
(program $smtx_map_default
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (M $smt_Map))
  :signature ($smt_Map) $smt_Value
  (
  (($smtx_map_default ($msm_cons j e M))  ($smtx_map_default M))
  (($smtx_map_default ($msm_default e))   e)
  )
)

; This program looks up the value of a term in a map.
; This is used for function evaluation.
(program $smtx_map_lookup
  ((i $smt_Value) (j $smt_Value) (e $smt_Value) (M $smt_Map))
  :signature ($smt_Map $smt_Value) $smt_Value
  (
  ; NOTE: the cases here are exhaustive
  (($smtx_map_lookup ($msm_cons i e M) i)  e)
  (($smtx_map_lookup ($msm_cons j e M) i)  ($smtx_map_lookup M i))
  (($smtx_map_lookup ($msm_default e) i)   e)
  )
)

; This program determines whether the map value is canonical
; This program is only necessary if we are doing equality between arrays
; (or functions).
(program $smtx_map_is_redundant
  ((T $smt_Type) (U $smt_Type) (t $smt_Value) (u $smt_Value) (M $smt_Map))
  :signature ($smt_Map $smt_Type) $smt_builtin_Bool
  (
  (($smtx_map_is_redundant ($msm_default u) U)     $smt_builtin_false)
  (($smtx_map_is_redundant ($msm_cons t u M) U)
    ; lookup value on tail
    ; if it is the same, this index is redundant and thus we are not a value
    ($smt_apply_3 "ite"
      ($smt_apply_= ($smtx_map_lookup t M) u)
      $smt_builtin_true
      ($smtx_map_is_redundant M)))
  )
)

; TODO: use $smtx_map_is_redundant.
; Also requires a sortedness and non-exhaustiveness conditions.
(program $smtx_map_is_value ()
  :signature ($smt_builtin_Int $smt_Map) $smt_builtin_Bool)

;;; Utilities for Datatype values

; define: $smt_is_dt
; returns: true if t is a datatpe (i.e. it has constructors).
(define $smt_is_dt ((t $smt_Type))
  ($smt_builtin_is_ok ($eo_dt_constructors t)))

; define: $smt_is_dt_cons
; returns: true if t is a constructor (i.e. it has selectors).
(define $smt_is_dt_cons ((t $smt_Term))
  ($smt_builtin_is_ok ($eo_dt_selectors t)))

;;; Term values.

; program: $smtx_term_is_value
; Returns true if its argument is an SMT value.
; This function is expected to never get stuck.
; Note that this does not take a type. This function must ensure
; that if it returns true for two terms t1 and t2 of the same type,
; then t1 != t2 in all models.
(program $smtx_term_is_value
  ((t $smt_Term) (b $smt_builtin_Bool) (n $smt_builtin_Int) (r $smt_builtin_Real) (s $smt_builtin_String))
  :signature ($smt_Term) $smt_builtin_Bool
  (
  ; standard atomic types are values
  (($smtx_term_is_value ($sm_mk_bool b))  $smt_builtin_true)
  (($smtx_term_is_value ($sm_mk_z n))     $smt_builtin_true)
  (($smtx_term_is_value ($sm_mk_q r))     $smt_builtin_true)
  (($smtx_term_is_value ($sm_mk_str s))   $smt_builtin_true)
  ; by default, not a value
  (($smtx_term_is_value t)                $smt_builtin_false)
  )
)

;;; Guarded utilities for making values

; Returns a term of type $smt_Value, embeds the term
; if indeed it is a value, or returns not a value otherwise.
(define $smt_mk_value_term ((t $smt_Term))
  ($smt_apply_3 "ite" ($smtx_term_is_value t)
    ; an atomic term, e.g. 0, true, "abc"
    ($vsm_term t)
    ($smt_apply_3 "ite" ($smt_is_dt_cons t)
      ; a datatype constructor, which becomes a (nil-terminated) vsm_apply
      ($vsm_apply ($vsm_term t) $vsm_not_value)
      $vsm_not_value)))

(define $smt_mk_value_map ((T $smt_builtin_Int) (m $smt_Map))
  ($smt_apply_3 "ite"
    ($smtx_map_is_value T m)
    ($vsm_map T m)
    $vsm_not_value))

; program: $smtx_is_value
(program $smtx_is_value
  ((t $smt_Term) (f $smt_Value) (v $smt_Value) (T $eo_Term) (m $smt_Map)
   (T $smt_builtin_Int) (id $smt_builtin_Int))
  :signature ($smt_Value) $smt_builtin_Bool
  (
  (($smtx_is_value ($vsm_term t))         ($smtx_term_is_value t))
  (($smtx_is_value ($vsm_map T m))        ($smtx_map_is_value T m))
  (($smtx_is_value ($vsm_uconst T id))    $smt_builtin_true)
  ; Herbrand interpretations: nil terminated apply of value terms
  (($smtx_is_value ($vsm_apply ($vsm_term t) $vsm_not_value))
                                          ($smt_is_dt_cons t))
  (($smtx_is_value ($vsm_apply f v))      ($smt_apply_2 "and" ($smtx_is_value f) ($smtx_is_value v)))
  ; Otherwise false
  (($smtx_is_value v)                     $smt_builtin_false)
  )
)

; program: $smtx_ensure_value
; args:
; - v $smt_Value: A value term.
; return: >
;   v itself if it denotes a proper SMT-LIB value, or $vsm_not_value otherwise.
(program $smtx_ensure_value
  ((v $smt_Value) (t $smt_Term) (T $smt_builtin_Int) (m $smt_Map) (id $smt_builtin_Int))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_ensure_value ($vsm_term t))         ($smt_mk_value_term t))
  (($smtx_ensure_value ($vsm_map T m))        ($smt_mk_value_map T m))
  (($smtx_ensure_value ($vsm_uconst T id))    ($vsm_uconst T id))
  (($smtx_ensure_value v)                     $vsm_not_value)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program $smtx_enum_type ((T $eo_Term) (i $smt_builtin_Int))
  :signature ($eo_Term $smt_builtin_Int) $smt_Value
  (
  ; otherwise, uninterpreted constant.
  (($smtx_enum_type T i)               ($vsm_uconst T i))
  )
)


;;; Model semantics

; Forward declaration of the main method defined by this signature.
; We use this to define $eo_model_sat.
(program $smtx_model_eval () :signature ($eo_Term) $smt_Value)

; program: $smtx_model_lookup
; Conceptually, returns the model value for a term whose value is
; partially constrained or unconstrained in the model. This is
; intentionally undefined. For example, we may pass the following
; terms to this method:
;   (sm.Apply (sm.Apply sm./ x1) x2), when M(x2) = 0,
;   TODO: skolems??
(program $smtx_model_lookup ()
  :signature ($smt_Term) $smt_Value)

; Lookup the predicate the constant can be assumed to have.
; These should be valid formulas.
(program $smtx_model_lookup_predicate_internal ((t $smt_Term) (v $smt_Value))
  :signature ($smt_Term $smt_Value) $smt_builtin_Bool
  (

  ; otherwise, no predicate
  (($smtx_model_lookup_predicate_internal t v) $smt_builtin_true)
  )
)

; Calls the method above
(program $smtx_model_lookup_predicate ((t $smt_Term))
  :signature ($smt_Term) $smt_builtin_Bool
  (
  (($smtx_model_lookup_predicate t)
    ($smtx_model_lookup_predicate_internal t ($smtx_model_lookup t)))
  )
)

; program: $smtx_substitute
; Used to define $smtx_eval_quant.
; TODO: debruijn
(program $smtx_substitute
  ((x $eo_Term) (y $eo_Term) (f $eo_Term) (a $eo_Term) (z $eo_Term))
  :signature ($eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($smtx_substitute x y (f a))   (_ ($smtx_substitute x y f) ($smtx_substitute x y a)))
  (($smtx_substitute x y x)       y)
  (($smtx_substitute x y z)       z)
  )
)

;;; Core definition of $smtx_model_eval

; program: $smtx_model_eval_apply
; We call ($smtx_model_eval_apply value_f value_i) when
; evaluating (f i) whose values are value_f and value_i
; respectively. If value_f is a map value, then we extract
; the map and call the map lookup routine.
(program $smtx_model_eval_apply
  ((T $smt_builtin_Int) (m $smt_Map) (i $smt_Value) (f $smt_Value) (v $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  ; If a Herbrand interpretation, apply it to the next value.
  (($smtx_model_eval_apply ($vsm_apply f v) i)  ($vsm_apply ($vsm_apply f v) i))
  ; The function evaluated to a map value, call the map lookup.
  (($smtx_model_eval_apply ($vsm_map T m) i)    ($smtx_map_lookup m i))
  ; The function did not evaluate to a map value, we fail.
  (($smtx_model_eval_apply v i)                 $vsm_not_value)
  )
)

; return: The evaluation of an ite application.
(program $smtx_model_eval_ite
  ((t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value

  (
  (($smtx_model_eval_ite $vsm_true t2 t3)   t2)
  (($smtx_model_eval_ite $vsm_false t2 t3)  t3)
  (($smtx_model_eval_ite t1 t2 t3)          $vsm_not_value)
  )
)

; return: The evaluation of an equality application.
(program $smtx_model_eval_=
  ((t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value

  (
  (($smtx_model_eval_= $vsm_not_value t2) $vsm_not_value)
  (($smtx_model_eval_= t1 $vsm_not_value) $vsm_not_value)
  ; use datatype equality over $smt_Value, which depends on t1 and t2 being proper values.
  (($smtx_model_eval_= t1 t2)             ($vsm_term ($sm_mk_bool ($smt_apply_= t1 t2))))
  )
)

; program: $smtx_eval_quant
; specification for exists is a (non-computable) function
; The last argument is whether we are check exists (resp. forall).
(program $smtx_eval_quant
  ((x $eo_Term) (xs $eo_List) (F $eo_Term) (i $smt_builtin_Int) (isExists $smt_builtin_Bool))
  :signature ($eo_List $eo_Term $smt_builtin_Int $smt_builtin_Bool) $smt_Value
  (
  (($smtx_eval_quant $eo_List_nil F i isExists)
    ; base case: we have processed all variables, recurse, negate if isExists is false.
    ($vsm_term ($sm_mk_bool ($smt_apply_= ($smtx_model_eval F) ($eo_mk_bool isExists)))))  ; we are now fully instantiated, look at the body
  (($smtx_eval_quant ($eo_List_cons x xs) F i isExists)
    ; get the next value in the type enumeration
    (eo::define ((next ($smtx_enum_type ($eo_model_typeof x) i)))
    ; if it exists
    ($smt_apply_3 "ite" ($smt_builtin_is_ok next)
      ; evaluate the body for this value. if this is a forcing value, return it
      ($smt_apply_3 "ite" ($smt_apply_= ($smtx_model_eval ($smtx_substitute x next F)) ($eo_mk_bool isExists))
        ($vsm_term ($sm_mk_bool isExists))
        ; otherwise recurse for the next value in the type enumeration for the current variable
        ($smtx_eval_quant ($eo_List_cons x xs) F ($smt_apply_1 "+ 1" i) isExists))
      ($vsm_term ($sm_mk_bool ($smt_apply_1 "not" isExists)))))) ; out of values.
  )
)

(program $smtx_model_eval_not
  ((x1 $smt_builtin_Bool) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_not ($vsm_term ($sm_mk_bool x1))) ($vsm_term ($sm_mk_bool ($smt_apply_1 "not" x1))))
  (($smtx_model_eval_not t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_or
  ((x1 $smt_builtin_Bool) (x2 $smt_builtin_Bool) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_or ($vsm_term ($sm_mk_bool x1)) ($vsm_term ($sm_mk_bool x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "or" x1 x2))))
  (($smtx_model_eval_or t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_and
  ((x1 $smt_builtin_Bool) (x2 $smt_builtin_Bool) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_and ($vsm_term ($sm_mk_bool x1)) ($vsm_term ($sm_mk_bool x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "and" x1 x2))))
  (($smtx_model_eval_and t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_=>
  ((x1 $smt_builtin_Bool) (x2 $smt_builtin_Bool) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_=> ($vsm_term ($sm_mk_bool x1)) ($vsm_term ($sm_mk_bool x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "=>" x1 x2))))
  (($smtx_model_eval_=> t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_xor
  ((x1 $smt_builtin_Bool) (x2 $smt_builtin_Bool) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_xor ($vsm_term ($sm_mk_bool x1)) ($vsm_term ($sm_mk_bool x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "xor" x1 x2))))
  (($smtx_model_eval_xor t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_+
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_+ ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_z ($smt_apply_2 "+" x1 x2))))
  (($smtx_model_eval_+ ($vsm_term ($sm_mk_q x3)) ($vsm_term ($sm_mk_q x4))) ($vsm_term ($sm_mk_q ($smt_apply_2 "+" x3 x4))))
  (($smtx_model_eval_+ t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_-
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_- ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_z ($smt_apply_2 "-" x1 x2))))
  (($smtx_model_eval_- ($vsm_term ($sm_mk_q x3)) ($vsm_term ($sm_mk_q x4))) ($vsm_term ($sm_mk_q ($smt_apply_2 "-" x3 x4))))
  (($smtx_model_eval_- t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_*
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_* ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_z ($smt_apply_2 "*" x1 x2))))
  (($smtx_model_eval_* ($vsm_term ($sm_mk_q x3)) ($vsm_term ($sm_mk_q x4))) ($vsm_term ($sm_mk_q ($smt_apply_2 "*" x3 x4))))
  (($smtx_model_eval_* t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_<
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_< ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "<" x1 x2))))
  (($smtx_model_eval_< ($vsm_term ($sm_mk_q x3)) ($vsm_term ($sm_mk_q x4))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "<" x3 x4))))
  (($smtx_model_eval_< t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_<=
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_<= ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "<=" x1 x2))))
  (($smtx_model_eval_<= ($vsm_term ($sm_mk_q x3)) ($vsm_term ($sm_mk_q x4))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "<=" x3 x4))))
  (($smtx_model_eval_<= t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_>
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_> ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 ">" x1 x2))))
  (($smtx_model_eval_> ($vsm_term ($sm_mk_q x3)) ($vsm_term ($sm_mk_q x4))) ($vsm_term ($sm_mk_bool ($smt_apply_2 ">" x3 x4))))
  (($smtx_model_eval_> t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_>=
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_>= ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 ">=" x1 x2))))
  (($smtx_model_eval_>= ($vsm_term ($sm_mk_q x3)) ($vsm_term ($sm_mk_q x4))) ($vsm_term ($sm_mk_bool ($smt_apply_2 ">=" x3 x4))))
  (($smtx_model_eval_>= t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_to_real
  ((x1 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_to_real ($vsm_term ($sm_mk_z x1))) ($vsm_term ($sm_mk_q ($smt_apply_1 "to_real" x1))))
  (($smtx_model_eval_to_real t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_to_int
  ((x1 $smt_builtin_Real) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_to_int ($vsm_term ($sm_mk_q x1))) ($vsm_term ($sm_mk_z ($smt_apply_1 "to_int" x1))))
  (($smtx_model_eval_to_int t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_is_int
  ((x1 $smt_builtin_Real) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_is_int ($vsm_term ($sm_mk_q x1))) ($vsm_term ($sm_mk_bool ($smt_apply_1 "is_int" x1))))
  (($smtx_model_eval_is_int t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_abs
  ((x1 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_abs ($vsm_term ($sm_mk_z x1))) ($vsm_term ($sm_mk_z ($smt_apply_1 "abs" x1))))
  (($smtx_model_eval_abs t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_$eoo_-.2
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Real) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_$eoo_-.2 ($vsm_term ($sm_mk_z x1))) ($vsm_term ($sm_mk_z ($smt_apply_1 "-" x1))))
  (($smtx_model_eval_$eoo_-.2 ($vsm_term ($sm_mk_q x2))) ($vsm_term ($sm_mk_q ($smt_apply_1 "-" x2))))
  (($smtx_model_eval_$eoo_-.2 t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_div
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_div ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_z ($smt_apply_2 "div" x1 x2))))
  (($smtx_model_eval_div t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_mod
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_mod ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_z ($smt_apply_2 "mod" x1 x2))))
  (($smtx_model_eval_mod t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_int.pow2
  ((x1 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_int.pow2 ($vsm_term ($sm_mk_z x1))) ($vsm_term ($sm_mk_z ($smt_apply_1 "int.pow2" x1))))
  (($smtx_model_eval_int.pow2 t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_div_total
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_div_total ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_z ($smt_apply_2 "div_total" x1 x2))))
  (($smtx_model_eval_div_total t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_mod_total
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_mod_total ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_z ($smt_apply_2 "mod_total" x1 x2))))
  (($smtx_model_eval_mod_total t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_/
  ((x1 $smt_builtin_Real) (x2 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_/ ($vsm_term ($sm_mk_q x1)) ($vsm_term ($sm_mk_q x2))) ($vsm_term ($sm_mk_q ($smt_apply_2 "/" x1 x2))))
  (($smtx_model_eval_/ t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_/_total
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Real) (x4 $smt_builtin_Real) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_/_total ($vsm_term ($sm_mk_z x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_q ($smt_apply_2 "/_total" x1 x2))))
  (($smtx_model_eval_/_total ($vsm_term ($sm_mk_q x3)) ($vsm_term ($sm_mk_q x4))) ($vsm_term ($sm_mk_q ($smt_apply_2 "/_total" x3 x4))))
  (($smtx_model_eval_/_total t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvand
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvand ($vsm_term ($sm_mk_binary x1 x2)) ($vsm_term ($sm_mk_binary x3 x4))) ($vsm_term ($sm_mk_binary x1 ($smtx_binary_and x1 x2 x4))))
  (($smtx_model_eval_bvand t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvor
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvor ($vsm_term ($sm_mk_binary x1 x2)) ($vsm_term ($sm_mk_binary x3 x4))) ($vsm_term ($sm_mk_binary x1 ($smtx_binary_or x1 x2 x4))))
  (($smtx_model_eval_bvor t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_bvxor
  ((x1 $smt_builtin_Int) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (x4 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_bvxor ($vsm_term ($sm_mk_binary x1 x2)) ($vsm_term ($sm_mk_binary x3 x4))) ($vsm_term ($sm_mk_binary x1 ($smtx_binary_xor x1 x2 x4))))
  (($smtx_model_eval_bvxor t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.len
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.len ($vsm_term ($sm_mk_str x1))) ($vsm_term ($sm_mk_z ($smt_apply_1 "str.len" x1))))
  (($smtx_model_eval_str.len t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.++
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.++ ($vsm_term ($sm_mk_str x1)) ($vsm_term ($sm_mk_str x2))) ($vsm_term ($sm_mk_str ($smt_apply_2 "str.++" x1 x2))))
  (($smtx_model_eval_str.++ t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.substr
  ((x1 $smt_builtin_String) (x2 $smt_builtin_Int) (x3 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.substr ($vsm_term ($sm_mk_str x1)) ($vsm_term ($sm_mk_z x2)) ($vsm_term ($sm_mk_z x3))) ($vsm_term ($sm_mk_str ($smt_apply_3 "str.substr" x1 x2 x3))))
  (($smtx_model_eval_str.substr t1 t2 t3) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.contains
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.contains ($vsm_term ($sm_mk_str x1)) ($vsm_term ($sm_mk_str x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "str.contains" x1 x2))))
  (($smtx_model_eval_str.contains t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.replace
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (x3 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.replace ($vsm_term ($sm_mk_str x1)) ($vsm_term ($sm_mk_str x2)) ($vsm_term ($sm_mk_str x3))) ($vsm_term ($sm_mk_str ($smt_apply_3 "str.replace" x1 x2 x3))))
  (($smtx_model_eval_str.replace t1 t2 t3) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.indexof
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (x3 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.indexof ($vsm_term ($sm_mk_str x1)) ($vsm_term ($sm_mk_str x2)) ($vsm_term ($sm_mk_z x3))) ($vsm_term ($sm_mk_z ($smt_apply_3 "str.indexof" x1 x2 x3))))
  (($smtx_model_eval_str.indexof t1 t2 t3) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.at
  ((x1 $smt_builtin_String) (x2 $smt_builtin_Int) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.at ($vsm_term ($sm_mk_str x1)) ($vsm_term ($sm_mk_z x2))) ($vsm_term ($sm_mk_str ($smt_apply_2 "str.at" x1 x2))))
  (($smtx_model_eval_str.at t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.prefixof
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.prefixof ($vsm_term ($sm_mk_str x1)) ($vsm_term ($sm_mk_str x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "str.prefixof" x1 x2))))
  (($smtx_model_eval_str.prefixof t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.suffixof
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.suffixof ($vsm_term ($sm_mk_str x1)) ($vsm_term ($sm_mk_str x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "str.suffixof" x1 x2))))
  (($smtx_model_eval_str.suffixof t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.rev
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.rev ($vsm_term ($sm_mk_str x1))) ($vsm_term ($sm_mk_str ($smt_apply_1 "str.rev" x1))))
  (($smtx_model_eval_str.rev t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.update
  ((x1 $smt_builtin_String) (x2 $smt_builtin_Int) (x3 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.update ($vsm_term ($sm_mk_str x1)) ($vsm_term ($sm_mk_z x2)) ($vsm_term ($sm_mk_str x3))) ($vsm_term ($sm_mk_str ($smt_apply_3 "str.update" x1 x2 x3))))
  (($smtx_model_eval_str.update t1 t2 t3) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.to_lower
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.to_lower ($vsm_term ($sm_mk_str x1))) ($vsm_term ($sm_mk_str ($smt_apply_1 "str.to_lower" x1))))
  (($smtx_model_eval_str.to_lower t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.to_upper
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.to_upper ($vsm_term ($sm_mk_str x1))) ($vsm_term ($sm_mk_str ($smt_apply_1 "str.to_upper" x1))))
  (($smtx_model_eval_str.to_upper t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.to_code
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.to_code ($vsm_term ($sm_mk_str x1))) ($vsm_term ($sm_mk_z ($smt_apply_1 "str.to_code" x1))))
  (($smtx_model_eval_str.to_code t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.from_code
  ((x1 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.from_code ($vsm_term ($sm_mk_z x1))) ($vsm_term ($sm_mk_str ($smt_apply_1 "str.from_code" x1))))
  (($smtx_model_eval_str.from_code t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.to_int
  ((x1 $smt_builtin_String) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.to_int ($vsm_term ($sm_mk_str x1))) ($vsm_term ($sm_mk_z ($smt_apply_1 "str.to_int" x1))))
  (($smtx_model_eval_str.to_int t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.from_int
  ((x1 $smt_builtin_Int) (t1 $smt_Value))
  :signature ($smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.from_int ($vsm_term ($sm_mk_z x1))) ($vsm_term ($sm_mk_str ($smt_apply_1 "str.from_int" x1))))
  (($smtx_model_eval_str.from_int t1) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.<=
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value))
  :signature ($smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.<= ($vsm_term ($sm_mk_str x1)) ($vsm_term ($sm_mk_str x2))) ($vsm_term ($sm_mk_bool ($smt_apply_2 "str.<=" x1 x2))))
  (($smtx_model_eval_str.<= t1 t2) $vsm_not_value)
  )
)
(program $smtx_model_eval_str.replace_all
  ((x1 $smt_builtin_String) (x2 $smt_builtin_String) (x3 $smt_builtin_String) (t1 $smt_Value) (t2 $smt_Value) (t3 $smt_Value))
  :signature ($smt_Value $smt_Value $smt_Value) $smt_Value
  (
  (($smtx_model_eval_str.replace_all ($vsm_term ($sm_mk_str x1)) ($vsm_term ($sm_mk_str x2)) ($vsm_term ($sm_mk_str x3))) ($vsm_term ($sm_mk_str ($smt_apply_3 "str.replace_all" x1 x2 x3))))
  (($smtx_model_eval_str.replace_all t1 t2 t3) $vsm_not_value)
  )
)


; An evaluator for all terms that we can reason about models.
; This is a recursive call.
; invariant: this must be a total function
; invariant: unless this method returns $vsm_not_value, it must be such that
;            it represents a unique SMT-LIB value, i.e. ($vsm_term t) is
;            forbidden unless t denotes a value.
(program $smtx_model_eval
  ((f $eo_Term) (y $eo_Term) (z $eo_Term)
   (val $smt_Value)
   ; generic parameters that may appear in terms to pattern match
   (x1 $eo_Term) (x2 $eo_Term) (x3 $eo_Term) (x4 $eo_Term) (x5 $eo_Term))
  :signature ($eo_Term) $smt_Value
  (
  ; ITE branches to the appropriate child.
  (($smtx_model_eval (ite x1 x2 x3))
    ($smtx_model_eval_ite ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  ; Equality insists on valueness and then reduces to an equality over datatypes
  ; in the deep embedding (vsm.Value), meaning it works for all types, including
  ; functions and uninterpreted sorts where values are not represented by terms.
  ; Note that the valueness predicate ensures this is sound. Moreover note that
  ; we do not invoke the type checker here. This means that if an ill-typed
  ; equality was given as input to this method, it would always evaluate to false.
  ; The caller of this method is responsible for ensuring that this behavior is
  ; either avoided or admissible.
  (($smtx_model_eval (= x1 x2))
    ($smtx_model_eval_= ($smtx_model_eval x1) ($smtx_model_eval x2)))
  ; evaluation of standard SMT symbols
  ; These calls will reference helper methods above, e.g. of the form
  ; $smtx_model_eval_*, or call builtin methods e.g. $smtx_eval_quant.
  (($smtx_model_eval (not x1)) ($smtx_model_eval_not ($smtx_model_eval x1)))
  (($smtx_model_eval (or x1 x2)) ($smtx_model_eval_or ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (and x1 x2)) ($smtx_model_eval_and ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (=> x1 x2)) ($smtx_model_eval_=> ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (xor x1 x2)) ($smtx_model_eval_xor ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (+ x1 x2)) ($smtx_model_eval_+ ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (- x1 x2)) ($smtx_model_eval_- ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (* x1 x2)) ($smtx_model_eval_* ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (< x1 x2)) ($smtx_model_eval_< ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (<= x1 x2)) ($smtx_model_eval_<= ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (> x1 x2)) ($smtx_model_eval_> ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (>= x1 x2)) ($smtx_model_eval_>= ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (to_real x1)) ($smtx_model_eval_to_real ($smtx_model_eval x1)))
  (($smtx_model_eval (to_int x1)) ($smtx_model_eval_to_int ($smtx_model_eval x1)))
  (($smtx_model_eval (is_int x1)) ($smtx_model_eval_is_int ($smtx_model_eval x1)))
  (($smtx_model_eval (abs x1)) ($smtx_model_eval_abs ($smtx_model_eval x1)))
  (($smtx_model_eval ($eoo_-.2 x1)) ($smtx_model_eval_$eoo_-.2 ($smtx_model_eval x1)))
  (($smtx_model_eval (div x1 x2)) ($smtx_model_eval_div ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (mod x1 x2)) ($smtx_model_eval_mod ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (int.pow2 x1)) ($smtx_model_eval_int.pow2 ($smtx_model_eval x1)))
  (($smtx_model_eval (div_total x1 x2)) ($smtx_model_eval_div_total ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (mod_total x1 x2)) ($smtx_model_eval_mod_total ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (/ x1 x2)) ($smtx_model_eval_/ ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (/_total x1 x2)) ($smtx_model_eval_/_total ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvand x1 x2)) ($smtx_model_eval_bvand ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvor x1 x2)) ($smtx_model_eval_bvor ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvxor x1 x2)) ($smtx_model_eval_bvxor ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (bvult x1 x2)) ($smtx_model_eval (bvugt x2 x1)))
  (($smtx_model_eval (bvule x1 x2)) ($smtx_model_eval (bvuge x2 x1)))
  (($smtx_model_eval (bvslt x1 x2)) ($smtx_model_eval (bvsgt x2 x1)))
  (($smtx_model_eval (bvsle x1 x2)) ($smtx_model_eval (bvsge x2 x1)))
  (($smtx_model_eval (str.len x1)) ($smtx_model_eval_str.len ($smtx_model_eval x1)))
  (($smtx_model_eval (str.++ x1 x2)) ($smtx_model_eval_str.++ ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.substr x1 x2 x3)) ($smtx_model_eval_str.substr ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  (($smtx_model_eval (str.contains x1 x2)) ($smtx_model_eval_str.contains ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.replace x1 x2 x3)) ($smtx_model_eval_str.replace ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  (($smtx_model_eval (str.indexof x1 x2 x3)) ($smtx_model_eval_str.indexof ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  (($smtx_model_eval (str.at x1 x2)) ($smtx_model_eval_str.at ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.prefixof x1 x2)) ($smtx_model_eval_str.prefixof ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.suffixof x1 x2)) ($smtx_model_eval_str.suffixof ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.rev x1)) ($smtx_model_eval_str.rev ($smtx_model_eval x1)))
  (($smtx_model_eval (str.update x1 x2 x3)) ($smtx_model_eval_str.update ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))
  (($smtx_model_eval (str.to_lower x1)) ($smtx_model_eval_str.to_lower ($smtx_model_eval x1)))
  (($smtx_model_eval (str.to_upper x1)) ($smtx_model_eval_str.to_upper ($smtx_model_eval x1)))
  (($smtx_model_eval (str.to_code x1)) ($smtx_model_eval_str.to_code ($smtx_model_eval x1)))
  (($smtx_model_eval (str.from_code x1)) ($smtx_model_eval_str.from_code ($smtx_model_eval x1)))
  (($smtx_model_eval (str.to_int x1)) ($smtx_model_eval_str.to_int ($smtx_model_eval x1)))
  (($smtx_model_eval (str.from_int x1)) ($smtx_model_eval_str.from_int ($smtx_model_eval x1)))
  (($smtx_model_eval (str.<= x1 x2)) ($smtx_model_eval_str.<= ($smtx_model_eval x1) ($smtx_model_eval x2)))
  (($smtx_model_eval (str.replace_all x1 x2 x3)) ($smtx_model_eval_str.replace_all ($smtx_model_eval x1) ($smtx_model_eval x2) ($smtx_model_eval x3)))


  ;; free constants
  ; Constants carry their value in the model, which is an arbitrary value term.
  ; We run this value through $smtx_ensure_value to ensure it is a proper value.
  (($smtx_model_eval ($sm_Const val))           ($smtx_ensure_value val))
  
  ; Apply case. We evaluate f and y separately and then call the
  ; $smtx_model_eval_apply above. We expect f to be an uninterpreted
  ; function whose model evaluation is an SMT-LIB map in this case.
  ; All interpreted f should be handled in the evaluation cases above.
  (($smtx_model_eval (f y))
    ($smtx_model_eval_apply ($smtx_model_eval f) ($smtx_model_eval y)))

  ; Otherwise, it may be a term value (e.g. if z is a Boolean or numeral constant).
  ; We call the utility method which will either generate an SMT-LIB term value or
  ; a SMT-LIB non-value error term.
  (($smtx_model_eval z)                         ($smt_mk_value_term z))
  )
)

; program: $smtx_model_sat
(program $smtx_model_sat ((val $smt_Value))
  :signature ($smt_Value) $eo_Option
  (
  (($smtx_model_sat $vsm_true)  ($eo_Option_some true))
  (($smtx_model_sat $vsm_false) ($eo_Option_some false))
  (($smtx_model_sat val)        $eo_Option_null)
  )
)

; program: $smtx_model_sat_combined
; args:
; - isInput Bool: Whether it is legal SMT-LIB input syntax.
; - T Type: Its type.
; - val $smt_Value: The result of model value.
(program $smtx_model_sat_combined ((b Bool) (T Type) (val $smt_Value))
  :signature (Bool Type $smt_Value) $eo_Option
  (
  (($smtx_model_sat_combined true Bool $vsm_true)  ($eo_Option_some true))
  (($smtx_model_sat_combined true Bool $vsm_false) ($eo_Option_some false))
  (($smtx_model_sat_combined b T val)        $eo_Option_null)
  )
)

;;; type of

; forward decl
(program $smtx_typeof () :signature ($eo_Term) $eo_Term)
(program $smtx_typeof_value () :signature ($smt_Value) $eo_Term)

(program $smtx_mk_fun_type_internal
  ((T $eo_Term) (U $eo_Term) (Tt $eo_Term) (Ut $eo_Term))
  :signature ($eo_Term $eo_Term $eo_Term $eo_Term) $eo_Term
  (
  (($smtx_mk_fun_type_internal T U Type Type) ($eo_mk_fun_type T U))
  (($smtx_mk_fun_type_internal T U Tt Ut)     $eo_null_type)
  )
)

; note: Helper for below.
(program $smtx_typeof_map ((T $smt_builtin_Int) (j $smt_Value) (e $smt_Value) (m $smt_Map))
  :signature ($smt_builtin_Int $smt_Map) $eo_Term
  (
  ; we rely on the reverse hash
  (($smtx_typeof_map T ($msm_cons j e m))   ($eo_mk_fun_type ($eo_reverse_hash ($eo_mk_numeral T)) ($smtx_typeof_value e)))
  (($smtx_typeof_map T ($msm_default e))    ($eo_mk_fun_type ($eo_reverse_hash ($eo_mk_numeral T)) ($smtx_typeof_value e)))
  )
)

; note: Helper for below. This is analogous to the method $eo_typeof_apply
(program $smtx_typeof_apply ((T $eo_Term) (U $eo_Term))
  :signature ($eo_Term $eo_Term) $eo_Term
  (
  (($smtx_typeof_apply ($eo_mk_fun_type T U) T) U)
  )
)

(program $smtx_typeof_value
  ((val $smt_Value) (T $smt_builtin_Int) (m $smt_Map) (id $smt_builtin_Int) (f $smt_Value) (a $smt_Term) (U $smt_Type))
  :signature ($smt_Value) $eo_Term
  (
  (($smtx_typeof_value ($vsm_apply f val))
    ($smtx_typeof_apply ($smtx_typeof_value f) ($smtx_typeof_value val)))
  ; the type of a value term is the type of its term.
  (($smtx_typeof_value ($vsm_term a))         ($smtx_typeof ($eo_smt_term a)))
  (($smtx_typeof_value ($vsm_map T m))        ($smtx_typeof_map T m))
  ; the type of uninterpreted constants carry its type.
  (($smtx_typeof_value ($vsm_uconst T id))    ($eo_reverse_hash ($eo_mk_numeral T)))
  ; the type of not-values is the null sort.
  (($smtx_typeof_value val)                   $eo_null_type)
  )
)

; The EO model typeof function, which incorporates SMT terms introduced in the
; model_smt layer.
; This is intended to cover all Eunoia and SMT terms (those of the form
; (eo.SmtTerm *). Since values are embedded into SMT terms, we cover SMT values,
; i.e. those of the form (eo.SmtValue *) as well.
; Furthermore note:
; - (SMT terms in $eo_typeof_main): sm.True, sm.False
; - (SMT terms in $eo_typeof): sm.Numeral, sm.Rational, sm.String, sm.Binary
; - (SMT terms handled below): sm.Const, sm.Apply
; - (EO terms in $eo_typeof_main): eo.Type, eo.FunType, eo.Apply
; - (EO terms in $eo_typeof): eo.Var
; - (EO terms intentionally unhandled): eo.Stuck, eo.SmtType
; invariant: all terms introduced by this layer must be given a type rule here.
; TODO: use hash for the nullsort below?
(program $smtx_typeof
  ((t $eo_Term) (val $smt_Value) (T $eo_Term) (m $smt_Map) (id $smt_builtin_Int)
   (f $smt_Value) (a $smt_Term) (U $smt_Type))
  :signature ($eo_Term) $eo_Term
  (
  ; the function type is a first class term in this embedding, requires a case
  (($smtx_typeof $eo_fun_type)                        Type)
  ; the type of an atomic type uses Eunoia's typeof builtin, or null sort if this fails.
  (($smtx_typeof ($eo_smt_type U))                    ($smt_try_typeof U))
  ; the type of a constant is the type of its value.
  (($smtx_typeof ($eo_smt_term ($sm_Const val)))      ($smtx_typeof_value val))
  ; similar to above, we try Eunoia's typeof, or null sort.
  (($smtx_typeof ($eo_smt_term a))                    ($smt_try_typeof a))
  ; For all other terms, we try Eunoia's typeof, or null sort.
  (($smtx_typeof t)                                   ($smt_try_typeof t))
  )
)

;;; SMT input

; program: $smtx_is_input
(program $smtx_is_input
  ((t $eo_Term) (a $eo_Term) (s $smt_Term) (T $smt_Type) (v $smt_Value))
  :signature ($eo_Term) Bool
  (
  (($smtx_is_input ($eo_apply t a))
    ($eo_if_both ($smtx_is_input t) ($smtx_is_input a)))
  (($smtx_is_input ($eo_smt_term ($sm_Const v)))  ($eo_mk_bool ($smtx_is_value v)))
  (($smtx_is_input ($eo_smt_term s))              true)
  (($smtx_is_input ($eo_smt_type T))              true)
  (($smtx_is_input t)                             false)
  )
)

;;;;;;;;;;;;;;;;;;;;;;

; program: $eo_model_sat
; note: F is satisfied by the model if F evaluates to the SMT-LIB value denoting true.
; We expect the input to this method to be a Eunoia term denoting an SMT-LIB formula
; (term of Boolean type).
(program $eo_model_sat ((F Bool))
  :signature (Bool) $eo_Option
  (
  (($eo_model_sat F) ($smtx_model_sat ($smtx_model_eval F)))
  )
)

; program: $eo_model_typeof
; note: F is satisfied by the model if F evaluates to the SMT-LIB value denoting true.
; We expect the input to this method to be a Eunoia term denoting an SMT-LIB formula
; (term of Boolean type).
(program $eo_model_typeof ((F Bool))
  :signature (Bool) Type
  (
  (($eo_model_typeof F) ($smtx_typeof F))
  )
)

; program: $eo_model_is_input
; return: true if this is a legal SMT-LIB input term or type.
(program $eo_model_is_input ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_is_input F) ($smtx_is_input F))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; model_end
(program $eor_evaluate.fev1 ((U Type) (t U) ($eo_1 U))
  :signature (U U) Bool
  (
  (($eor_evaluate.fev1 t $eo_1) (_ (= t) $eo_1))
  )
)
(program $eor_evaluate ((U Type) (t U))
  :signature (U) Bool
  (
  (($eor_evaluate t) ($eor_evaluate.fev1 t ($run_evaluate t)))
  )
)
(program $eovc_evaluate ((U Type) (t U))
  :signature (U) Bool
  (
  (($eovc_evaluate t) (eo::define ((_v0 ($eor_evaluate t))) ($eo_requires_eq ($eo_model_is_input _v0) true ($eo_requires_eq ($eo_model_sat _v0) ($eo_Option_some false) true))))
  )
)
(echo "smt-meta $eovc_evaluate :deps $smtx_model_lookup_predicate $eo_hash $eo_reverse_hash $tsm_Bool $eo_type $eo_fun_type ")
