; trim-defs: $eovc_symm $eo_typeof_main $eo_String $eo_Numeral $eo_Rational $eo_Binary $eo_List $eo_List_nil $eo_List_cons $eo_is_bool $eo_is_z $eo_is_q $eo_is_str $eo_is_bin $eo_dt_constructors $eo_dt_selectors $eo_model_sat $eo_model_eval $eo_model_Const $eo_model_Const_pred $eo_model_binary_width
; #trim-defs: 48
(define $eo_fail () (eo::requires true false true))
(declare-const $eo_undef_type Type)
(program $eo_typeof ((T Type))
  :signature (T) Type)
(declare-const Int Type)
(declare-consts <numeral> Int)
(declare-const Real Type)
(declare-consts <rational> Real)
(declare-const BitVec (-> Int Type))
(declare-consts <binary> (BitVec (eo::len eo::self)))
(declare-const Char Type)
(declare-const Seq (-> Type Type))
(declare-consts <string> (Seq Char))
(define $eo_Numeral () Int)
(define $eo_Rational () Real)
(define $eo_String () (Seq Char))
(define $eo_Binary () $eo_undef_type)
(program $eo_model_sat () :signature (Bool) Bool)
(program $eo_model_eval ((T Type)) :signature (T) T)
(declare-parameterized-const $eo_model_Const ((k $eo_Numeral) (id $eo_Numeral) (T Type)) T)
(define $eo_model_binary_width ((T Type))
  $eo_fail)
(declare-const $eo_List Type)
(declare-const $eo_List_nil $eo_List)
(declare-parameterized-const $eo_List_cons ((T Type :implicit))
  (-> T $eo_List $eo_List)
  :right-assoc-nil $eo_List_nil)
(program $eo_dt_constructors ((T Type))
  :signature (Type) $eo_List)
(program $eo_dt_selectors ((T Type) (t T))
  :signature (T) $eo_List)
(program $eo_eq ((T Type) (S Type) (t T) (s S))
  :signature (T S) Bool
  (
  (($eo_eq t t) true)
  (($eo_eq t s) false)
  )
)
(define $eo_is_eq ((T Type :implicit) (S Type :implicit) (t T) (s S))
  (eo::ite (eo::and (eo::is_ok t) (eo::is_ok s)) ($eo_eq s t) false))
(define $eo_is_z ((T Type :implicit) (x T))
  ($eo_is_eq (eo::to_z x) x))
(define $eo_is_q ((T Type :implicit) (x T))
  ($eo_is_eq (eo::to_q x) x))
(define $eo_is_bin ((T Type :implicit) (x T))
  ($eo_is_eq (eo::to_bin (eo::len x) x) x))
(define $eo_is_str ((T Type :implicit) (x T))
  ($eo_is_eq (eo::to_str x) x))
(define $eo_is_bool ((T Type :implicit) (x T))
  (eo::ite ($eo_is_eq x true) true ($eo_is_eq x false)))
(declare-parameterized-const $eo_Var ((s $eo_String) (T Type)) T)
(declare-const not (-> Bool Bool))
(declare-const and (-> Bool (-> Bool Bool)))
(declare-parameterized-const = ((A Type :implicit) ($eo_x_1 A) ($eo_x_2 A)) Bool)
(program $mk_symm ((T Type) (t2 T) (t1 T))
  :signature (Bool) Bool
  (
  (($mk_symm (_ (= t1) t2)) (_ (= t2) t1))
  (($mk_symm (not (_ (= t1) t2))) (not (_ (= t2) t1)))
  )
)
(program $eo_typeof_apply ((T Type) (U Type) (V Type))
  :signature (Type Type) Type
  (
  (($eo_typeof_apply (-> T U) T) U)
  )
)
(program $eo_typeof_= (($eo_T Type) (A Type))
  :signature ($eo_T) Type
  (
  (($eo_typeof_= A) (-> A Bool))
  )
)
(program $eo_typeof_main
  ((T Type) (U Type) (V Type) (W Type) (f (-> U V T)) (x U) (t T)
   (W1 Type) (x1 W1) (W2 Type) (x2 W2) (W3 Type) (x3 W3)) 
  :signature (T) Type
  (
  (($eo_typeof_main Type)      Type)
  (($eo_typeof_main (-> T U))  (eo::requires ($eo_typeof T) Type
                               (eo::requires ($eo_typeof U) Type
                                 Type)))
  (($eo_typeof_main Bool)      Type)
  (($eo_typeof_main true)      Bool)
  (($eo_typeof_main false)     Bool)
  
  (($eo_typeof_main Int) Type)
  
  (($eo_typeof_main Real) Type)
  
  (($eo_typeof_main BitVec) (-> Int Type))
  
  (($eo_typeof_main Char) Type)
  
  (($eo_typeof_main Seq) (-> Type Type))
  
  (($eo_typeof_main not) (-> Bool Bool))
  
  (($eo_typeof_main and) (-> Bool (-> Bool Bool)))
  
  (($eo_typeof_main (= x1)) ($eo_typeof_= ($eo_typeof x1)))

  (($eo_typeof_main (f x))     ($eo_typeof_apply ($eo_typeof f) ($eo_typeof x)))
  )
)
(program $eo_dt_constructors
  ((T Type))
  :signature (Type) $eo_List
  (

  (($eo_dt_constructors T) $eo_fail)
  )
)
(program $eo_dt_selectors ((T Type) (t T))
  :signature (T) $eo_List
  (

  (($eo_dt_selectors t) $eo_fail)
  )
)
(program $eo_typeof ((T Type) (t T) (s $eo_String))
  :signature (T) Type
  (
  (($eo_typeof ($eo_Var s T)) T)
  (($eo_typeof t) (eo::ite ($eo_is_bool t) Bool
                  (eo::ite ($eo_is_z t) $eo_Numeral
                  (eo::ite ($eo_is_q t) $eo_Rational
                  (eo::ite ($eo_is_str t) $eo_String
                  (eo::ite ($eo_is_bin t) $eo_Binary
                    ($eo_typeof_main t)))))))
  )
)
(program $eo_model_Const_pred ((k $eo_Numeral) (i $eo_Numeral) (T Type))
  :signature ($eo_Numeral $eo_Numeral (eo::quote T)) T
  (
  
  (($eo_model_Const_pred 0 i T) true)

  (($eo_model_Const_pred k i T) $eo_fail)
  )
)
(program $eo_model_eval ((T Type) (t T))
  :signature (T) T
  (

  (($eo_model_eval t) $eo_fail)
  )
)
(program $eorx_symm ((F Bool))
  :signature (Bool Type) Bool
  (
  (($eorx_symm F Bool) ($mk_symm F))
  )
)
(program $eor_symm ((F Bool))
  :signature (Bool) Bool
  (
  (($eor_symm F) ($eorx_symm F (eo::typeof F)))
  )
)
(program $eovc_symm ((F Bool))
  :signature (Bool) Bool
  (
  (($eovc_symm F)
     (eo::requires ($eo_model_sat F) true
     (eo::requires ($eo_model_sat ($eor_symm F)) false
       true)))
  )
)

; This file is a formalization of the SMT-LIB semantics in Eunoia.
; It uses a deep embedding of SMT-LIB terms .
; This file is expected to define function $eo_model_sat, which can be used 
; to define whether a (Boolean) term is satisfied by a model.
; It generates symbols $smt_Term, $sym_apply_*, $eo_to_smt_*, and $smt_to_eo_*,
; which have further meaning in the compilation pipeline.

; Forward declaration of the main method defined by this signature.
; We use this to define $eo_model_sat.
(program $smt_model_eval ((T Type)) :signature (T) T)

; These functions will be handled by smt_meta.

; An SMT-LIB term.
(declare-const $smt_Term Type)

; Apply the SMT operator named "op" to x1, x2, and so on.
; Assumes arity of SMT-LIB operators are at most 5.
(declare-parameterized-const $smt_apply_1
  ((W1 Type :implicit))
  (-> $eo_String W1 $smt_Term))
(declare-parameterized-const $smt_apply_2
  ((W1 Type :implicit) (W2 Type :implicit))
  (-> $eo_String W1 W2 $smt_Term))
(declare-parameterized-const $smt_apply_3
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit))
  (-> $eo_String W1 W2 W3 $smt_Term))
(declare-parameterized-const $smt_apply_4
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit))
  (-> $eo_String W1 W2 W3 W4 $smt_Term))
(declare-parameterized-const $smt_apply_5
  ((W1 Type :implicit) (W2 Type :implicit) (W3 Type :implicit) (W4 Type :implicit) (W5 Type :implicit))
  (-> $eo_String W1 W2 W3 W4 W5 $smt_Term))

; Convert from Eunoia to an SMT value
; These assume the Eunoia term is a literal of the correct type.
; All uses of the $eo_to_smt_* methods must ensure this is the case
; Convert Eunoia Boolean to an smt Boolean.
(declare-const $eo_to_smt_bool (-> Bool $smt_Term))
; Convert Eunoia Numeral to an smt Integer.
(declare-const $eo_to_smt_z (-> $eo_Numeral $smt_Term))
; Convert Eunoia Rational to an smt Real.
(declare-const $eo_to_smt_q (-> $eo_Rational $smt_Term))
; Convert Eunoia String to an smt String.
(declare-const $eo_to_smt_str (-> $eo_String $smt_Term))
; Convert Eunoia Binary to an smt-meta representation of Binary.
(declare-const $eo_to_smt_bin (-> $eo_Binary $smt_Term))
; Convert smt2 term to a Eunoia Boolean.
(declare-const $smt_to_eo_bool (-> $smt_Term Bool))
; Convert smt2 term to a Eunoia numeral.
(declare-const $smt_to_eo_z (-> $smt_Term $eo_Numeral))
; Convert smt2 term to a Eunoia rational.
(declare-const $smt_to_eo_q (-> $smt_Term $eo_Rational))
; Convert smt2 term to a Eunoia string.
(declare-const $smt_to_eo_str (-> $smt_Term $eo_String))
; Convert smt2 term to a Eunoia binary.
(declare-const $smt_to_eo_bin (-> $smt_Term $eo_Binary))

;;; definitions of Valueness

; represents an unknown value
; This must be a constructor in the final sm.Term.
(declare-parameterized-const $smt_unknown_type_enum ((T Type) (i $eo_Numeral)) T)

; re-bootstrap version of list operators, monomorphized for $eo_List.
; We only define what is necessary.

(program $eo_List_concat
  ((T Type) (x T) (y $eo_List) (z $eo_List))
  :signature ($eo_List $eo_List) $eo_List
  (
  (($eo_List_concat ($eo_List_cons x y) z)  ($eo_List_cons x ($eo_List_concat y z)))
  (($eo_List_concat $eo_List_nil z)         z)
  )
)

;;; definitions of Type enumeration

; note: The methods in this section are only included (based on trim-defs) if
; the verification condition is reasoning about quantified formuls.

(declare-const @smt_RatPair Type)
(declare-const @smt_ratPair (-> $eo_Numeral $eo_Numeral @smt_RatPair))

; Based on Calkinâ€“Wilf tree.
;(program $smt_rat_enum_rec () :signature ($eo_Numeral $eo_List) @smt_RatPair)
(program $smt_rat_enum_rec
  ((i $eo_Numeral) (n $eo_Numeral) (d $eo_Numeral) (r @smt_RatPair) (rs $eo_List))
  :signature ($eo_Numeral $eo_List) @smt_RatPair
  (
  (($smt_rat_enum_rec 0 ($eo_List_cons r rs)) r)
  (($smt_rat_enum_rec i ($eo_List_cons (@smt_ratPair n d) rs))
     (eo::define ((r1 (@smt_ratPair (eo::add n d) d)))
     (eo::define ((r2 (@smt_ratPair n (eo::add n d))))
      ($smt_rat_enum_rec (eo::add i -1)
        ($eo_List_concat rs ($eo_List_cons r1 ($eo_List_cons r2 $eo_List_nil)))))))
  )
)

(define $smt_rat_enum ((i $eo_Numeral))
  ($smt_rat_enum_rec i ($eo_List_cons (@smt_ratPair 1 1) $eo_List_nil)))

(program $smt_rat_to_num ((n $eo_Numeral) (d $eo_Numeral))
  :signature ($eo_Numeral) $eo_Rational
  (
  (($smt_rat_to_num (@smt_ratPair n d)) (eo::qdiv n d))
  )
)

; we have no incorporate of irrational values, which can be soundly approximated using
; $smt_unknown_type_enum.
(define $smt_irrat_enum ((i $eo_Numeral))
 ($smt_unknown_type_enum $eo_Rational i))

(program $smt_type_enum ((T Type) (i $eo_Numeral)
   ; generic parameters that may appear in terms to pattern match
   (W1 Type) (x1 W1) (W2 Type) (x2 W2) (W3 Type) (x3 W3) (W4 Type) (x4 W4) (W5 Type) (x5 W5))
  :signature ((eo::quote T) $eo_Numeral) T
  (
  ; enumeration of standard SMT types
  (($smt_type_enum $eo_Numeral i)   (eo::define ((v (eo::zdiv i 2)))
                                      (eo::ite (eo::eq (eo::zmod i 2) 0) v (eo::neg v))))
  (($smt_type_enum $eo_String i)    (eo::ite (eo::eq i 0)
                                      ""
                                      (eo::concat (eo::to_str (eo::zmod i 196608)) ($smt_type_enum $eo_String (eo::zdiv i 196608)))))
  ; rationals are treated as Real, meaning we interleave rational/irrational.
  (($smt_type_enum $eo_Rational i)  (eo::define ((ir (eo::zdiv i 2)))
                                    (eo::define ((isRat (eo::eq (eo::zmod ir 2) 0)))
                                    (eo::define ((i (eo::zdiv ir 2)))
                                    (eo::define ((v (eo::ite isRat ($smt_rat_to_num ($smt_rat_enum i)) ($smt_irrat_enum i))))
                                      (eo::ite (eo::eq (eo::zmod i 2) 0) v (eo::neg v)))))))

  ; NOTE: this assumes that (BitVec _) is a parmetric type, thus we look for it with $eo_model_binary_width.
  (($smt_type_enum T i)             (eo::define ((w ($eo_model_binary_width T)))
                                    (eo::define ((v (eo::to_bin w i)))
                                      (eo::ite (eo::is_ok w)
                                        (eo::requires (eo::to_z v) i v)
                                        ; otherwise, uninterpreted constant
                                        ; note since this always succeeds, this assumes that unhandled types have infinite type
                                        ($smt_unknown_type_enum T i)))))
  )
)

; Type enumeration contains

(program $smt_type_enum_contains_rec ((T Type) (t T) (i $eo_Numeral))
  :signature ((eo::quote T) T $eo_Numeral) Bool
  (
  (($smt_type_enum_contains_rec T t i)  (eo::define ((v ($smt_type_enum T i)))
                                        (eo::ite (eo::is_ok v)
                                          (eo::ite (eo::eq v t)
                                            true
                                            ($smt_type_enum_contains_rec T i (eo::add i 1)))
                                          false)))
  )
)

; Can be use as a default implementation for valueness.
; This is not included by default in $smt_is_value below to ensure
; dependencies are clean.
(define $smt_type_enum_contains ((T Type :implicit) (x T))
  ($smt_type_enum_contains_rec ($eo_typeof x) x 0))

; program: $smt_substitute
; Used to define $smt_model_eval_quant.
(program $smt_substitute
  ((T Type) (U Type) (S Type) (x S) (y S) (f (-> T U)) (a T) (z U))
  :signature (S S U) U
  (
  (($smt_substitute x y (f a))         (_ ($smt_substitute x y f) ($smt_substitute x y a)))
  (($smt_substitute x y x)             y)
  (($smt_substitute x y z)             z)
  )
)

; program: $smt_model_eval_quant
; specification for exists is a (non-computable) function
; The last argument is whether we are check exists (resp. forall).
(program $smt_model_eval_quant ((T Type) (x T) (xs $eo_List) (F Bool) (i $eo_Numeral) (isExists Bool))
  :signature ($eo_List Bool $eo_Numeral Bool) Bool
  (
  (($smt_model_eval_quant $eo_List_nil F i isExists)
    ; base case: we have processed all variables, recurse, negate if isExists is false.
    (eo::eq ($smt_model_eval F) isExists))  ; FIXME
  (($smt_model_eval_quant ($eo_List_cons x xs) F i isExists)
    ; get the next value in the type enumeration
    (eo::define ((next ($smt_type_enum (eo::typeof x) i)))
    ; if it exists
    (eo::ite (eo::is_ok next)
      ; evaluate the body for this value. if this is a forcing value, return it
      (eo::ite (eo::eq ($smt_model_eval ($smt_substitute x next F)) isExists)
        isExists
        ; otherwise recurse for the next value in the type enumeration for the current variable
        ($smt_model_eval_quant ($eo_List_cons x xs) F (eo::add i 1) isExists))
      (eo::not isExists)))) ; out of values,
  )
)

; definitions of Values

; forward declaration
(program $smt_is_value ((T Type)) :signature ((eo::quote T) T) Bool)

; define: $smt_dt_is_cons
; returns: true if t is a datatpe (i.e. it has constructors).
(define $smt_is_dt ((T Type :implicit) (t T))
  (eo::is_ok ($eo_dt_constructors t)))

; define: $smt_is_dt_cons
; returns: true if t is a constructor (i.e. it has selectors).
(define $smt_is_dt_cons ((T Type :implicit) (t T))
  (eo::is_ok ($eo_dt_selectors t)))

; program: $smt_dt_is_value
; Returns true if its argument is a datatype value.
(program $smt_dt_is_value
  ((U Type) (T Type) (f (-> T U)) (a T) (c U))
  :signature (U) Bool
  (
  (($smt_dt_is_value (f a))  (eo::ite ($smt_is_value a) ($smt_dt_is_value f) false))
  (($smt_dt_is_value c)      ($smt_is_dt_cons c))
  )
)

; program: $smt_dt_is_value
; Returns true if its argument is an SMT value.
(program $smt_is_value ((T Type) (t T)
   ; generic parameters that may appear in terms to pattern match
   (W1 Type) (x1 W1) (W2 Type) (x2 W2) (W3 Type) (x3 W3))
  :signature ((eo::quote T) T) Bool
  (
  ; if the literal type is not defined, this is false
  (($smt_is_value $eo_undef_type t) false)
  ; standard atomic types
  (($smt_is_value $eo_Numeral t)      ($eo_is_z t))
  (($smt_is_value $eo_Rational t)     ($eo_is_q t))
  (($smt_is_value $eo_String t)       ($eo_is_str t))
  (($smt_is_value $eo_Binary t)       ($eo_is_bin t))
  ; TODO: Arrays? Sets? Seq?

  (($smt_is_value T t) false)
  )
)

;;; Core definition of $smt_model_eval

; fwd-decl: $smt_model_lookup
; Conceptually, returns the model value for constant with identifier id and type T.
; This is intentionally undefined in this signature.
(program $smt_model_lookup ((T Type))
  :signature ($eo_Numeral T) T)

(define $smt_eval_o_arith_unary
  ((W1 Type :implicit) (W2 Type :implicit) (op $eo_String) (x1 W1))
  (eo::ite ($eo_is_z x1)
    ($smt_to_eo_z ($smt_apply_1 op ($eo_to_smt_z x1)))
  (eo::ite ($eo_is_q x1)
    ($smt_to_eo_q ($smt_apply_1 op ($eo_to_smt_q x1)))
    $eo_fail)))

(define $smt_eval_o_arith
  ((W1 Type :implicit) (W2 Type :implicit) (op $eo_String) (x1 W1) (x2 W2))
  (eo::ite (eo::and ($eo_is_z x1) ($eo_is_z x2))
    ($smt_to_eo_z ($smt_apply_2 op ($eo_to_smt_z x1) ($eo_to_smt_z x2)))
  (eo::ite (eo::and ($eo_is_q x1) ($eo_is_q x2))
    ($smt_to_eo_q ($smt_apply_2 op ($eo_to_smt_q x1) ($eo_to_smt_q x2)))
    $eo_fail)))

(define $smt_eval_o_arith_pred
  ((W1 Type :implicit) (W2 Type :implicit) (op $eo_String) (x1 W1) (x2 W2))
  (eo::ite (eo::and ($eo_is_z x1) ($eo_is_z x2))
    ($smt_to_eo_bool ($smt_apply_2 op ($eo_to_smt_z x1) ($eo_to_smt_z x2)))
  (eo::ite (eo::and ($eo_is_q x1) ($eo_is_q x2))
    ($smt_to_eo_bool ($smt_apply_2 op ($eo_to_smt_q x1) ($eo_to_smt_q x2)))
    $eo_fail)))

; An evaluator for all terms that we can reason about models.
; This is a recursive call.
(program $smt_model_eval
  ((T Type) (U Type) (V Type) (a1 T) (a2 T) (c Bool) (f (-> U T)) (y U) (z T) (k $eo_Numeral) (i $eo_Numeral) (F Bool)
   ; generic parameters that may appear in terms to pattern match
   (W1 Type) (x1 W1) (W2 Type) (x2 W2) (W3 Type) (x3 W3))
  :signature (T) T
  (
  ; evaluation of standard SMT symbols
  (($smt_model_eval (not x1)) (eo::define ((e1 ($smt_model_eval x1))) (eo::requires ($smt_is_value (eo::typeof x1) e1) true ($smt_to_eo_bool ($smt_apply_1 "not" ($eo_to_smt_bool e1))))))
  (($smt_model_eval (and x1 x2)) (eo::define ((e1 ($smt_model_eval x1))) (eo::requires ($smt_is_value (eo::typeof x1) e1) true (eo::define ((e2 ($smt_model_eval x2))) (eo::requires ($smt_is_value (eo::typeof x2) e2) true ($smt_to_eo_bool ($smt_apply_2 "and" ($eo_to_smt_bool e1) ($eo_to_smt_bool e2))))))))
  (($smt_model_eval (= x1 x2)) (eo::define ((e1 ($smt_model_eval x1))) (eo::requires ($smt_is_value (eo::typeof x1) e1) true (eo::define ((e2 ($smt_model_eval x2))) (eo::requires ($smt_is_value (eo::typeof x2) e2) true (eo::eq e1 e2))))))

  ; free constants
  ; These are given an arbitrary value by the model ($smt_model_lookup).
  ; We then check if their property F is satisfied. If so, then they are
  ; interpreted to be this value. Otherwise, they are unevaluated.
  ; FIXME: must apply substitution to F.
  (($smt_model_eval ($eo_model_Const k i T))  (eo::define ((val ($smt_model_lookup i T)))
                                              (eo::ite ($smt_model_eval ($eo_model_Const_pred k i T))
                                                val
                                                ($eo_model_Const k i T))))
  ; generic apply and base case.
  ; these do not insist that the term is a value.
  ; They call the user callback $eo_model_eval.
  (($smt_model_eval (f y))                (eo::define ((fme ($smt_model_eval f)))
                                          (eo::define ((yme ($smt_model_eval y)))
                                            ($eo_model_eval (_ fme yme)))))
  (($smt_model_eval z)                    ($eo_model_eval z))
  )
)

; program: $eo_model_sat
; note: Satisfied by the model if F evaluates to true.
(program $eo_model_sat ((F Bool))
  :signature (Bool) Bool
  (
  (($eo_model_sat F) ($smt_model_eval F))
  )
)

